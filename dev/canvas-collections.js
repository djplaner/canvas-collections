GM_addStyle(GM_getResourceText('css'));
var app = (function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                else
                    this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    /**
     * Associates an arbitrary `context` object with the current component and the specified `key`
     * and returns that object. The context is then available to children of the component
     * (including slotted content) with `getContext`.
     *
     * Like lifecycle functions, this must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-setcontext
     */
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
        return context;
    }
    /**
     * Retrieves the context that belongs to the closest parent component with the specified `key`.
     * Must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-getcontext
     */
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update$1(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind(component, name, callback, value) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            if (value === undefined) {
                callback(component.$$.ctx[index]);
            }
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.55.0' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    /* jshint esversion: 6 */
    class UniversityDateCalendar {
        constructor(strm = DEFAULT_PERIOD) {
            //public static getInstance(strm = DEFAULT_PERIOD): UniversityDateCalendar {
            if (strm && CALENDAR[strm]) {
                this.defaultPeriod = strm;
            }
        }
        setStudyPeriod(studyPeriod) {
            this.defaultPeriod = studyPeriod;
        }
        getStudyPeriod() {
            return this.defaultPeriod;
        }
        /**
         * @function getHumanReadableStudyPeriod
         * @returns {String} the human readable version of the current study period
         * @description Current implemented for Griffith course id's version of term code
         * https://intranet.secure.griffith.edu.au/computing/using-learning-at-griffith/staff/administration/course-ID
         * Four digits
         * - first digit is the type of course
         * - middle two digits are the year (20 + XX)
         * - final digit is the term
         */
        getHumanReadableStudyPeriod() {
            const termMap = {
                // OUA courses
                2: {
                    1: "Study Period 1",
                    2: "Session 1",
                    3: "Study Period 2",
                    4: "Session 2",
                    5: "Study Period 3",
                    6: "Session 3",
                    7: "Study Period 4",
                },
                3: {
                    1: "Trimester 1",
                    5: "Trimester 2",
                    8: "Trimester 3",
                },
                6: {
                    1: "Teaching Period 1",
                    2: "Teaching Period 2",
                    3: "Teaching Period 3",
                    4: "Teaching Period 4",
                    5: "Teaching Period 5",
                    6: "Teaching Period 6",
                },
            };
            // extract the first, middle two and last digital from defaultPeriod
            const courseType = this.defaultPeriod[0];
            const year = this.defaultPeriod.slice(1, 3);
            const term = this.defaultPeriod[3];
            return `${termMap[courseType][term]} 20${year}`;
        }
        /**
         * @function getWeekDetails
         * @param {String} period
         * @param {String} week
         * @returns {Object} the correct start/stop dates for the givern period/week
         * null if doesn't exist
         * if no week specified, returns the object for the STRM that specifies the
         * weeks
         */
        getWeekDetails(week = "all", period = this.defaultPeriod) {
            // by default return the object for the current period
            if (week === "all") {
                return CALENDAR[period];
            }
            // if week is a string starting with "Week" remove
            // the Week and convert number of integer
            if (typeof week === "string" && week.startsWith("Week")) {
                //week = parseInt(week.substring(4));
                week = week.substring(4);
            }
            // only proceed if the period and week are in the CALENDAR
            if (!(period in CALENDAR)) {
                return null;
            }
            else if (!(week in CALENDAR[period])) {
                return null;
            }
            return CALENDAR[period][week];
        }
        getDaysOfWeek() {
            return DAYS_OF_WEEK;
        }
        /**
         * Generate a object that specifies the full date for a given study period date.
         * e.g. converts Tuesday Week 1 to
         * { date: "", month: "", week: 1: year: 2019 }
         * Based on the specified study period and the calendar above
         * @param {Integer} week - week of university term
         * @param {Boolean} startWeek - if true, returns the start date of the week
         * @param {String} dayOfWeek - specify the day to return
         * @returns {Object} specifying the day, month, year of the week
         */
        getDate(week, startWeek = true, dayOfWeek = "Monday") {
            let date = {
                day: "",
                date: "",
                month: "",
                week: week,
                year: 0,
            };
            // lowercase dayOfWeek
            dayOfWeek = dayOfWeek.toLowerCase();
            // get the details for the given week
            let weekDetails = this.getWeekDetails(week);
            // if no details for the week, return empty date
            if (weekDetails === null) {
                return date;
            }
            // weekDetails/date format
            // 0: { start: "2022-03-07", stop: "2022-03-13" },
            let d = new Date(weekDetails.start);
            const dayToNum = {
                tuesday: 1,
                tue: 1,
                wednesday: 2,
                wed: 2,
                thursday: 3,
                thu: 3,
                friday: 4,
                fri: 4,
                saturday: 5,
                sat: 5,
                sunday: 6,
                sun: 6,
            };
            if (dayOfWeek !== "monday") {
                date.day = dayOfWeek.charAt(0).toUpperCase() + dayOfWeek.substring(1, 3);
                if (dayOfWeek in dayToNum) {
                    d.setDate(d.getDate() + dayToNum[dayOfWeek.toLowerCase()]);
                }
            }
            date.month = MONTHS[d.getMonth()];
            date.date = d.getDate().toString();
            date.year = d.getFullYear();
            return date;
        }
        /**
         * @function getFirstDayOfWeek
         * @param {Integer} week - week of university term
         * @param {String} period - study period
         * @returns {String} the first day of the week according to the calendar
         * @description University specific way of identifying the first day of the week
         */
        getFirstDayOfWeek(week = 1, period = this.defaultPeriod) {
            return "Monday";
        }
        /**
         * getCurrentPeriod
         * @descr Examine Canvas course object's course_code attribute in an attempt
         * to extract the STRM and subsequently calculate the year, period and
         * other data -- assumes a Griffith University course code format which is
         * currently
         *
         * Production sites:
         *    Organisational Communication (COM31_2226)
         *    - study period 2226
         *
         * Production sites - joined courses
         *    Introduction to Sculpture (1252QCA_3228/7252QCA_3228)
         *
         * DEV sites:
         *    DEV_2515LHS_3228
         *    - study period 3228
         *
         * ORG sites:
         *     AEL_SHOW1
         *     - no study period
         *
         * TODO rejig based on scapeLib/parseCourseInstanceId (ael-automation)
         * In particular to handle the "YP" course ids
         */
        getCurrentPeriod(courseCode) {
            // Kludge for DEV courses that don't have brackets
            if (courseCode.match(/^DEV_/)) {
                courseCode = `(${courseCode})`;
            }
            // still doesn't start with ( use the default period
            if (!courseCode.startsWith("(")) {
                return this.defaultPeriod;
            }
            // extract out each of the individual courseIds in courseCode
            // e.g. joined courses could have multiple
            const courseIds = courseCode
                .match(/\([^()]+\)(?=[^()]*$)/, "")[0]
                .replace(/[\(\)]/g, "") // Remove parentheses from the remaining string
                .split("/"); // break up the string on delineating /
            // process each courseId separately and try to separate out two components
            // courseCode - e.g. 1252QCA
            // STRM - e.g. 3228
            let courseIdsComponents = [];
            for (let courseId of courseIds) {
                // split up into the components
                let components = courseId.split("_");
                // want to identify the courseCode and the STRM
                let obj = {};
                for (let component of components) {
                    let match = component.match(/^[0-9][0-9][0-9][0-9][A-Z][A-Z][A-Z]$/);
                    if (match) {
                        obj["courseCode"] = match[0];
                        continue;
                    }
                    match = component.match(/^[0-9][0-9][0-9][0-9]$/);
                    if (match) {
                        obj["STRM"] = match[0];
                        continue;
                    }
                }
                courseIdsComponents.push(obj);
            }
            // now get a unique list of the STRMs found in the courseCode
            let STRMs = courseIdsComponents.map((obj) => obj.STRM);
            // get unique list
            STRMs = [...new Set(STRMs)];
            if (STRMs.length === 0) {
                // if there aren't any, use the default
                return this.defaultPeriod;
            }
            else if (STRMs.length > 1) {
                // more than one, report an error and use the first one
                console.error(`Multiple STRMs found in courseCode: ${courseCode}`);
            }
            // return the first STRM because there is at least one STRM
            return STRMs[0];
        }
    }
    // Calendar for Griffith University
    // Period is represented by a four digit number - an STRM
    // XYYP
    // - X is the type of offering
    //   - 2 indicates OUA course
    //   - 3 indicates normal Griffith course
    // - YY is the year (last two digits)
    //   - 19 is 2019
    //   - 21 is 2021
    // - P is the particular period for the offering
    //   - OUA has study periods
    //     - 1 = period 1
    //     - 3 = period 2
    //     - 5 = period 3
    //     - 7 = period 4
    //   - Griffith has 3 trimesters
    //     - 1 = T1
    //     - 5 = T2
    //     - 8 = T3
    // courseCode_STRM_mode
    // default period is the current main trimester
    const DEFAULT_PERIOD = "3231";
    const DAYS_OF_WEEK = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
    ];
    const MONTHS = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
    ];
    /* Griffith Calendar Term dates
     * 2021
     * - OUA Study Periods 1-4
     *   2211, 2213 2215 2217
     * - GU T1, T2, T3
     *   3211 3215 3218
     * - QCM T1 T2
     *   3211QCM 3215QCM
     * 2020
     * - OUA Study Periods 1-4
     *   2201 2203 2205 2207
     * - GU T1, T2, T3
     *   3201 3205 3208
     * 2019
     * - OUA SP 3, 4
     *   2195 2197
     * - GU T1, T2, T3
     *   3191 3195 319
     */
    const CALENDAR = {
        // 2023
        "3231": {
            0: { start: "2023-02-27", stop: "2023-03-03" },
            1: { start: "2023-03-06", stop: "2023-03-12" },
            2: { start: "2023-03-13", stop: "2023-03-19" },
            3: { start: "2023-03-20", stop: "2023-03-26" },
            4: { start: "2023-03-27", stop: "2023-04-09" },
            5: { start: "2023-04-10", stop: "2023-04-16" },
            6: { start: "2023-04-17", stop: "2023-04-23" },
            7: { start: "2023-04-24", stop: "2023-04-30" },
            8: { start: "2023-05-01", stop: "2023-05-07" },
            9: { start: "2023-05-08", stop: "2023-05-14" },
            10: { start: "2023-05-15", stop: "2023-05-21" },
            11: { start: "2023-05-22", stop: "2023-05-28" },
            12: { start: "2023-05-29", stop: "2023-06-04" },
            13: { start: "2023-06-05", stop: "2023-06-11" },
            14: { start: "2023-06-12", stop: "2023-06-18" },
            15: { start: "2023-06-19", stop: "2023-07-25" },
            exam: { start: "2023-06-08", stop: "2023-06-17" },
        },
        // 2022
        "3221": {
            0: { start: "2022-03-07", stop: "2022-03-13" },
            1: { start: "2022-03-14", stop: "2022-03-20" },
            2: { start: "2022-03-21", stop: "2022-03-28" },
            3: { start: "2022-03-28", stop: "2022-04-03" },
            4: { start: "2022-04-04", stop: "2022-04-10" },
            5: { start: "2022-04-18", stop: "2022-04-24" },
            6: { start: "2022-04-25", stop: "2022-05-01" },
            7: { start: "2022-05-02", stop: "2022-05-08" },
            8: { start: "2022-05-09", stop: "2022-05-15" },
            9: { start: "2022-05-16", stop: "2022-05-22" },
            10: { start: "2022-05-23", stop: "2022-05-29" },
            11: { start: "2022-05-30", stop: "2022-06-05" },
            12: { start: "2022-06-06", stop: "2022-06-12" },
            13: { start: "2022-06-13", stop: "2022-06-19" },
            14: { start: "2022-06-20", stop: "2022-06-26" },
            15: { start: "2022-06-27", stop: "2022-07-03" },
            exam: { start: "2022-06-13", stop: "2022-06-25" },
        },
        "2222": {
            0: { start: "2022-03-07", stop: "2022-03-13" },
            1: { start: "2022-03-14", stop: "2022-03-20" },
            2: { start: "2022-03-21", stop: "2022-03-28" },
            3: { start: "2022-03-28", stop: "2022-04-03" },
            4: { start: "2022-04-04", stop: "2022-04-10" },
            5: { start: "2022-04-18", stop: "2022-04-24" },
            6: { start: "2022-04-25", stop: "2022-05-01" },
            7: { start: "2022-05-02", stop: "2022-05-08" },
            8: { start: "2022-05-09", stop: "2022-05-15" },
            9: { start: "2022-05-16", stop: "2022-05-22" },
            10: { start: "2022-05-23", stop: "2022-05-29" },
            11: { start: "2022-05-30", stop: "2022-06-05" },
            12: { start: "2022-06-06", stop: "2022-06-12" },
            13: { start: "2022-06-13", stop: "2022-06-19" },
            14: { start: "2022-06-20", stop: "2022-06-26" },
            15: { start: "2022-06-27", stop: "2022-07-03" },
            exam: { start: "2022-06-13", stop: "2022-06-25" },
        },
        "3221QCM": {
            0: { start: "2022-02-21", stop: "2022-02-27" },
            1: { start: "2022-02-28", stop: "2022-03-06" },
            2: { start: "2022-03-07", stop: "2022-03-13" },
            3: { start: "2022-03-14", stop: "2022-03-20" },
            4: { start: "2022-03-21", stop: "2022-03-27" },
            5: { start: "2022-03-28", stop: "2022-04-03" },
            6: { start: "2022-04-04", stop: "2022-04-10" },
            7: { start: "2022-04-18", stop: "2022-04-24" },
            8: { start: "2022-04-25", stop: "2022-05-01" },
            9: { start: "2022-05-09", stop: "2022-05-15" },
            10: { start: "2022-05-16", stop: "2022-05-22" },
            11: { start: "2022-05-23", stop: "2022-05-29" },
            12: { start: "2022-05-30", stop: "2022-06-05" },
            13: { start: "2022-06-06", stop: "2022-06-12" },
            14: { start: "2022-06-13", stop: "2022-06-19" },
            15: { start: "2022-06-20", stop: "2022-07-26" },
            exam: { start: "2022-06-13", stop: "2022-06-25" },
        },
        "3225": {
            0: { start: "2022-07-11", stop: "2022-07-17" },
            1: { start: "2022-07-18", stop: "2022-07-24" },
            2: { start: "2022-07-25", stop: "2022-07-31" },
            3: { start: "2022-08-01", stop: "2022-08-07" },
            4: { start: "2022-08-08", stop: "2022-08-14" },
            5: { start: "2022-08-22", stop: "2022-08-28" },
            6: { start: "2022-08-29", stop: "2022-09-04" },
            7: { start: "2022-09-05", stop: "2022-09-11" },
            8: { start: "2022-09-12", stop: "2022-09-18" },
            9: { start: "2022-09-19", stop: "2022-09-25" },
            10: { start: "2022-09-26", stop: "2022-10-02" },
            11: { start: "2022-10-03", stop: "2022-10-09" },
            12: { start: "2022-10-10", stop: "2022-10-16" },
            13: { start: "2022-10-17", stop: "2022-10-23" },
            14: { start: "2022-10-24", stop: "2022-10-30" },
            15: { start: "2022-10-31", stop: "2022-11-06" },
            exam: { start: "2022-10-20", stop: "2022-10-29" },
        },
        "2224": {
            0: { start: "2022-07-11", stop: "2022-07-17" },
            1: { start: "2022-07-18", stop: "2022-07-24" },
            2: { start: "2022-07-25", stop: "2022-07-31" },
            3: { start: "2022-08-01", stop: "2022-08-07" },
            4: { start: "2022-08-08", stop: "2022-08-14" },
            5: { start: "2022-08-22", stop: "2022-08-28" },
            6: { start: "2022-08-29", stop: "2022-09-04" },
            7: { start: "2022-09-05", stop: "2022-09-11" },
            8: { start: "2022-09-12", stop: "2022-09-18" },
            9: { start: "2022-09-19", stop: "2022-09-25" },
            10: { start: "2022-09-26", stop: "2022-10-02" },
            11: { start: "2022-10-03", stop: "2022-10-09" },
            12: { start: "2022-10-10", stop: "2022-10-16" },
            13: { start: "2022-10-17", stop: "2022-10-23" },
            14: { start: "2022-10-24", stop: "2022-10-30" },
            15: { start: "2022-10-31", stop: "2022-11-06" },
            exam: { start: "2022-10-20", stop: "2022-10-29" },
        },
        "3225QCM": {
            0: { start: "2022-07-18", stop: "2022-07-24" },
            1: { start: "2022-07-25", stop: "2022-07-31" },
            2: { start: "2022-08-01", stop: "2022-08-07" },
            3: { start: "2022-08-08", stop: "2022-08-14" },
            4: { start: "2022-08-15", stop: "2022-08-21" },
            5: { start: "2022-08-22", stop: "2022-08-28" },
            6: { start: "2022-09-05", stop: "2022-09-11" },
            7: { start: "2022-09-12", stop: "2022-09-18" },
            8: { start: "2022-09-19", stop: "2022-09-25" },
            9: { start: "2022-10-03", stop: "2022-10-09" },
            10: { start: "2022-10-10", stop: "2022-10-16" },
            11: { start: "2022-10-17", stop: "2022-10-23" },
            12: { start: "2022-10-24", stop: "2022-10-30" },
            13: { start: "2022-10-31", stop: "2022-11-06" },
            14: { start: "2022-11-07", stop: "2022-11-13" },
            15: { start: "2022-11-14", stop: "2022-07-20" },
            exam: { start: "2022-11-07", stop: "2022-11-19" },
        },
        3228: {
            0: { start: "2022-10-31", stop: "2022-11-06" },
            1: { start: "2022-11-07", stop: "2022-11-13" },
            2: { start: "2022-11-14", stop: "2022-11-20" },
            3: { start: "2022-11-21", stop: "2022-11-27" },
            4: { start: "2022-11-28", stop: "2022-12-04" },
            5: { start: "2022-12-05", stop: "2022-12-11" },
            6: { start: "2022-12-12", stop: "2022-12-18" },
            7: { start: "2022-12-19", stop: "2022-12-25" },
            8: { start: "2023-01-09", stop: "2023-01-15" },
            9: { start: "2023-01-16", stop: "2023-01-22" },
            10: { start: "2023-01-23", stop: "2023-01-29" },
            11: { start: "2023-01-30", stop: "2023-02-05" },
            12: { start: "2023-02-06", stop: "2023-02-12" },
            13: { start: "2023-02-13", stop: "2023-02-19" },
            14: { start: "2023-02-20", stop: "2023-02-26" },
            15: { start: "2023-02-27", stop: "2023-03-05" },
            //    exam: { start: "2023-02-17", stop: "2023-02-26" },
        },
        2226: {
            0: { start: "2022-10-31", stop: "2022-11-06" },
            1: { start: "2022-11-07", stop: "2022-11-13" },
            2: { start: "2022-11-14", stop: "2022-11-20" },
            3: { start: "2022-11-21", stop: "2022-11-27" },
            4: { start: "2022-11-28", stop: "2022-12-04" },
            5: { start: "2022-12-05", stop: "2022-12-11" },
            6: { start: "2022-12-12", stop: "2022-12-18" },
            7: { start: "2022-12-19", stop: "2022-12-25" },
            8: { start: "2023-01-09", stop: "2023-01-15" },
            9: { start: "2023-01-16", stop: "2023-01-22" },
            10: { start: "2023-01-23", stop: "2023-01-29" },
            11: { start: "2023-01-30", stop: "2023-02-05" },
            12: { start: "2023-02-06", stop: "2023-02-12" },
            13: { start: "2023-02-13", stop: "2023-02-19" },
            14: { start: "2023-02-20", stop: "2023-02-26" },
            15: { start: "2023-02-27", stop: "2023-03-05" },
            //    exam: { start: "2023-02-17", stop: "2023-02-26" },
        },
        2211: {
            0: { start: "2021-02-22", stop: "2021-02-28" },
            1: { start: "2021-03-01", stop: "2021-03-07" },
            2: { start: "2021-03-08", stop: "2021-03-14" },
            3: { start: "2021-03-15", stop: "2021-03-21" },
            4: { start: "2021-03-22", stop: "2021-03-28" },
            5: { start: "2021-03-29", stop: "2021-04-04" },
            6: { start: "2021-04-05", stop: "2021-04-11" },
            7: { start: "2021-04-12", stop: "2021-04-18" },
            8: { start: "2021-04-19", stop: "2021-04-25" },
            9: { start: "2021-04-26", stop: "2021-05-02" },
            10: { start: "2021-05-03", stop: "2021-05-09" },
            11: { start: "2021-05-10", stop: "2021-05-16" },
            12: { start: "2021-05-17", stop: "2021-05-23" },
            13: { start: "2021-05-24", stop: "2021-05-30" },
            14: { start: "2021-05-31", stop: "2021-06-06" },
            exam: { start: "2021-05-31", stop: "2021-06-06" },
        },
        2213: {
            1: { start: "2021-05-31", stop: "2021-06-06" },
            2: { start: "2021-06-07", stop: "2021-06-13" },
            3: { start: "2021-06-14", stop: "2021-06-20" },
            4: { start: "2021-06-21", stop: "2021-06-27" },
            5: { start: "2021-06-28", stop: "2021-07-04" },
            6: { start: "2021-07-05", stop: "2021-07-11" },
            7: { start: "2021-07-12", stop: "2021-07-18" },
            8: { start: "2021-07-19", stop: "2021-07-25" },
            9: { start: "2021-07-26", stop: "2021-08-01" },
            10: { start: "2021-08-02", stop: "2021-08-08" },
            11: { start: "2021-08-09", stop: "2021-08-15" },
            12: { start: "2021-08-16", stop: "2021-08-22" },
            13: { start: "2021-08-23", stop: "2021-08-29" },
            exam: { start: "2021-08-30", stop: "2021-09-05" },
        },
        2215: {
            0: { start: "2021-08-23", stop: "2021-08-29" },
            1: { start: "2021-08-30", stop: "2021-09-05" },
            2: { start: "2021-09-06", stop: "2021-09-12" },
            3: { start: "2021-09-13", stop: "2021-09-19" },
            4: { start: "2021-09-20", stop: "2021-09-26" },
            5: { start: "2021-09-27", stop: "2021-10-03" },
            6: { start: "2021-10-04", stop: "2021-10-10" },
            7: { start: "2021-10-11", stop: "2021-10-17" },
            8: { start: "2021-10-18", stop: "2021-10-24" },
            9: { start: "2021-10-25", stop: "2021-10-31" },
            10: { start: "2021-11-01", stop: "2021-11-07" },
            11: { start: "2021-11-08", stop: "2021-11-14" },
            12: { start: "2021-11-15", stop: "2021-11-21" },
            13: { start: "2021-11-22", stop: "2021-11-28" },
            exam: { start: "2021-11-29", stop: "2021-12-05" },
        },
        2217: {
            0: { start: "2021-11-22", stop: "2021-11-28" },
            1: { start: "2021-11-29", stop: "2021-12-05" },
            2: { start: "2021-12-06", stop: "2021-12-12" },
            3: { start: "2021-12-13", stop: "2021-12-19" },
            4: { start: "2021-12-20", stop: "2021-12-26" },
            5: { start: "2021-12-27", stop: "2022-01-02" },
            6: { start: "2022-01-03", stop: "2022-01-09" },
            7: { start: "2022-01-10", stop: "2022-01-16" },
            8: { start: "2022-01-17", stop: "2022-01-23" },
            9: { start: "2022-01-24", stop: "2022-01-30" },
            10: { start: "2022-01-31", stop: "2022-02-06" },
            11: { start: "2022-02-07", stop: "2022-02-13" },
            12: { start: "2022-02-14", stop: "2022-02-20" },
            13: { start: "2022-02-21", stop: "2022-02-27" },
            exam: { start: "2022-02-28", stop: "2022-03-04" },
        },
        3218: {
            0: { start: "2021-11-01", stop: "2021-11-07" },
            1: { start: "2021-11-08", stop: "2021-11-14" },
            2: { start: "2021-11-15", stop: "2021-11-21" },
            3: { start: "2021-11-22", stop: "2021-11-28" },
            4: { start: "2021-11-29", stop: "2021-12-05" },
            5: { start: "2021-12-06", stop: "2021-12-12" },
            6: { start: "2021-12-13", stop: "2021-12-19" },
            7: { start: "2021-12-20", stop: "2021-12-26" },
            8: { start: "2022-01-10", stop: "2022-01-16" },
            9: { start: "2022-01-17", stop: "2022-01-23" },
            10: { start: "2022-01-24", stop: "2022-01-30" },
            11: { start: "2022-01-31", stop: "2022-02-06" },
            12: { start: "2022-02-07", stop: "2022-02-13" },
            13: { start: "2022-02-14", stop: "2022-02-20" },
            14: { start: "2022-02-21", stop: "2022-02-27" },
            15: { start: "2022-02-28", stop: "2022-03-06" },
            exam: { start: "2022-02-17", stop: "2022-02-26" },
        },
        3215: {
            0: { start: "2021-07-12", stop: "2021-07-18" },
            1: { start: "2021-07-19", stop: "2021-07-25" },
            2: { start: "2021-07-26", stop: "2021-08-01" },
            3: { start: "2021-08-02", stop: "2021-08-08" },
            4: { start: "2021-08-16", stop: "2021-08-22" },
            5: { start: "2021-08-23", stop: "2021-08-29" },
            6: { start: "2021-08-30", stop: "2021-09-05" },
            7: { start: "2021-09-06", stop: "2021-09-12" },
            8: { start: "2021-09-13", stop: "2021-09-19" },
            9: { start: "2021-09-20", stop: "2021-09-26" },
            10: { start: "2021-09-27", stop: "2021-10-03" },
            11: { start: "2021-10-04", stop: "2021-10-10" },
            12: { start: "2021-10-11", stop: "2021-10-17" },
            13: { start: "2021-10-18", stop: "2021-10-24" },
            14: { start: "2021-10-25", stop: "2021-10-31" },
            15: { start: "2021-11-01", stop: "2021-11-07" },
            exam: { start: "2021-10-21", stop: "2021-10-31" },
        },
        3211: {
            0: { start: "2021-03-01", stop: "2021-03-07" },
            1: { start: "2021-03-08", stop: "2021-03-14" },
            2: { start: "2021-03-15", stop: "2021-03-21" },
            3: { start: "2021-03-22", stop: "2021-03-28" },
            4: { start: "2021-03-29", stop: "2021-04-04" },
            5: { start: "2021-04-12", stop: "2021-04-18" },
            6: { start: "2021-04-19", stop: "2021-04-25" },
            7: { start: "2021-04-26", stop: "2021-05-02" },
            8: { start: "2021-05-03", stop: "2021-05-09" },
            9: { start: "2021-05-10", stop: "2021-05-16" },
            10: { start: "2021-05-17", stop: "2021-05-23" },
            11: { start: "2021-05-24", stop: "2021-05-30" },
            12: { start: "2021-05-31", stop: "2021-06-06" },
            13: { start: "2021-06-07", stop: "2021-06-13" },
            14: { start: "2021-06-14", stop: "2021-06-20" },
            15: { start: "2021-06-21", stop: "2021-06-27" },
            exam: { start: "2021-06-10", stop: "2021-06-19" },
        },
        "3215QCM": {
            0: { start: "2021-07-12", stop: "2021-07-18" },
            1: { start: "2021-07-19", stop: "2021-07-25" },
            2: { start: "2021-07-26", stop: "2021-08-01" },
            3: { start: "2021-08-02", stop: "2021-08-08" },
            4: { start: "2021-08-09", stop: "2021-08-15" },
            5: { start: "2021-08-16", stop: "2021-08-22" },
            6: { start: "2021-08-30", stop: "2021-09-05" },
            7: { start: "2021-09-06", stop: "2021-09-12" },
            8: { start: "2021-09-13", stop: "2021-09-19" },
            9: { start: "2021-09-20", stop: "2021-09-26" },
            10: { start: "2021-10-04", stop: "2021-10-10" },
            11: { start: "2021-10-11", stop: "2021-10-17" },
            12: { start: "2021-10-18", stop: "2021-10-24" },
            13: { start: "2021-10-25", stop: "2021-10-31" },
            14: { start: "2021-11-01", stop: "2021-11-07" },
            15: { start: "2021-11-08", stop: "2021-11-14" },
            exam: { start: "2021-10-30", stop: "2021-11-13" },
        },
        "3211QCM": {
            0: { start: "2021-02-22", stop: "2021-02-28" },
            1: { start: "2021-03-01", stop: "2021-03-07" },
            2: { start: "2021-03-08", stop: "2021-03-14" },
            3: { start: "2021-03-15", stop: "2021-03-21" },
            4: { start: "2021-03-22", stop: "2021-03-29" },
            5: { start: "2021-03-29", stop: "2021-04-04" },
            6: { start: "2021-04-12", stop: "2021-04-18" },
            7: { start: "2021-04-19", stop: "2021-04-25" },
            8: { start: "2021-04-26", stop: "2021-05-02" },
            9: { start: "2021-05-10", stop: "2021-05-16" },
            10: { start: "2021-05-17", stop: "2021-05-23" },
            11: { start: "2021-05-24", stop: "2021-05-30" },
            12: { start: "2021-05-31", stop: "2021-06-06" },
            13: { start: "2021-06-07", stop: "2021-03-13" },
            14: { start: "2021-06-14", stop: "2021-03-20" },
            15: { start: "2021-06-21", stop: "2021-03-26" },
            exam: { start: "2021-06-12", stop: "2021-06-26" },
        },
        2201: {
            0: { start: "2020-02-24", stop: "2020-03-01" },
            1: { start: "2020-03-02", stop: "2020-03-08" },
            2: { start: "2020-03-09", stop: "2020-03-15" },
            3: { start: "2020-03-16", stCop: "2020-03-22" },
            4: { start: "2020-03-23", stop: "2020-03-29" },
            5: { start: "2020-03-30", stop: "2020-04-05" },
            6: { start: "2020-04-06", stop: "2020-04-12" },
            7: { start: "2020-04-13", stop: "2020-04-19" },
            8: { start: "2020-04-20", stop: "2020-04-26" },
            9: { start: "2020-04-27", stop: "2020-05-03" },
            10: { start: "2020-05-04", stop: "2020-05-10" },
            11: { start: "2020-05-11", stop: "2020-05-17" },
            12: { start: "2020-05-18", stop: "2020-05-24" },
            13: { start: "2020-05-25", stop: "2020-05-31" },
            14: { start: "2020-06-01", stop: "2020-06-05" },
            exam: { start: "2020-06-01", stop: "2020-06-05" },
        },
        2203: {
            0: { start: "2020-05-25", stop: "2020-05-31" },
            1: { start: "2020-06-01", stop: "2020-06-07" },
            2: { start: "2020-06-08", stop: "2020-06-14" },
            3: { start: "2020-06-15", stop: "2020-06-21" },
            4: { start: "2020-06-22", stop: "2020-06-28" },
            5: { start: "2020-06-29", stop: "2020-07-05" },
            6: { start: "2020-07-06", stop: "2020-07-12" },
            7: { start: "2020-07-13", stop: "2020-07-19" },
            8: { start: "2020-07-20", stop: "2020-07-26" },
            9: { start: "2020-07-27", stop: "2020-08-02" },
            10: { start: "2020-08-03", stop: "2020-08-09" },
            11: { start: "2020-08-10", stop: "2020-05-17" },
            12: { start: "2020-08-17", stop: "2020-05-24" },
            13: { start: "2020-08-24", stop: "2020-05-31" },
            14: { start: "2020-08-31", stop: "2020-09-06" },
            exam: { start: "2020-08-31", stop: "2020-09-04" },
        },
        2205: {
            0: { start: "2020-08-24", stop: "2020-09-30" },
            1: { start: "2020-08-31", stop: "2020-09-06" },
            2: { start: "2020-09-07", stop: "2020-09-13" },
            3: { start: "2020-09-14", stop: "2020-09-20" },
            4: { start: "2020-09-21", stop: "2020-09-27" },
            5: { start: "2020-09-28", stop: "2020-10-04" },
            6: { start: "2020-10-05", stop: "2020-10-11" },
            7: { start: "2020-10-12", stop: "2020-10-19" },
            8: { start: "2020-10-19", stop: "2020-10-25" },
            9: { start: "2020-10-26", stop: "2020-11-01" },
            10: { start: "2020-11-02", stop: "2020-11-08" },
            11: { start: "2020-11-09", stop: "2020-11-15" },
            12: { start: "2020-11-16", stop: "2020-11-22" },
            13: { start: "2020-11-23", stop: "2020-11-29" },
            14: { start: "2020-11-30", stop: "2020-12-06" },
            15: { start: "2020-12-07", stop: "2020-12-13" },
            exam: { start: "2020-12-07", stop: "2020-12-13" },
        },
        2207: {
            0: { start: "2020-11-23", stop: "2020-11-29" },
            1: { start: "2020-11-30", stop: "2020-12-06" },
            2: { start: "2020-12-07", stop: "2020-12-13" },
            3: { start: "2020-12-14", stop: "2020-12-20" },
            4: { start: "2020-12-21", stop: "2020-12-27" },
            5: { start: "2020-12-28", stop: "2021-01-03" },
            6: { start: "2021-01-04", stop: "2021-01-10" },
            7: { start: "2021-01-11", stop: "2021-01-17" },
            8: { start: "2021-01-18", stop: "2021-01-24" },
            9: { start: "2021-01-25", stop: "2021-01-31" },
            10: { start: "2021-02-01", stop: "2021-02-07" },
            11: { start: "2021-02-08", stop: "2021-02-14" },
            12: { start: "2021-02-15", stop: "2021-02-21" },
            13: { start: "2021-02-22", stop: "2021-02-28" },
            14: { start: "2021-03-01", stop: "2021-03-07" },
            15: { start: "2021-03-08", stop: "2021-03-14" },
            exam: { start: "2021-03-01", stop: "2021-03-07" },
        },
        3208: {
            0: { start: "2020-10-26", stop: "2020-11-01" },
            1: { start: "2020-11-02", stop: "2020-11-08" },
            2: { start: "2020-11-09", stop: "2020-11-15" },
            3: { start: "2020-11-16", stop: "2020-11-22" },
            4: { start: "2020-11-23", stop: "2020-11-29" },
            5: { start: "2020-11-30", stop: "2020-12-06" },
            6: { start: "2020-12-07", stop: "2020-12-13" },
            7: { start: "2020-12-14", stop: "2020-12-20" },
            8: { start: "2021-01-04", stop: "2021-01-10" },
            9: { start: "2021-01-11", stop: "2021-01-17" },
            10: { start: "2021-01-18", stop: "2021-01-24" },
            11: { start: "2021-01-25", stop: "2021-01-31" },
            12: { start: "2021-02-01", stop: "2021-02-07" },
            13: { start: "2021-02-08", stop: "2021-02-14" },
            exam: { start: "2021-02-08", stop: "2021-02-20" },
        },
        3205: {
            0: { start: "2020-07-06", stop: "2020-07-12" },
            1: { start: "2020-07-13", stop: "2020-07-19" },
            2: { start: "2020-07-20", stop: "2020-08-26" },
            3: { start: "2020-07-27", stop: "2020-08-02" },
            4: { start: "2020-08-03", stop: "2020-08-16" },
            5: { start: "2020-08-17", stop: "2020-08-23" },
            6: { start: "2020-08-24", stop: "2020-08-30" },
            7: { start: "2020-08-31", stop: "2020-09-06" },
            8: { start: "2020-09-07", stop: "2020-09-13" },
            9: { start: "2020-09-14", stop: "2020-09-20" },
            10: { start: "2020-09-21", stop: "2020-09-27" },
            11: { start: "2020-09-28", stop: "2020-10-04" },
            12: { start: "2020-10-05", stop: "2020-10-11" },
            13: { start: "2020-10-12", stop: "2020-10-18" },
            14: { start: "2020-10-19", stop: "2020-10-25" },
            15: { start: "2020-10-27", stop: "2020-11-01" },
            exam: { start: "2020-10-12", stop: "2020-10-18" },
        },
        3201: {
            0: { start: "2020-02-17", stop: "2020-02-23" },
            1: { start: "2020-02-24", stop: "2020-03-01" },
            2: { start: "2020-03-02", stop: "2020-03-08" },
            3: { start: "2020-03-09", stop: "2020-03-15" },
            4: { start: "2020-03-16", stop: "2020-03-22" },
            5: { start: "2020-03-23", stop: "2020-03-29" },
            6: { start: "2020-03-30", stop: "2020-04-05" },
            7: { start: "2020-04-13", stop: "2020-04-19" },
            8: { start: "2020-04-20", stop: "2020-04-26" },
            9: { start: "2020-04-27", stop: "2020-05-03" },
            10: { start: "2020-05-04", stop: "2020-05-10" },
            11: { start: "2020-05-11", stop: "2020-05-17" },
            12: { start: "2020-05-18", stop: "2020-05-24" },
            13: { start: "2020-05-25", stop: "2020-05-31" },
            exam: { start: "2020-06-01", stop: "2020-06-07" },
        },
        3198: {
            0: { start: "2019-10-21", stop: "2019-10-27" },
            1: { start: "2019-10-28", stop: "2019-11-03" },
            2: { start: "2019-11-04", stop: "2019-11-10" },
            3: { start: "2019-11-11", stop: "2019-11-17" },
            4: { start: "2019-11-18", stop: "2019-11-24" },
            5: { start: "2019-11-25", stop: "2019-12-1" },
            6: { start: "2019-12-02", stop: "2019-12-08" },
            7: { start: "2019-12-09", stop: "2019-12-15" },
            8: { start: "2019-12-16", stop: "2019-12-22" },
            9: { start: "2020-01-06", stop: "2020-01-12" },
            10: { start: "2020-01-13", stop: "2020-01-19" },
            11: { start: "2020-01-20", stop: "2020-01-26" },
            12: { start: "2020-01-27", stop: "2020-02-02" },
            13: { start: "2020-02-03", stop: "2020-02-09" },
            exam: { start: "2020-02-06", stop: "2020-02-15" },
        },
        2197: {
            0: { start: "2019-11-18", stop: "2019-11-24" },
            1: { start: "2019-11-25", stop: "2019-12-01" },
            2: { start: "2019-12-02", stop: "2019-12-08" },
            3: { start: "2019-12-09", stop: "2019-12-15" },
            4: { start: "2019-12-16", stop: "2019-12-22" },
            5: { start: "2019-12-23", stop: "2019-09-29" },
            6: { start: "2019-12-30", stop: "2020-01-05" },
            7: { start: "2020-01-06", stop: "2020-01-12" },
            8: { start: "2020-01-13", stop: "2020-01-19" },
            9: { start: "2020-01-20", stop: "2020-01-26" },
            10: { start: "2020-01-27", stop: "2020-02-02" },
            11: { start: "2020-02-03", stop: "2020-02-09" },
            12: { start: "2020-02-10", stop: "2020-02-16" },
            13: { start: "2019-02-17", stop: "2020-02-23" },
            14: { start: "2020-02-24", stop: "2020-03-01" },
            15: { start: "2020-03-02", stop: "2020-03-08" },
        },
        2195: {
            0: { start: "2019-08-19", stop: "2019-09-25" },
            1: { start: "2019-08-26", stop: "2019-09-01" },
            2: { start: "2019-09-02", stop: "2019-09-18" },
            3: { start: "2019-09-09", stop: "2019-09-15" },
            4: { start: "2019-09-16", stop: "2019-09-22" },
            5: { start: "2019-09-23", stop: "2019-09-29" },
            6: { start: "2019-09-30", stop: "2019-10-06" },
            7: { start: "2019-10-07", stop: "2019-10-13" },
            8: { start: "2019-10-14", stop: "2019-08-20" },
            9: { start: "2019-10-21", stop: "2019-10-27" },
            10: { start: "2019-10-28", stop: "2019-11-03" },
            11: { start: "2019-11-04", stop: "2019-11-10" },
            12: { start: "2019-11-11", stop: "2019-11-17" },
            13: { start: "2019-11-18", stop: "2019-11-24" },
            14: { start: "2019-11-25", stop: "2019-12-01" },
            15: { start: "2019-10-07", stop: "2019-10-13" },
        },
        3195: {
            0: { start: "2019-07-01", stop: "2019-07-07" },
            1: { start: "2019-07-08", stop: "2019-07-14" },
            2: { start: "2019-07-15", stop: "2019-07-21" },
            3: { start: "2019-07-22", stop: "2019-07-28" },
            4: { start: "2019-07-29", stop: "2019-08-04" },
            5: { start: "2019-08-05", stop: "2019-08-11" },
            6: { start: "2019-08-19", stop: "2019-08-25" },
            7: { start: "2019-08-26", stop: "2019-09-01" },
            8: { start: "2019-09-02", stop: "2019-09-08" },
            9: { start: "2019-09-09", stop: "2019-09-15" },
            10: { start: "2019-09-16", stop: "2019-09-22" },
            11: { start: "2019-09-23", stop: "2019-09-29" },
            12: { start: "2019-09-30", stop: "2019-10-06" },
            13: { start: "2019-10-07", stop: "2019-10-13" },
            14: { start: "2019-10-14", stop: "2019-10-20" },
            15: { start: "2019-10-21", stop: "2019-10-27" },
            exam: { start: "2019-10-10", stop: "2019-10-19" },
        },
        3191: {
            0: { start: "2019-02-18", stop: "2019-02-24" },
            1: { start: "2019-02-25", stop: "2019-03-03" },
            2: { start: "2019-03-04", stop: "2019-03-10" },
            3: { start: "2019-03-11", stop: "2019-03-17" },
            4: { start: "2019-03-18", stop: "2019-03-24" },
            5: { start: "2019-03-25", stop: "2019-03-31" },
            6: { start: "2019-04-01", stop: "2019-04-07" },
            7: { start: "2019-04-08", stop: "2019-04-14" },
            8: { start: "2019-04-22", stop: "2019-04-28" },
            9: { start: "2019-04-29", stop: "2019-05-05" },
            10: { start: "2019-05-06", stop: "2019-05-12" },
            11: { start: "2019-05-13", stop: "2019-05-19" },
            12: { start: "2019-05-20", stop: "2019-05-26" },
            13: { start: "2019-05-27", stop: "2019-06-02" },
            14: { start: "2019-06-03", stop: "2019-06-09" },
            15: { start: "2019-06-10", stop: "2019-06-17" },
            exam: { start: "2019-05-30", stop: "2019-06-08" },
        },
    };

    /* src\components\Configuration\ModuleDateConfiguration.svelte generated by Svelte v3.55.0 */
    const file$p = "src\\components\\Configuration\\ModuleDateConfiguration.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	return child_ctx;
    }

    // (219:8) {:else}
    function create_else_block$b(ctx) {
    	let input;
    	let input_id_value;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-label");
    			set_style(input, "width", "10rem");
    			input.value = "";
    			attr_dev(input, "class", "svelte-le37x9");
    			add_location(input, file$p, 219, 10, 8139);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-label")) {
    				attr_dev(input, "id", input_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(219:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (211:8) {#if $collectionsStore["MODULES"][moduleId].hasOwnProperty("date") && $collectionsStore["MODULES"][moduleId].date.hasOwnProperty("label")}
    function create_if_block$i(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-label");
    			set_style(input, "width", "10rem");
    			attr_dev(input, "class", "svelte-le37x9");
    			add_location(input, file$p, 211, 10, 7853);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["label"]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keydown", stop_propagation(/*keydown_handler*/ ctx[13]), false, false, true),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[14])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-label")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19 && input.value !== /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["label"]) {
    				set_input_value(input, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["label"]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(211:8) {#if $collectionsStore[\\\"MODULES\\\"][moduleId].hasOwnProperty(\\\"date\\\") && $collectionsStore[\\\"MODULES\\\"][moduleId].date.hasOwnProperty(\\\"label\\\")}",
    		ctx
    	});

    	return block;
    }

    // (254:10) {#each daysOfWeek as day}
    function create_each_block_3(ctx) {
    	let option;
    	let t_value = /*day*/ ctx[37] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*day*/ ctx[37];
    			option.value = option.__value;
    			add_location(option, file$p, 254, 12, 9294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(254:10) {#each daysOfWeek as day}",
    		ctx
    	});

    	return block;
    }

    // (284:10) {#each weeksOfTerm as week}
    function create_each_block_2$2(ctx) {
    	let option;
    	let t_value = /*week*/ ctx[34] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*week*/ ctx[34].toString();
    			option.value = option.__value;
    			add_location(option, file$p, 284, 12, 10346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(284:10) {#each weeksOfTerm as week}",
    		ctx
    	});

    	return block;
    }

    // (382:10) {#each daysOfWeek as day}
    function create_each_block_1$4(ctx) {
    	let option;
    	let t_value = /*day*/ ctx[37] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*day*/ ctx[37];
    			option.value = option.__value;
    			add_location(option, file$p, 382, 12, 13746);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(382:10) {#each daysOfWeek as day}",
    		ctx
    	});

    	return block;
    }

    // (401:10) {#each weeksOfTerm as week}
    function create_each_block$f(ctx) {
    	let option;
    	let t_value = /*week*/ ctx[34] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*week*/ ctx[34].toString();
    			option.value = option.__value;
    			add_location(option, file$p, 401, 12, 14367);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(401:10) {#each weeksOfTerm as week}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div1;
    	let p0;
    	let strong0;
    	let t1;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[8].studyPeriod.tooltip + "";
    	let t2;
    	let a0;
    	let i0;
    	let t3;
    	let t4;
    	let t5;
    	let div3;
    	let p1;
    	let strong1;
    	let t7;
    	let sl_tooltip1;
    	let div2;
    	let raw1_value = /*HELP*/ ctx[8].calculatedDate.tooltip + "";
    	let t8;
    	let a1;
    	let i1;
    	let t9;
    	let t10_value = /*calculateDate*/ ctx[6](/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]].date) + "";
    	let t10;
    	let t11;
    	let div26;
    	let div16;
    	let div5;
    	let t12;
    	let sl_tooltip2;
    	let div4;
    	let raw2_value = /*HELP*/ ctx[8].dateStart.tooltip + "";
    	let t13;
    	let a2;
    	let i2;
    	let t14;
    	let div6;
    	let span0;
    	let label0;
    	let t15;
    	let label0_for_value;
    	let t16;
    	let span1;
    	let show_if;
    	let t17;
    	let div8;
    	let span2;
    	let label1;
    	let t18;
    	let label1_for_value;
    	let t19;
    	let sl_tooltip3;
    	let div7;
    	let raw3_value = /*HELP*/ ctx[8].hideDate.tooltip + "";
    	let t20;
    	let input0;
    	let t21;
    	let span3;
    	let select0;
    	let option0;
    	let select0_id_value;
    	let t23;
    	let div10;
    	let span4;
    	let label2;
    	let t24;
    	let label2_for_value;
    	let t25;
    	let sl_tooltip4;
    	let div9;
    	let raw4_value = /*HELP*/ ctx[8].hideDate.tooltip + "";
    	let t26;
    	let input1;
    	let t27;
    	let span5;
    	let select1;
    	let option1;
    	let select1_id_value;
    	let t29;
    	let div12;
    	let span6;
    	let label3;
    	let t30;
    	let label3_for_value;
    	let t31;
    	let sl_tooltip5;
    	let div11;
    	let raw5_value = /*HELP*/ ctx[8].hideDate.tooltip + "";
    	let t32;
    	let input2;
    	let t33;
    	let span7;
    	let style0;
    	let t35;
    	let aeon_datepicker0;
    	let input3;
    	let input3_id_value;
    	let t36;
    	let div15;
    	let span8;
    	let label4;
    	let t37;
    	let label4_for_value;
    	let t38;
    	let sl_tooltip6;
    	let div13;
    	let raw6_value = /*HELP*/ ctx[8].hideDate.tooltip + "";
    	let t39;
    	let input4;
    	let t40;
    	let span9;
    	let sl_tooltip7;
    	let div14;
    	let raw7_value = /*HELP*/ ctx[8].calendarDate.tooltip + "";
    	let t41;
    	let input5;
    	let input5_id_value;
    	let input5_value_value;
    	let div16_id_value;
    	let t42;
    	let div25;
    	let div18;
    	let t43;
    	let sl_tooltip8;
    	let div17;
    	let raw8_value = /*HELP*/ ctx[8].stopDate.tooltip + "";
    	let t44;
    	let a3;
    	let i3;
    	let t45;
    	let div19;
    	let t46;
    	let div20;
    	let span10;
    	let label5;
    	let t47;
    	let label5_for_value;
    	let t48;
    	let span11;
    	let select2;
    	let option2;
    	let select2_id_value;
    	let t50;
    	let div21;
    	let span12;
    	let label6;
    	let t51;
    	let label6_for_value;
    	let t52;
    	let span13;
    	let select3;
    	let option3;
    	let select3_id_value;
    	let t54;
    	let div22;
    	let span14;
    	let label7;
    	let t55;
    	let label7_for_value;
    	let t56;
    	let span15;
    	let style1;
    	let t58;
    	let aeon_datepicker1;
    	let input6;
    	let input6_id_value;
    	let t59;
    	let div24;
    	let span16;
    	let label8;
    	let t60;
    	let label8_for_value;
    	let t61;
    	let span17;
    	let sl_tooltip9;
    	let div23;
    	let raw9_value = /*HELP*/ ctx[8].calendarDate.tooltip + "";
    	let t62;
    	let input7;
    	let input7_id_value;
    	let input7_value_value;
    	let div25_id_value;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*$collectionsStore, moduleId*/ 3) show_if = null;
    		if (show_if == null) show_if = !!(/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]].hasOwnProperty("date") && /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]].date.hasOwnProperty("label"));
    		if (show_if) return create_if_block$i;
    		return create_else_block$b;
    	}

    	let current_block_type = select_block_type(ctx, [-1, -1]);
    	let if_block = current_block_type(ctx);
    	let each_value_3 = /*daysOfWeek*/ ctx[4];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*weeksOfTerm*/ ctx[5];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*daysOfWeek*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	let each_value = /*weeksOfTerm*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			p0 = element("p");
    			strong0 = element("strong");
    			strong0.textContent = "Current Term:";
    			t1 = space();
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t2 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t3 = space();
    			t4 = text(/*currentStudyPeriod*/ ctx[3]);
    			t5 = space();
    			div3 = element("div");
    			p1 = element("p");
    			strong1 = element("strong");
    			strong1.textContent = "Current Date:";
    			t7 = space();
    			sl_tooltip1 = element("sl-tooltip");
    			div2 = element("div");
    			t8 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t9 = space();
    			t10 = text(t10_value);
    			t11 = space();
    			div26 = element("div");
    			div16 = element("div");
    			div5 = element("div");
    			t12 = text("Start date\r\n      ");
    			sl_tooltip2 = element("sl-tooltip");
    			div4 = element("div");
    			t13 = space();
    			a2 = element("a");
    			i2 = element("i");
    			t14 = space();
    			div6 = element("div");
    			span0 = element("span");
    			label0 = element("label");
    			t15 = text("Date label");
    			t16 = space();
    			span1 = element("span");
    			if_block.c();
    			t17 = space();
    			div8 = element("div");
    			span2 = element("span");
    			label1 = element("label");
    			t18 = text("Day of week");
    			t19 = space();
    			sl_tooltip3 = element("sl-tooltip");
    			div7 = element("div");
    			t20 = space();
    			input0 = element("input");
    			t21 = space();
    			span3 = element("span");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Not chosen";

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t23 = space();
    			div10 = element("div");
    			span4 = element("span");
    			label2 = element("label");
    			t24 = text("Week");
    			t25 = space();
    			sl_tooltip4 = element("sl-tooltip");
    			div9 = element("div");
    			t26 = space();
    			input1 = element("input");
    			t27 = space();
    			span5 = element("span");
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "Not chosen";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t29 = space();
    			div12 = element("div");
    			span6 = element("span");
    			label3 = element("label");
    			t30 = text("Time");
    			t31 = space();
    			sl_tooltip5 = element("sl-tooltip");
    			div11 = element("div");
    			t32 = space();
    			input2 = element("input");
    			t33 = space();
    			span7 = element("span");
    			style0 = element("style");
    			style0.textContent = "input[readonly] {\r\n            display: none;\r\n          }";
    			t35 = space();
    			aeon_datepicker0 = element("aeon-datepicker");
    			input3 = element("input");
    			t36 = space();
    			div15 = element("div");
    			span8 = element("span");
    			label4 = element("label");
    			t37 = text("Date");
    			t38 = space();
    			sl_tooltip6 = element("sl-tooltip");
    			div13 = element("div");
    			t39 = space();
    			input4 = element("input");
    			t40 = space();
    			span9 = element("span");
    			sl_tooltip7 = element("sl-tooltip");
    			div14 = element("div");
    			t41 = space();
    			input5 = element("input");
    			t42 = space();
    			div25 = element("div");
    			div18 = element("div");
    			t43 = text("Stop date\r\n      ");
    			sl_tooltip8 = element("sl-tooltip");
    			div17 = element("div");
    			t44 = space();
    			a3 = element("a");
    			i3 = element("i");
    			t45 = space();
    			div19 = element("div");
    			t46 = space();
    			div20 = element("div");
    			span10 = element("span");
    			label5 = element("label");
    			t47 = text("Day of week");
    			t48 = space();
    			span11 = element("span");
    			select2 = element("select");
    			option2 = element("option");
    			option2.textContent = "Not chosen";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t50 = space();
    			div21 = element("div");
    			span12 = element("span");
    			label6 = element("label");
    			t51 = text("Week");
    			t52 = space();
    			span13 = element("span");
    			select3 = element("select");
    			option3 = element("option");
    			option3.textContent = "Not chosen";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t54 = space();
    			div22 = element("div");
    			span14 = element("span");
    			label7 = element("label");
    			t55 = text("Time");
    			t56 = space();
    			span15 = element("span");
    			style1 = element("style");
    			style1.textContent = "input[readonly] {\r\n            display: none;\r\n          }";
    			t58 = space();
    			aeon_datepicker1 = element("aeon-datepicker");
    			input6 = element("input");
    			t59 = space();
    			div24 = element("div");
    			span16 = element("span");
    			label8 = element("label");
    			t60 = text("Date");
    			t61 = space();
    			span17 = element("span");
    			sl_tooltip9 = element("sl-tooltip");
    			div23 = element("div");
    			t62 = space();
    			input7 = element("input");
    			add_location(strong0, file$p, 170, 4, 6286);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$p, 172, 6, 6378);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$p, 174, 9, 6519);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "href", /*HELP*/ ctx[8].studyPeriod.href);
    			add_location(a0, file$p, 173, 6, 6444);
    			set_custom_element_data(sl_tooltip0, "class", "cc-about-module-studyPeriod svelte-le37x9");
    			add_location(sl_tooltip0, file$p, 171, 4, 6322);
    			add_location(p0, file$p, 169, 2, 6277);
    			attr_dev(div1, "class", "cc-current-studyPeriod svelte-le37x9");
    			add_location(div1, file$p, 168, 0, 6237);
    			add_location(strong1, file$p, 183, 4, 6683);
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$p, 185, 6, 6739);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$p, 187, 8, 6886);
    			attr_dev(a1, "href", /*HELP*/ ctx[8].calculatedDate.href);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			add_location(a1, file$p, 186, 6, 6808);
    			set_custom_element_data(sl_tooltip1, "class", "svelte-le37x9");
    			add_location(sl_tooltip1, file$p, 184, 4, 6719);
    			add_location(p1, file$p, 182, 2, 6674);
    			attr_dev(div3, "class", "cc-calculated-date svelte-le37x9");
    			add_location(div3, file$p, 181, 0, 6638);
    			attr_dev(div4, "slot", "content");
    			add_location(div4, file$p, 199, 8, 7258);
    			attr_dev(i2, "class", "icon-question cc-module-icon");
    			add_location(i2, file$p, 201, 11, 7399);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noreferrer");
    			attr_dev(a2, "href", /*HELP*/ ctx[8].dateStart.href);
    			add_location(a2, file$p, 200, 8, 7324);
    			set_custom_element_data(sl_tooltip2, "id", "cc-about-module-date-start");
    			set_custom_element_data(sl_tooltip2, "class", "svelte-le37x9");
    			add_location(sl_tooltip2, file$p, 198, 6, 7204);
    			attr_dev(div5, "class", "cc-date-heading svelte-le37x9");
    			add_location(div5, file$p, 196, 4, 7149);
    			attr_dev(label0, "for", label0_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-label");
    			add_location(label0, file$p, 207, 8, 7570);
    			attr_dev(span0, "class", "cc-module-label svelte-le37x9");
    			add_location(span0, file$p, 206, 6, 7530);
    			attr_dev(span1, "class", "cc-module-input svelte-le37x9");
    			add_location(span1, file$p, 209, 6, 7663);
    			attr_dev(div6, "class", "cc-module-form svelte-le37x9");
    			add_location(div6, file$p, 205, 4, 7494);
    			attr_dev(label1, "for", label1_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day");
    			add_location(label1, file$p, 230, 8, 8420);
    			attr_dev(div7, "slot", "content");
    			add_location(div7, file$p, 233, 10, 8551);
    			attr_dev(input0, "type", "checkbox");
    			add_location(input0, file$p, 234, 10, 8618);
    			set_custom_element_data(sl_tooltip3, "id", "cc-about-module-date-stop");
    			set_custom_element_data(sl_tooltip3, "class", "svelte-le37x9");
    			add_location(sl_tooltip3, file$p, 232, 8, 8496);
    			attr_dev(span2, "class", "cc-module-label svelte-le37x9");
    			add_location(span2, file$p, 229, 6, 8380);
    			option0.__value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$p, 252, 10, 9207);
    			attr_dev(select0, "id", select0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day");
    			attr_dev(select0, "class", "svelte-le37x9");
    			if (/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["day"] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[17].call(select0));
    			add_location(select0, file$p, 247, 8, 9017);
    			attr_dev(span3, "class", "cc-module-input svelte-le37x9");
    			add_location(span3, file$p, 246, 6, 8977);
    			attr_dev(div8, "class", "cc-module-form svelte-le37x9");
    			add_location(div8, file$p, 228, 4, 8344);
    			attr_dev(label2, "for", label2_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week");
    			add_location(label2, file$p, 261, 8, 9475);
    			attr_dev(div9, "slot", "content");
    			add_location(div9, file$p, 263, 10, 9598);
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$p, 264, 10, 9665);
    			set_custom_element_data(sl_tooltip4, "id", "cc-about-module-date-stop");
    			set_custom_element_data(sl_tooltip4, "class", "svelte-le37x9");
    			add_location(sl_tooltip4, file$p, 262, 8, 9543);
    			attr_dev(span4, "class", "cc-module-label svelte-le37x9");
    			add_location(span4, file$p, 260, 6, 9435);
    			option1.__value = "";
    			option1.value = option1.__value;
    			add_location(option1, file$p, 282, 10, 10257);
    			attr_dev(select1, "id", select1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week");
    			attr_dev(select1, "class", "svelte-le37x9");
    			if (/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["week"] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[20].call(select1));
    			add_location(select1, file$p, 277, 8, 10065);
    			attr_dev(span5, "class", "cc-module-input svelte-le37x9");
    			add_location(span5, file$p, 276, 6, 10025);
    			attr_dev(div10, "class", "cc-module-form svelte-le37x9");
    			add_location(div10, file$p, 259, 4, 9399);
    			attr_dev(label3, "for", label3_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time");
    			add_location(label3, file$p, 291, 8, 10540);
    			attr_dev(div11, "slot", "content");
    			add_location(div11, file$p, 293, 10, 10663);
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$p, 294, 10, 10730);
    			set_custom_element_data(sl_tooltip5, "id", "cc-about-module-date-stop");
    			set_custom_element_data(sl_tooltip5, "class", "svelte-le37x9");
    			add_location(sl_tooltip5, file$p, 292, 8, 10608);
    			attr_dev(span6, "class", "cc-module-label svelte-le37x9");
    			add_location(span6, file$p, 290, 6, 10500);
    			add_location(style0, file$p, 307, 8, 11130);
    			attr_dev(input3, "type", "time");
    			attr_dev(input3, "id", input3_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time");
    			attr_dev(input3, "name", "time");
    			attr_dev(input3, "class", "svelte-le37x9");
    			add_location(input3, file$p, 314, 10, 11280);
    			set_custom_element_data(aeon_datepicker0, "local", "en-au");
    			add_location(aeon_datepicker0, file$p, 313, 8, 11237);
    			attr_dev(span7, "class", "cc-module-input svelte-le37x9");
    			add_location(span7, file$p, 306, 6, 11090);
    			attr_dev(div12, "class", "cc-module-form svelte-le37x9");
    			add_location(div12, file$p, 289, 4, 10464);
    			attr_dev(label4, "for", label4_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date");
    			add_location(label4, file$p, 326, 8, 11655);
    			attr_dev(div13, "slot", "content");
    			add_location(div13, file$p, 328, 10, 11787);
    			attr_dev(input4, "type", "checkbox");
    			add_location(input4, file$p, 329, 10, 11854);
    			set_custom_element_data(sl_tooltip6, "id", "cc-about-module-date-stop");
    			set_custom_element_data(sl_tooltip6, "class", "svelte-le37x9");
    			add_location(sl_tooltip6, file$p, 327, 8, 11732);
    			attr_dev(span8, "class", "cc-module-label svelte-le37x9");
    			add_location(span8, file$p, 325, 6, 11615);
    			attr_dev(div14, "slot", "content");
    			add_location(div14, file$p, 343, 10, 12322);
    			attr_dev(input5, "id", input5_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date");
    			attr_dev(input5, "type", "text");
    			input5.disabled = true;
    			input5.value = input5_value_value = "" + (/*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['date'] + " " + /*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['month']);
    			attr_dev(input5, "class", "svelte-le37x9");
    			add_location(input5, file$p, 345, 10, 12395);
    			set_custom_element_data(sl_tooltip7, "class", "cc-about-module-studyPeriod svelte-le37x9");
    			add_location(sl_tooltip7, file$p, 342, 8, 12262);
    			attr_dev(span9, "class", "cc-module-input svelte-le37x9");
    			add_location(span9, file$p, 341, 6, 12222);
    			attr_dev(div15, "class", "cc-module-form svelte-le37x9");
    			add_location(div15, file$p, 324, 4, 11579);
    			attr_dev(div16, "class", "cc-date-col svelte-le37x9");
    			attr_dev(div16, "id", div16_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-start");
    			add_location(div16, file$p, 195, 2, 7074);
    			attr_dev(div17, "slot", "content");
    			add_location(div17, file$p, 361, 8, 12933);
    			attr_dev(i3, "class", "icon-question cc-module-icon");
    			add_location(i3, file$p, 363, 11, 13072);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "rel", "noreferrer");
    			attr_dev(a3, "href", /*HELP*/ ctx[8].stopDate.href);
    			add_location(a3, file$p, 362, 8, 12998);
    			set_custom_element_data(sl_tooltip8, "id", "cc-about-module-date-stop");
    			set_custom_element_data(sl_tooltip8, "class", "svelte-le37x9");
    			add_location(sl_tooltip8, file$p, 360, 6, 12880);
    			attr_dev(div18, "class", "cc-date-heading svelte-le37x9");
    			add_location(div18, file$p, 358, 4, 12826);
    			attr_dev(div19, "class", "cc-module-form svelte-le37x9");
    			set_style(div19, "height", "2.375rem");
    			add_location(div19, file$p, 367, 4, 13167);
    			attr_dev(label5, "for", label5_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day-to");
    			add_location(label5, file$p, 370, 8, 13304);
    			attr_dev(span10, "class", "cc-module-label svelte-le37x9");
    			add_location(span10, file$p, 369, 6, 13264);
    			option2.__value = "";
    			option2.value = option2.__value;
    			add_location(option2, file$p, 380, 10, 13659);
    			attr_dev(select2, "id", select2_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day-to");
    			attr_dev(select2, "class", "svelte-le37x9");
    			if (/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["day"] === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[26].call(select2));
    			add_location(select2, file$p, 373, 8, 13434);
    			attr_dev(span11, "class", "cc-module-input svelte-le37x9");
    			add_location(span11, file$p, 372, 6, 13394);
    			attr_dev(div20, "class", "cc-module-form svelte-le37x9");
    			add_location(div20, file$p, 368, 4, 13228);
    			attr_dev(label6, "for", label6_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week-to");
    			add_location(label6, file$p, 389, 8, 13927);
    			attr_dev(span12, "class", "cc-module-label svelte-le37x9");
    			add_location(span12, file$p, 388, 6, 13887);
    			option3.__value = "";
    			option3.value = option3.__value;
    			add_location(option3, file$p, 399, 10, 14278);
    			attr_dev(select3, "id", select3_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week-to");
    			attr_dev(select3, "class", "svelte-le37x9");
    			if (/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["week"] === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[27].call(select3));
    			add_location(select3, file$p, 392, 8, 14051);
    			attr_dev(span13, "class", "cc-module-input svelte-le37x9");
    			add_location(span13, file$p, 391, 6, 14011);
    			attr_dev(div21, "class", "cc-module-form svelte-le37x9");
    			add_location(div21, file$p, 387, 4, 13851);
    			attr_dev(label7, "for", label7_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time-to");
    			add_location(label7, file$p, 408, 8, 14561);
    			attr_dev(span14, "class", "cc-module-label svelte-le37x9");
    			add_location(span14, file$p, 407, 6, 14521);
    			add_location(style1, file$p, 411, 8, 14685);
    			attr_dev(input6, "type", "time");
    			attr_dev(input6, "id", input6_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time-to");
    			attr_dev(input6, "name", "time");
    			attr_dev(input6, "class", "svelte-le37x9");
    			add_location(input6, file$p, 418, 10, 14835);
    			set_custom_element_data(aeon_datepicker1, "local", "en-au");
    			add_location(aeon_datepicker1, file$p, 417, 8, 14792);
    			attr_dev(span15, "class", "cc-module-input svelte-le37x9");
    			add_location(span15, file$p, 410, 6, 14645);
    			attr_dev(div22, "class", "cc-module-form svelte-le37x9");
    			add_location(div22, file$p, 406, 4, 14485);
    			attr_dev(label8, "for", label8_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date-to");
    			add_location(label8, file$p, 432, 8, 15249);
    			attr_dev(span16, "class", "cc-module-label svelte-le37x9");
    			add_location(span16, file$p, 431, 6, 15209);
    			attr_dev(div23, "slot", "content");
    			add_location(div23, file$p, 436, 10, 15442);
    			attr_dev(input7, "id", input7_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date-to");
    			attr_dev(input7, "type", "text");
    			input7.disabled = true;
    			input7.value = input7_value_value = "" + (/*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['to']['date'] + " " + /*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['to']['month']);
    			attr_dev(input7, "class", "svelte-le37x9");
    			add_location(input7, file$p, 437, 10, 15513);
    			set_custom_element_data(sl_tooltip9, "class", "cc-about-module-studyPeriod svelte-le37x9");
    			add_location(sl_tooltip9, file$p, 435, 8, 15382);
    			attr_dev(span17, "class", "cc-module-input svelte-le37x9");
    			add_location(span17, file$p, 434, 6, 15342);
    			attr_dev(div24, "class", "cc-module-form svelte-le37x9");
    			add_location(div24, file$p, 430, 4, 15173);
    			attr_dev(div25, "class", "cc-date-col svelte-le37x9");
    			attr_dev(div25, "id", div25_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-stop");
    			add_location(div25, file$p, 357, 2, 12752);
    			attr_dev(div26, "class", "cc-date-row svelte-le37x9");
    			add_location(div26, file$p, 194, 0, 7045);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, p0);
    			append_dev(p0, strong0);
    			append_dev(p0, t1);
    			append_dev(p0, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t2);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			append_dev(p0, t3);
    			append_dev(p0, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, p1);
    			append_dev(p1, strong1);
    			append_dev(p1, t7);
    			append_dev(p1, sl_tooltip1);
    			append_dev(sl_tooltip1, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t8);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(p1, t9);
    			append_dev(p1, t10);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div26, anchor);
    			append_dev(div26, div16);
    			append_dev(div16, div5);
    			append_dev(div5, t12);
    			append_dev(div5, sl_tooltip2);
    			append_dev(sl_tooltip2, div4);
    			div4.innerHTML = raw2_value;
    			append_dev(sl_tooltip2, t13);
    			append_dev(sl_tooltip2, a2);
    			append_dev(a2, i2);
    			append_dev(div16, t14);
    			append_dev(div16, div6);
    			append_dev(div6, span0);
    			append_dev(span0, label0);
    			append_dev(label0, t15);
    			append_dev(div6, t16);
    			append_dev(div6, span1);
    			if_block.m(span1, null);
    			append_dev(div16, t17);
    			append_dev(div16, div8);
    			append_dev(div8, span2);
    			append_dev(span2, label1);
    			append_dev(label1, t18);
    			append_dev(span2, t19);
    			append_dev(span2, sl_tooltip3);
    			append_dev(sl_tooltip3, div7);
    			div7.innerHTML = raw3_value;
    			append_dev(sl_tooltip3, t20);
    			append_dev(sl_tooltip3, input0);
    			input0.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["day"];
    			append_dev(div8, t21);
    			append_dev(div8, span3);
    			append_dev(span3, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select0, null);
    			}

    			select_option(select0, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["day"]);
    			append_dev(div16, t23);
    			append_dev(div16, div10);
    			append_dev(div10, span4);
    			append_dev(span4, label2);
    			append_dev(label2, t24);
    			append_dev(span4, t25);
    			append_dev(span4, sl_tooltip4);
    			append_dev(sl_tooltip4, div9);
    			div9.innerHTML = raw4_value;
    			append_dev(sl_tooltip4, t26);
    			append_dev(sl_tooltip4, input1);
    			input1.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["week"];
    			append_dev(div10, t27);
    			append_dev(div10, span5);
    			append_dev(span5, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select1, null);
    			}

    			select_option(select1, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["week"]);
    			append_dev(div16, t29);
    			append_dev(div16, div12);
    			append_dev(div12, span6);
    			append_dev(span6, label3);
    			append_dev(label3, t30);
    			append_dev(span6, t31);
    			append_dev(span6, sl_tooltip5);
    			append_dev(sl_tooltip5, div11);
    			div11.innerHTML = raw5_value;
    			append_dev(sl_tooltip5, t32);
    			append_dev(sl_tooltip5, input2);
    			input2.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["time"];
    			append_dev(div12, t33);
    			append_dev(div12, span7);
    			append_dev(span7, style0);
    			append_dev(span7, t35);
    			append_dev(span7, aeon_datepicker0);
    			append_dev(aeon_datepicker0, input3);
    			set_input_value(input3, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["time"]);
    			append_dev(div16, t36);
    			append_dev(div16, div15);
    			append_dev(div15, span8);
    			append_dev(span8, label4);
    			append_dev(label4, t37);
    			append_dev(span8, t38);
    			append_dev(span8, sl_tooltip6);
    			append_dev(sl_tooltip6, div13);
    			div13.innerHTML = raw6_value;
    			append_dev(sl_tooltip6, t39);
    			append_dev(sl_tooltip6, input4);
    			input4.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["calendarDate"];
    			append_dev(div15, t40);
    			append_dev(div15, span9);
    			append_dev(span9, sl_tooltip7);
    			append_dev(sl_tooltip7, div14);
    			div14.innerHTML = raw7_value;
    			append_dev(sl_tooltip7, t41);
    			append_dev(sl_tooltip7, input5);
    			append_dev(div26, t42);
    			append_dev(div26, div25);
    			append_dev(div25, div18);
    			append_dev(div18, t43);
    			append_dev(div18, sl_tooltip8);
    			append_dev(sl_tooltip8, div17);
    			div17.innerHTML = raw8_value;
    			append_dev(sl_tooltip8, t44);
    			append_dev(sl_tooltip8, a3);
    			append_dev(a3, i3);
    			append_dev(div25, t45);
    			append_dev(div25, div19);
    			append_dev(div25, t46);
    			append_dev(div25, div20);
    			append_dev(div20, span10);
    			append_dev(span10, label5);
    			append_dev(label5, t47);
    			append_dev(div20, t48);
    			append_dev(div20, span11);
    			append_dev(span11, select2);
    			append_dev(select2, option2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select2, null);
    			}

    			select_option(select2, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["day"]);
    			append_dev(div25, t50);
    			append_dev(div25, div21);
    			append_dev(div21, span12);
    			append_dev(span12, label6);
    			append_dev(label6, t51);
    			append_dev(div21, t52);
    			append_dev(div21, span13);
    			append_dev(span13, select3);
    			append_dev(select3, option3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select3, null);
    			}

    			select_option(select3, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["week"]);
    			append_dev(div25, t54);
    			append_dev(div25, div22);
    			append_dev(div22, span14);
    			append_dev(span14, label7);
    			append_dev(label7, t55);
    			append_dev(div22, t56);
    			append_dev(div22, span15);
    			append_dev(span15, style1);
    			append_dev(span15, t58);
    			append_dev(span15, aeon_datepicker1);
    			append_dev(aeon_datepicker1, input6);
    			set_input_value(input6, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["time"]);
    			append_dev(div25, t59);
    			append_dev(div25, div24);
    			append_dev(div24, span16);
    			append_dev(span16, label8);
    			append_dev(label8, t60);
    			append_dev(div24, t61);
    			append_dev(div24, span17);
    			append_dev(span17, sl_tooltip9);
    			append_dev(sl_tooltip9, div23);
    			div23.innerHTML = raw9_value;
    			append_dev(sl_tooltip9, t62);
    			append_dev(sl_tooltip9, input7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keydown", stop_propagation(/*keydown_handler_1*/ ctx[12]), false, false, true),
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[15]),
    					listen_dev(input0, "click", /*click_handler*/ ctx[16], false, false, false),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[17]),
    					listen_dev(select0, "change", /*updateDate*/ ctx[7], false, false, false),
    					listen_dev(input1, "keydown", stop_propagation(/*keydown_handler_2*/ ctx[11]), false, false, true),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[18]),
    					listen_dev(input1, "click", /*click_handler_1*/ ctx[19], false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[20]),
    					listen_dev(select1, "change", /*updateDate*/ ctx[7], false, false, false),
    					listen_dev(input2, "keydown", stop_propagation(/*keydown_handler_3*/ ctx[10]), false, false, true),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[21]),
    					listen_dev(input2, "click", /*click_handler_2*/ ctx[22], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[23]),
    					listen_dev(input3, "change", /*updateDate*/ ctx[7], false, false, false),
    					listen_dev(input4, "keydown", stop_propagation(/*keydown_handler_4*/ ctx[9]), false, false, true),
    					listen_dev(input4, "change", /*input4_change_handler*/ ctx[24]),
    					listen_dev(input4, "click", /*click_handler_3*/ ctx[25], false, false, false),
    					listen_dev(select2, "change", /*select2_change_handler*/ ctx[26]),
    					listen_dev(select2, "change", /*updateDate*/ ctx[7], false, false, false),
    					listen_dev(select3, "change", /*select3_change_handler*/ ctx[27]),
    					listen_dev(select3, "change", /*updateDate*/ ctx[7], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[28]),
    					listen_dev(input6, "change", /*updateDate*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$collectionsStore, moduleId*/ 3 && t10_value !== (t10_value = /*calculateDate*/ ctx[6](/*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]].date) + "")) set_data_dev(t10, t10_value);

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label0_for_value !== (label0_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-label")) {
    				attr_dev(label0, "for", label0_for_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span1, null);
    				}
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label1_for_value !== (label1_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day")) {
    				attr_dev(label1, "for", label1_for_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				input0.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["day"];
    			}

    			if (dirty[0] & /*daysOfWeek*/ 16) {
    				each_value_3 = /*daysOfWeek*/ ctx[4];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && select0_id_value !== (select0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day")) {
    				attr_dev(select0, "id", select0_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				select_option(select0, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["day"]);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label2_for_value !== (label2_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week")) {
    				attr_dev(label2, "for", label2_for_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				input1.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["week"];
    			}

    			if (dirty[0] & /*weeksOfTerm*/ 32) {
    				each_value_2 = /*weeksOfTerm*/ ctx[5];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && select1_id_value !== (select1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week")) {
    				attr_dev(select1, "id", select1_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				select_option(select1, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["week"]);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label3_for_value !== (label3_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time")) {
    				attr_dev(label3, "for", label3_for_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				input2.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["time"];
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && input3_id_value !== (input3_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time")) {
    				attr_dev(input3, "id", input3_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				set_input_value(input3, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["time"]);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label4_for_value !== (label4_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date")) {
    				attr_dev(label4, "for", label4_for_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				input4.checked = /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["dateHide"]["calendarDate"];
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && input5_id_value !== (input5_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date")) {
    				attr_dev(input5, "id", input5_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19 && input5_value_value !== (input5_value_value = "" + (/*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['date'] + " " + /*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['month'])) && input5.value !== input5_value_value) {
    				prop_dev(input5, "value", input5_value_value);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && div16_id_value !== (div16_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-start")) {
    				attr_dev(div16, "id", div16_id_value);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label5_for_value !== (label5_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day-to")) {
    				attr_dev(label5, "for", label5_for_value);
    			}

    			if (dirty[0] & /*daysOfWeek*/ 16) {
    				each_value_1 = /*daysOfWeek*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$4(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && select2_id_value !== (select2_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-day-to")) {
    				attr_dev(select2, "id", select2_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				select_option(select2, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["day"]);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label6_for_value !== (label6_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week-to")) {
    				attr_dev(label6, "for", label6_for_value);
    			}

    			if (dirty[0] & /*weeksOfTerm*/ 32) {
    				each_value = /*weeksOfTerm*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && select3_id_value !== (select3_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-week-to")) {
    				attr_dev(select3, "id", select3_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				select_option(select3, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["week"]);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label7_for_value !== (label7_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time-to")) {
    				attr_dev(label7, "for", label7_for_value);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && input6_id_value !== (input6_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-time-to")) {
    				attr_dev(input6, "id", input6_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19) {
    				set_input_value(input6, /*$collectionsStore*/ ctx[1]["MODULES"][/*moduleId*/ ctx[0]]["date"]["to"]["time"]);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && label8_for_value !== (label8_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date-to")) {
    				attr_dev(label8, "for", label8_for_value);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && input7_id_value !== (input7_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-calendar-date-to")) {
    				attr_dev(input7, "id", input7_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId, daysOfWeek*/ 19 && input7_value_value !== (input7_value_value = "" + (/*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['to']['date'] + " " + /*$collectionsStore*/ ctx[1]['MODULES'][/*moduleId*/ ctx[0]]['date']['to']['month'])) && input7.value !== input7_value_value) {
    				prop_dev(input7, "value", input7_value_value);
    			}

    			if (dirty[0] & /*moduleId, daysOfWeek*/ 17 && div25_id_value !== (div25_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-date-stop")) {
    				attr_dev(div25, "id", div25_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div26);
    			if_block.d();
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	let $configStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(1, $collectionsStore = $$value));
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(2, $configStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModuleDateConfiguration', slots, []);
    	let { moduleId } = $$props;
    	let calendar = new UniversityDateCalendar();

    	// tmp kludge
    	let currentStudyPeriod = `${calendar.getHumanReadableStudyPeriod()} (${calendar.getStudyPeriod()})`;

    	let calculatedDate = calculateDate($collectionsStore["MODULES"][moduleId].date);
    	let originalDate = $collectionsStore["MODULES"][moduleId].date;

    	// TODO move these into UniversityDateCalendar?
    	const daysOfWeek = calendar.getDaysOfWeek();

    	const weeksOfTerm = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, "exam"];

    	/**
     * @function calculateDate
     * @param {Object} dateInfo - module date json
     * @return {String} - human readable date
     * @description Conert json date into a human readable date using the
     * calendar to calculate
     * Return "No set date" if no date is set
     */
    	function calculateDate(dateInfo) {
    		// valid date combinations will be
    		// 1. week
    		// 2. week and day
    		// 3. week and day and time
    		// - must have a week
    		if (dateInfo.week === "") {
    			return "No date set";
    		}

    		let dateString = dateJsonToString(dateInfo);

    		if (dateInfo.hasOwnProperty("to") && dateInfo.to.week !== "") {
    			// date range
    			dateString = `${dateString} to ${dateJsonToString(dateInfo.to)}`;
    		}

    		return dateString;
    	}

    	function dateJsonToString(dateInfo) {
    		let calcDate = {};

    		if (dateInfo.day === "") {
    			// no day
    			calcDate = calendar.getDate(dateInfo.week);
    		} else {
    			calcDate = calendar.getDate(dateInfo.week, false, dateInfo.day);
    		}

    		let dateString = `${calcDate["date"]} ${calcDate["month"]} ${calcDate["year"]}`;

    		if (calcDate.hasOwnProperty("day")) {
    			dateString = `${calcDate["day"]} ${dateString}`;
    		}

    		if (dateInfo.time !== "") {
    			// no time
    			dateString = `${dateInfo.time} ${dateString}`;
    		}

    		if (dateInfo.hasOwnProperty("label") && dateInfo.label !== "") {
    			dateString = `${dateInfo.label} ${dateString}`;
    		}

    		return dateString;
    	}

    	/**
     * @function updateDate
     * @description Called whenever any change has been made to the date
     * - update the calculateDate
     * - set needToSave to true
     */
    	function updateDate() {
    		// also need to recalculate the date and month
    		modifyDate();

    		//calculatedDate = calculateDate($collectionsStore["MODULES"][moduleId].date);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	/**
     * @function modifyDate
     * @description Something has changed about the module's date. Need to recalculate the
     * and update the calendar date for one of the from or to dates
     * - call getDate on from
     * - call getDate on to - if it exists
     * - compare the resulting JSON and make any chances necessary
     */
    	function modifyDate() {
    		// calculate new date for from
    		let newFrom = {};

    		if ($collectionsStore["MODULES"][moduleId]["date"].day === "") {
    			// no day
    			newFrom = calendar.getDate($collectionsStore["MODULES"][moduleId]["date"].week);
    		} else {
    			newFrom = calendar.getDate($collectionsStore["MODULES"][moduleId]["date"].week, false, $collectionsStore["MODULES"][moduleId]["date"].day);
    		}

    		// calculate new date for to
    		let newTo = {};

    		if ($collectionsStore["MODULES"][moduleId]["date"].hasOwnProperty("to")) {
    			if ($collectionsStore["MODULES"][moduleId]["date"].to.day === "") {
    				newTo = calendar.getDate($collectionsStore["MODULES"][moduleId]["date"].to.week);
    			} else {
    				newTo = calendar.getDate($collectionsStore["MODULES"][moduleId]["date"].to.week, false, $collectionsStore["MODULES"][moduleId]["date"].to.day);
    			}
    		}

    		// date and month specific the calendar date, this is what we need to check and update
    		const fieldsToCheck = ["date", "month"];

    		fieldsToCheck.forEach(field => {
    			if (newFrom[field] !== originalDate[field]) {
    				set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId]["date"][field] = newFrom[field], $collectionsStore);
    			}

    			if (newTo[field] !== originalDate["to"][field]) {
    				set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId]["date"]["to"][field] = newTo[field], $collectionsStore);
    			}
    		});
    	}

    	/**
     * Define the tooltip and help site links for this module
     */
    	const HELP = {
    		studyPeriod: {
    			tooltip: `The term is automatically identified from the course site. The academic
		calendar for this term will be used to translate the generic date <em>Monday Week 1</em> into a calendar date.`,
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#study-period"
    		},
    		dateStart: {
    			tooltip: `Specify a single date, or becomes the start date in a date range when used 
		with "stop" date.`,
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#start-date"
    		},
    		stopDate: {
    			tooltip: `Specify the 'stop' date for a date range. Date is relative to the specific study period.`,
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#stop-date"
    		},
    		calculatedDate: {
    			tooltip: `Representation of the date as configured by <em>Start Date</em> and possible <em>Stop Date</em>.`,
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#start-date"
    		},
    		hideDate: {
    			tooltip: `Select to hide this portion of the date in the representation.`
    		},
    		calendarDate: {
    			tooltip: `<p>Calculated automatically based on the academic calendar and the current term.<p>
        <p>Use the above to change.</p>`
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<ModuleDateConfiguration> was created without expected prop 'moduleId'");
    		}
    	});

    	const writable_props = ['moduleId'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModuleDateConfiguration> was created with unknown prop '${key}'`);
    	});

    	function keydown_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_input_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["label"] = this.value;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	function input0_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["dateHide"]["day"] = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	const click_handler = () => {
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	};

    	function select0_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["day"] = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	function input1_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["dateHide"]["week"] = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	const click_handler_1 = () => {
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	};

    	function select1_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["week"] = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	function input2_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["dateHide"]["time"] = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	const click_handler_2 = () => {
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	};

    	function input3_input_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["time"] = this.value;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	function input4_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["dateHide"]["calendarDate"] = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	const click_handler_3 = () => {
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	};

    	function select2_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["to"]["day"] = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	function select3_change_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["to"]["week"] = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	function input6_input_handler() {
    		$collectionsStore["MODULES"][moduleId]["date"]["to"]["time"] = this.value;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(4, daysOfWeek);
    	}

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		UniversityDateCalendar,
    		moduleId,
    		calendar,
    		currentStudyPeriod,
    		calculatedDate,
    		originalDate,
    		daysOfWeek,
    		weeksOfTerm,
    		calculateDate,
    		dateJsonToString,
    		updateDate,
    		modifyDate,
    		HELP,
    		$collectionsStore,
    		$configStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    		if ('calendar' in $$props) calendar = $$props.calendar;
    		if ('currentStudyPeriod' in $$props) $$invalidate(3, currentStudyPeriod = $$props.currentStudyPeriod);
    		if ('calculatedDate' in $$props) calculatedDate = $$props.calculatedDate;
    		if ('originalDate' in $$props) originalDate = $$props.originalDate;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		moduleId,
    		$collectionsStore,
    		$configStore,
    		currentStudyPeriod,
    		daysOfWeek,
    		weeksOfTerm,
    		calculateDate,
    		updateDate,
    		HELP,
    		keydown_handler_4,
    		keydown_handler_3,
    		keydown_handler_2,
    		keydown_handler_1,
    		keydown_handler,
    		input_input_handler,
    		input0_change_handler,
    		click_handler,
    		select0_change_handler,
    		input1_change_handler,
    		click_handler_1,
    		select1_change_handler,
    		input2_change_handler,
    		click_handler_2,
    		input3_input_handler,
    		input4_change_handler,
    		click_handler_3,
    		select2_change_handler,
    		select3_change_handler,
    		input6_input_handler
    	];
    }

    class ModuleDateConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { moduleId: 0 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModuleDateConfiguration",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<ModuleDateConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<ModuleDateConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Define suite of methods to interact with Canvas during app set up
     */
    /**
     * @function checkContext
     * @returns {Object} containing editMode, courseId, modulesPage
     * @description Check the current URL to determine it it is Canvas modules
     * page, identify the courseId and if we're in edit mode
     */
    function checkContext() {
        let context = {
            editMode: false,
            courseId: null,
            modulesPage: false,
            csrfToken: null,
            currentCollection: 0,
            showConfig: false,
        };
        // replace # at end of string
        let url = new URL(window.location.href);
        // check if there's a cc-collection-\d+ in the hash
        // this is the case for internal navigation within collections
        // i.e. we're on a modules page
        /*  let hash = url.hash;
        if (hash) {
          let checkNum = hash.match(/cc-collection-(\d+)/);
          if (checkNum) {
            // will set this to a number now, for later translation to collectionName
            context.currentCollection = parseInt(checkNum[1]) ;
          }
        } */
        url.hash = "";
        const documentUrl = url.href;
        //documentUrl = documentUrl.replace(/#$/, '');
        // courseId
        // Following adapted from https://github.com/msdlt/canvas-where-am-I
        // if ENV object has a COURSE_ID field and it is an integer, set context.courseId
        if (ENV.COURSE_ID && ENV.COURSE_ID.match(/^\d+$/)) {
            context.courseId = ENV.COURSE_ID;
        }
        else {
            // try and extract it from the URL
            let urlPartIncludingCourseId = documentUrl.split("courses/")[1];
            if (urlPartIncludingCourseId) {
                const localCourseId = urlPartIncludingCourseId.split("/")[0];
                // if localCourseId is an integer, set context.courseId
                if (localCourseId.match(/^\d+$/)) {
                    context.courseId = localCourseId;
                }
            }
        }
        // fail here if we've not gotten a courseId
        if (!context.courseId) {
            throw new Error("No courseId found");
        }
        // modulesPage true if location ends with courses/${courseId}/modules
        let regEx = new RegExp(`courses/${context.courseId}/modules(/*|#*|#[^/]+)$`);
        context.modulesPage = regEx.test(documentUrl);
        if (!context.modulesPage) {
            // check to see if the home page has been set to modules
            // homeModulesPage true iff
            // - location ends with courses/${courseId}
            // - div#context_modules is present
            regEx = new RegExp(`courses/${context.courseId}$`);
            context.modulesPage =
                regEx.test(documentUrl) &&
                    document.getElementById("context_modules") !== null;
        }
        // editMode true iff a#easy_student_view exists
        // TODO - perhaps replace/extend this with another check using
        // the course object later
        context.editMode = document.getElementById("easy_student_view") !== null;
        context.csrfToken = setCsrfToken();
        return context;
    }
    /**
     * @function setCsrfToken
     * @returns {String} csrfToken
     * Following adapted from https://github.com/msdlt/canvas-where-am-I
     * Function which returns csrf_token from cookie see:
     * https://community.canvaslms.com/thread/22500-mobile-javascript-development
     */
    function setCsrfToken() {
        let csrfRegex = new RegExp("^_csrf_token=(.*)$");
        let cookies = document.cookie.split(";");
        for (let i = 0; i < cookies.length; i++) {
            let cookie = cookies[i].trim();
            let match = csrfRegex.exec(cookie);
            if (match) {
                return decodeURIComponent(match[1]);
            }
        }
        return null;
    }
    /**
     * Fetch function for retrieving information from a single endpoint request
     * @param {String} reqUrl Endpoint URL to query the Canvas API
     * @returns Response Object
     */
    const wf_fetchData = async (reqUrl) => {
        const url = reqUrl;
        try {
            const res = await fetch(url);
            /*    if (res.status === 404)
                  // Endpoint not found
                  return null;
                if (res.status === 401)
                  // User not authorized
                  return null; */
            const body = await res.json();
            const msg = {
                status: res.status,
                res: res,
                body: body,
            };
            return msg;
        }
        catch (e) {
            console.error(`Could not fetch requested information: ${e}`);
        }
    };
    /**
     * @function wf_postData
     * @param reqUrl
     * @param data
     * @param csrf
     * @param post - POST or PUT
     * @returns json response (if successful), null otherwise
     *
     */
    const wf_postData = async (reqUrl, data, csrf, post = "POST") => {
        try {
            const res = await fetch(reqUrl, {
                method: post,
                credentials: "include",
                headers: {
                    "Content-Type": "application/json; charset=UTF-8",
                    Accept: "application/json; charset=UTF-8",
                    "X-CSRF-Token": csrf,
                },
                body: data,
            });
            if (res.status === 404)
                // Endpoint not found
                return null;
            if (res.status === 401)
                // User not authorized
                return null;
            const json = await res.json();
            return json;
        }
        catch (e) {
            console.error(`Could not post requested information: ${e}`);
        }
    };
    /**
     * add the div#canvas-collections-representation to the DOM ready for
     * the Svelte component to be added
     * Return the div if added, null if not
     */
    function addCollectionsRepresentation() {
        // check that there isn't already a div#canvas-collections-representation
        // if there is, do nothing
        const representation = document.querySelector("div#canvas-collections-representation");
        if (representation) {
            // if it's already there, empty it
            return null;
        }
        // get the div#context-modules
        const contextModules = document.querySelector("div#context_modules");
        if (!contextModules) {
            return null;
        }
        // add a div#canvas-collections-representation as first child of div#context-modules
        let canvasCollectionsRepresentation = document.createElement("div");
        canvasCollectionsRepresentation.id = "canvas-collections-representation";
        contextModules.prepend(canvasCollectionsRepresentation);
        return canvasCollectionsRepresentation;
    }
    /**
     * @function removeCollectionsRepresentation
     * @description Remove the div#canvas-collections-representation from the DOM
     */
    function removeCollectionsRepresentation() {
        const representation = document.querySelector("div#canvas-collections-representation");
        if (representation) {
            representation.remove();
        }
    }
    /**
     * @function removeModuleConfiguration
     * @param {Object} modules - hash of module objects keyed on moduleId
     * @description loop through all the modules and remove div#cc-module-config-<moduleId>
     */
    function removeModuleConfiguration(modules) {
        // loop thru the keys of the modules hash
        Object.keys(modules).forEach((moduleId) => {
            const moduleConfig = document.querySelector(`div#cc-module-config-${moduleId}`);
            if (moduleConfig) {
                moduleConfig.remove();
            }
            // make sure all the modules are visible
            const module = document.getElementById(`context_module_${moduleId}`);
            if (module) {
                module.style.display = "block";
            }
        });
    }
    /**
     * @function getPageName
     * @param {String} pageName - name of the page
     * @param {String} courseId - id of the course
     * @param {Function} callBack - function to call when the page name is found (or not)
     * @description Given the visible name of a page (e.g. "Canvas Collections Configuration")
     * - Slugify the name (e.g. "canvas-collections-configuration")
     * - use the Canvas API to get the page Object
     * - return the pageName and the results (positive or not) to the callBack function
     * - The pageObject will be null if page not found
     */
    function getPageName(pageName, courseId, callBack) {
        if (pageName === undefined) {
            console.trace();
            alert("getPageName: pageName is undefined");
            return;
        }
        if (pageName !== "") {
            // only do this if we've a valid page name
            String.prototype.slugify = function (separator = "-") {
                return this.toString()
                    .normalize("NFD") // split an accented letter in the base letter and the acent
                    .replace(/[\u0300-\u036f]/g, "") // remove all previously split accents
                    .toLowerCase()
                    .trim()
                    .replace("@", "at")
                    .replace(/[^a-z0-9 ]/g, "") // remove all chars not letters, numbers and spaces (to be replaced)
                    .replace(/\s+/g, separator);
            };
            const slugifiedPageName = pageName.slugify();
            const apiUrl = `https://${document.location.hostname}/api/v1/courses/${courseId}/pages/${slugifiedPageName}`;
            wf_fetchData(apiUrl).then((msg) => {
                callBack(pageName, msg.body);
            });
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    // Generated using scripts/write-decode-map.ts

    var _default$2 = new Uint16Array(
    // prettier-ignore
    "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
        .split("")
        .map(function (c) { return c.charCodeAt(0); }));


    var decodeDataHtml = /*#__PURE__*/Object.defineProperty({
    	default: _default$2
    }, '__esModule', {value: true});

    // Generated using scripts/write-decode-map.ts

    var _default$1 = new Uint16Array(
    // prettier-ignore
    "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
        .split("")
        .map(function (c) { return c.charCodeAt(0); }));


    var decodeDataXml = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var decode_codepoint = createCommonjsModule(function (module, exports) {
    // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = new Map([
        [0, 65533],
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
    ]);
    exports.fromCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
    function replaceCodePoint(codePoint) {
        var _a;
        if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
            return 0xfffd;
        }
        return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
        return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;

    });

    var decode = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(decodeDataHtml);
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(decodeDataXml);
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importDefault(decode_codepoint);
    exports.decodeCodePoint = decode_codepoint_js_1.default;

    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function () { return decode_codepoint.replaceCodePoint; } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function () { return decode_codepoint.fromCodePoint; } });
    var CharCodes;
    (function (CharCodes) {
        CharCodes[CharCodes["NUM"] = 35] = "NUM";
        CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
        CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
        CharCodes[CharCodes["NINE"] = 57] = "NINE";
        CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
        CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
        CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
        /** Bit that needs to be set to convert an upper case ASCII character to lower case */
        CharCodes[CharCodes["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
    })(CharCodes || (CharCodes = {}));
    var BinTrieFlags;
    (function (BinTrieFlags) {
        BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function getDecoder(decodeTree) {
        return function decodeHTMLBinary(str, strict) {
            var ret = "";
            var lastIdx = 0;
            var strIdx = 0;
            while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
                ret += str.slice(lastIdx, strIdx);
                lastIdx = strIdx;
                // Skip the "&"
                strIdx += 1;
                // If we have a numeric entity, handle this separately.
                if (str.charCodeAt(strIdx) === CharCodes.NUM) {
                    // Skip the leading "&#". For hex entities, also skip the leading "x".
                    var start = strIdx + 1;
                    var base = 10;
                    var cp = str.charCodeAt(start);
                    if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {
                        base = 16;
                        strIdx += 1;
                        start += 1;
                    }
                    do
                        cp = str.charCodeAt(++strIdx);
                    while ((cp >= CharCodes.ZERO && cp <= CharCodes.NINE) ||
                        (base === 16 &&
                            (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A &&
                            (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F));
                    if (start !== strIdx) {
                        var entity = str.substring(start, strIdx);
                        var parsed = parseInt(entity, base);
                        if (str.charCodeAt(strIdx) === CharCodes.SEMI) {
                            strIdx += 1;
                        }
                        else if (strict) {
                            continue;
                        }
                        ret += (0, decode_codepoint_js_1.default)(parsed);
                        lastIdx = strIdx;
                    }
                    continue;
                }
                var resultIdx = 0;
                var excess = 1;
                var treeIdx = 0;
                var current = decodeTree[treeIdx];
                for (; strIdx < str.length; strIdx++, excess++) {
                    treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
                    if (treeIdx < 0)
                        break;
                    current = decodeTree[treeIdx];
                    var masked = current & BinTrieFlags.VALUE_LENGTH;
                    // If the branch is a value, store it and continue
                    if (masked) {
                        // If we have a legacy entity while parsing strictly, just skip the number of bytes
                        if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {
                            resultIdx = treeIdx;
                            excess = 0;
                        }
                        // The mask is the number of bytes of the value, including the current byte.
                        var valueLength = (masked >> 14) - 1;
                        if (valueLength === 0)
                            break;
                        treeIdx += valueLength;
                    }
                }
                if (resultIdx !== 0) {
                    var valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;
                    ret +=
                        valueLength === 1
                            ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH)
                            : valueLength === 2
                                ? String.fromCharCode(decodeTree[resultIdx + 1])
                                : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);
                    lastIdx = strIdx - excess + 1;
                }
            }
            return ret + str.slice(lastIdx);
        };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
        var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        // Case 1: Single branch encoded in jump offset
        if (branchCount === 0) {
            return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        // Case 2: Multiple branches encoded in jump table
        if (jumpOffset) {
            var value = char - jumpOffset;
            return value < 0 || value >= branchCount
                ? -1
                : decodeTree[nodeIdx + value] - 1;
        }
        // Case 3: Multiple branches encoded in dictionary
        // Binary search for the character.
        var lo = nodeIdx;
        var hi = lo + branchCount - 1;
        while (lo <= hi) {
            var mid = (lo + hi) >>> 1;
            var midVal = decodeTree[mid];
            if (midVal < char) {
                lo = mid + 1;
            }
            else if (midVal > char) {
                hi = mid - 1;
            }
            else {
                return decodeTree[mid + branchCount];
            }
        }
        return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    /**
     * Decodes an HTML string, allowing for entities not terminated by a semi-colon.
     *
     * @param str The string to decode.
     * @returns The decoded string.
     */
    function decodeHTML(str) {
        return htmlDecoder(str, false);
    }
    exports.decodeHTML = decodeHTML;
    /**
     * Decodes an HTML string, requiring all entities to be terminated by a semi-colon.
     *
     * @param str The string to decode.
     * @returns The decoded string.
     */
    function decodeHTMLStrict(str) {
        return htmlDecoder(str, true);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    /**
     * Decodes an XML string, requiring all entities to be terminated by a semi-colon.
     *
     * @param str The string to decode.
     * @returns The decoded string.
     */
    function decodeXML(str) {
        return xmlDecoder(str, true);
    }
    exports.decodeXML = decodeXML;

    });

    var Tokenizer_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuoteType = void 0;

    var CharCodes;
    (function (CharCodes) {
        CharCodes[CharCodes["Tab"] = 9] = "Tab";
        CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
        CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
        CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
        CharCodes[CharCodes["Space"] = 32] = "Space";
        CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
        CharCodes[CharCodes["Num"] = 35] = "Num";
        CharCodes[CharCodes["Amp"] = 38] = "Amp";
        CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
        CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
        CharCodes[CharCodes["Dash"] = 45] = "Dash";
        CharCodes[CharCodes["Slash"] = 47] = "Slash";
        CharCodes[CharCodes["Zero"] = 48] = "Zero";
        CharCodes[CharCodes["Nine"] = 57] = "Nine";
        CharCodes[CharCodes["Semi"] = 59] = "Semi";
        CharCodes[CharCodes["Lt"] = 60] = "Lt";
        CharCodes[CharCodes["Eq"] = 61] = "Eq";
        CharCodes[CharCodes["Gt"] = 62] = "Gt";
        CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
        CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
        CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
        CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
        CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
        CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
        CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
        CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
        CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    /** All the states the tokenizer can be in. */
    var State;
    (function (State) {
        State[State["Text"] = 1] = "Text";
        State[State["BeforeTagName"] = 2] = "BeforeTagName";
        State[State["InTagName"] = 3] = "InTagName";
        State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
        State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
        State[State["InClosingTagName"] = 6] = "InClosingTagName";
        State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
        // Attributes
        State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
        State[State["InAttributeName"] = 9] = "InAttributeName";
        State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
        State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
        State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
        State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
        State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
        // Declarations
        State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
        State[State["InDeclaration"] = 16] = "InDeclaration";
        // Processing instructions
        State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
        // Comments & CDATA
        State[State["BeforeComment"] = 18] = "BeforeComment";
        State[State["CDATASequence"] = 19] = "CDATASequence";
        State[State["InSpecialComment"] = 20] = "InSpecialComment";
        State[State["InCommentLike"] = 21] = "InCommentLike";
        // Special tags
        State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
        State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
        State[State["InSpecialTag"] = 24] = "InSpecialTag";
        State[State["BeforeEntity"] = 25] = "BeforeEntity";
        State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
        State[State["InNamedEntity"] = 27] = "InNamedEntity";
        State[State["InNumericEntity"] = 28] = "InNumericEntity";
        State[State["InHexEntity"] = 29] = "InHexEntity";
    })(State || (State = {}));
    function isWhitespace(c) {
        return (c === CharCodes.Space ||
            c === CharCodes.NewLine ||
            c === CharCodes.Tab ||
            c === CharCodes.FormFeed ||
            c === CharCodes.CarriageReturn);
    }
    function isEndOfTagSection(c) {
        return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
    }
    function isNumber(c) {
        return c >= CharCodes.Zero && c <= CharCodes.Nine;
    }
    function isASCIIAlpha(c) {
        return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
            (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
    }
    function isHexDigit(c) {
        return ((c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
            (c >= CharCodes.LowerA && c <= CharCodes.LowerF));
    }
    var QuoteType;
    (function (QuoteType) {
        QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
        QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
        QuoteType[QuoteType["Single"] = 2] = "Single";
        QuoteType[QuoteType["Double"] = 3] = "Double";
    })(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
    /**
     * Sequences used to match longer strings.
     *
     * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
     * sequences with an increased offset.
     */
    var Sequences = {
        Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
        CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
        CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
        ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
        StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
        TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
    };
    var Tokenizer = /** @class */ (function () {
        function Tokenizer(_a, cbs) {
            var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
            this.cbs = cbs;
            /** The current state the tokenizer is in. */
            this.state = State.Text;
            /** The read buffer. */
            this.buffer = "";
            /** The beginning of the section that is currently being read. */
            this.sectionStart = 0;
            /** The index within the buffer that we are currently looking at. */
            this.index = 0;
            /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
            this.baseState = State.Text;
            /** For special parsing behavior inside of script and style tags. */
            this.isSpecial = false;
            /** Indicates whether the tokenizer has been paused. */
            this.running = true;
            /** The offset of the current buffer. */
            this.offset = 0;
            this.sequenceIndex = 0;
            this.trieIndex = 0;
            this.trieCurrent = 0;
            /** For named entities, the index of the value. For numeric entities, the code point. */
            this.entityResult = 0;
            this.entityExcess = 0;
            this.xmlMode = xmlMode;
            this.decodeEntities = decodeEntities;
            this.entityTrie = xmlMode ? decode.xmlDecodeTree : decode.htmlDecodeTree;
        }
        Tokenizer.prototype.reset = function () {
            this.state = State.Text;
            this.buffer = "";
            this.sectionStart = 0;
            this.index = 0;
            this.baseState = State.Text;
            this.currentSequence = undefined;
            this.running = true;
            this.offset = 0;
        };
        Tokenizer.prototype.write = function (chunk) {
            this.offset += this.buffer.length;
            this.buffer = chunk;
            this.parse();
        };
        Tokenizer.prototype.end = function () {
            if (this.running)
                this.finish();
        };
        Tokenizer.prototype.pause = function () {
            this.running = false;
        };
        Tokenizer.prototype.resume = function () {
            this.running = true;
            if (this.index < this.buffer.length + this.offset) {
                this.parse();
            }
        };
        /**
         * The current index within all of the written data.
         */
        Tokenizer.prototype.getIndex = function () {
            return this.index;
        };
        /**
         * The start of the current section.
         */
        Tokenizer.prototype.getSectionStart = function () {
            return this.sectionStart;
        };
        Tokenizer.prototype.stateText = function (c) {
            if (c === CharCodes.Lt ||
                (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
                if (this.index > this.sectionStart) {
                    this.cbs.ontext(this.sectionStart, this.index);
                }
                this.state = State.BeforeTagName;
                this.sectionStart = this.index;
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.state = State.BeforeEntity;
            }
        };
        Tokenizer.prototype.stateSpecialStartSequence = function (c) {
            var isEnd = this.sequenceIndex === this.currentSequence.length;
            var isMatch = isEnd
                ? // If we are at the end of the sequence, make sure the tag name has ended
                    isEndOfTagSection(c)
                : // Otherwise, do a case-insensitive comparison
                    (c | 0x20) === this.currentSequence[this.sequenceIndex];
            if (!isMatch) {
                this.isSpecial = false;
            }
            else if (!isEnd) {
                this.sequenceIndex++;
                return;
            }
            this.sequenceIndex = 0;
            this.state = State.InTagName;
            this.stateInTagName(c);
        };
        /** Look for an end tag. For <title> tags, also decode entities. */
        Tokenizer.prototype.stateInSpecialTag = function (c) {
            if (this.sequenceIndex === this.currentSequence.length) {
                if (c === CharCodes.Gt || isWhitespace(c)) {
                    var endOfText = this.index - this.currentSequence.length;
                    if (this.sectionStart < endOfText) {
                        // Spoof the index so that reported locations match up.
                        var actualIndex = this.index;
                        this.index = endOfText;
                        this.cbs.ontext(this.sectionStart, endOfText);
                        this.index = actualIndex;
                    }
                    this.isSpecial = false;
                    this.sectionStart = endOfText + 2; // Skip over the `</`
                    this.stateInClosingTagName(c);
                    return; // We are done; skip the rest of the function.
                }
                this.sequenceIndex = 0;
            }
            if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
                this.sequenceIndex += 1;
            }
            else if (this.sequenceIndex === 0) {
                if (this.currentSequence === Sequences.TitleEnd) {
                    // We have to parse entities in <title> tags.
                    if (this.decodeEntities && c === CharCodes.Amp) {
                        this.state = State.BeforeEntity;
                    }
                }
                else if (this.fastForwardTo(CharCodes.Lt)) {
                    // Outside of <title> tags, we can fast-forward.
                    this.sequenceIndex = 1;
                }
            }
            else {
                // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
                this.sequenceIndex = Number(c === CharCodes.Lt);
            }
        };
        Tokenizer.prototype.stateCDATASequence = function (c) {
            if (c === Sequences.Cdata[this.sequenceIndex]) {
                if (++this.sequenceIndex === Sequences.Cdata.length) {
                    this.state = State.InCommentLike;
                    this.currentSequence = Sequences.CdataEnd;
                    this.sequenceIndex = 0;
                    this.sectionStart = this.index + 1;
                }
            }
            else {
                this.sequenceIndex = 0;
                this.state = State.InDeclaration;
                this.stateInDeclaration(c); // Reconsume the character
            }
        };
        /**
         * When we wait for one specific character, we can speed things up
         * by skipping through the buffer until we find it.
         *
         * @returns Whether the character was found.
         */
        Tokenizer.prototype.fastForwardTo = function (c) {
            while (++this.index < this.buffer.length + this.offset) {
                if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                    return true;
                }
            }
            /*
             * We increment the index at the end of the `parse` loop,
             * so set it to `buffer.length - 1` here.
             *
             * TODO: Refactor `parse` to increment index before calling states.
             */
            this.index = this.buffer.length + this.offset - 1;
            return false;
        };
        /**
         * Comments and CDATA end with `-->` and `]]>`.
         *
         * Their common qualities are:
         * - Their end sequences have a distinct character they start with.
         * - That character is then repeated, so we have to check multiple repeats.
         * - All characters but the start character of the sequence can be skipped.
         */
        Tokenizer.prototype.stateInCommentLike = function (c) {
            if (c === this.currentSequence[this.sequenceIndex]) {
                if (++this.sequenceIndex === this.currentSequence.length) {
                    if (this.currentSequence === Sequences.CdataEnd) {
                        this.cbs.oncdata(this.sectionStart, this.index, 2);
                    }
                    else {
                        this.cbs.oncomment(this.sectionStart, this.index, 2);
                    }
                    this.sequenceIndex = 0;
                    this.sectionStart = this.index + 1;
                    this.state = State.Text;
                }
            }
            else if (this.sequenceIndex === 0) {
                // Fast-forward to the first character of the sequence
                if (this.fastForwardTo(this.currentSequence[0])) {
                    this.sequenceIndex = 1;
                }
            }
            else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
                // Allow long sequences, eg. --->, ]]]>
                this.sequenceIndex = 0;
            }
        };
        /**
         * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
         *
         * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
         * We allow anything that wouldn't end the tag.
         */
        Tokenizer.prototype.isTagStartChar = function (c) {
            return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
        };
        Tokenizer.prototype.startSpecial = function (sequence, offset) {
            this.isSpecial = true;
            this.currentSequence = sequence;
            this.sequenceIndex = offset;
            this.state = State.SpecialStartSequence;
        };
        Tokenizer.prototype.stateBeforeTagName = function (c) {
            if (c === CharCodes.ExclamationMark) {
                this.state = State.BeforeDeclaration;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.Questionmark) {
                this.state = State.InProcessingInstruction;
                this.sectionStart = this.index + 1;
            }
            else if (this.isTagStartChar(c)) {
                var lower = c | 0x20;
                this.sectionStart = this.index;
                if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                    this.startSpecial(Sequences.TitleEnd, 3);
                }
                else {
                    this.state =
                        !this.xmlMode && lower === Sequences.ScriptEnd[2]
                            ? State.BeforeSpecialS
                            : State.InTagName;
                }
            }
            else if (c === CharCodes.Slash) {
                this.state = State.BeforeClosingTagName;
            }
            else {
                this.state = State.Text;
                this.stateText(c);
            }
        };
        Tokenizer.prototype.stateInTagName = function (c) {
            if (isEndOfTagSection(c)) {
                this.cbs.onopentagname(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
        };
        Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
            if (isWhitespace(c)) ;
            else if (c === CharCodes.Gt) {
                this.state = State.Text;
            }
            else {
                this.state = this.isTagStartChar(c)
                    ? State.InClosingTagName
                    : State.InSpecialComment;
                this.sectionStart = this.index;
            }
        };
        Tokenizer.prototype.stateInClosingTagName = function (c) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                this.cbs.onclosetag(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.AfterClosingTagName;
                this.stateAfterClosingTagName(c);
            }
        };
        Tokenizer.prototype.stateAfterClosingTagName = function (c) {
            // Skip everything until ">"
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        };
        Tokenizer.prototype.stateBeforeAttributeName = function (c) {
            if (c === CharCodes.Gt) {
                this.cbs.onopentagend(this.index);
                if (this.isSpecial) {
                    this.state = State.InSpecialTag;
                    this.sequenceIndex = 0;
                }
                else {
                    this.state = State.Text;
                }
                this.baseState = this.state;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.Slash) {
                this.state = State.InSelfClosingTag;
            }
            else if (!isWhitespace(c)) {
                this.state = State.InAttributeName;
                this.sectionStart = this.index;
            }
        };
        Tokenizer.prototype.stateInSelfClosingTag = function (c) {
            if (c === CharCodes.Gt) {
                this.cbs.onselfclosingtag(this.index);
                this.state = State.Text;
                this.baseState = State.Text;
                this.sectionStart = this.index + 1;
                this.isSpecial = false; // Reset special state, in case of self-closing special tags
            }
            else if (!isWhitespace(c)) {
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
        };
        Tokenizer.prototype.stateInAttributeName = function (c) {
            if (c === CharCodes.Eq || isEndOfTagSection(c)) {
                this.cbs.onattribname(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.AfterAttributeName;
                this.stateAfterAttributeName(c);
            }
        };
        Tokenizer.prototype.stateAfterAttributeName = function (c) {
            if (c === CharCodes.Eq) {
                this.state = State.BeforeAttributeValue;
            }
            else if (c === CharCodes.Slash || c === CharCodes.Gt) {
                this.cbs.onattribend(QuoteType.NoValue, this.index);
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
            else if (!isWhitespace(c)) {
                this.cbs.onattribend(QuoteType.NoValue, this.index);
                this.state = State.InAttributeName;
                this.sectionStart = this.index;
            }
        };
        Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
            if (c === CharCodes.DoubleQuote) {
                this.state = State.InAttributeValueDq;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.SingleQuote) {
                this.state = State.InAttributeValueSq;
                this.sectionStart = this.index + 1;
            }
            else if (!isWhitespace(c)) {
                this.sectionStart = this.index;
                this.state = State.InAttributeValueNq;
                this.stateInAttributeValueNoQuotes(c); // Reconsume token
            }
        };
        Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
            if (c === quote ||
                (!this.decodeEntities && this.fastForwardTo(quote))) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.cbs.onattribend(quote === CharCodes.DoubleQuote
                    ? QuoteType.Double
                    : QuoteType.Single, this.index);
                this.state = State.BeforeAttributeName;
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.baseState = this.state;
                this.state = State.BeforeEntity;
            }
        };
        Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
            this.handleInAttributeValue(c, CharCodes.DoubleQuote);
        };
        Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
            this.handleInAttributeValue(c, CharCodes.SingleQuote);
        };
        Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
            if (isWhitespace(c) || c === CharCodes.Gt) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.cbs.onattribend(QuoteType.Unquoted, this.index);
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.baseState = this.state;
                this.state = State.BeforeEntity;
            }
        };
        Tokenizer.prototype.stateBeforeDeclaration = function (c) {
            if (c === CharCodes.OpeningSquareBracket) {
                this.state = State.CDATASequence;
                this.sequenceIndex = 0;
            }
            else {
                this.state =
                    c === CharCodes.Dash
                        ? State.BeforeComment
                        : State.InDeclaration;
            }
        };
        Tokenizer.prototype.stateInDeclaration = function (c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.ondeclaration(this.sectionStart, this.index);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        };
        Tokenizer.prototype.stateInProcessingInstruction = function (c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.onprocessinginstruction(this.sectionStart, this.index);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        };
        Tokenizer.prototype.stateBeforeComment = function (c) {
            if (c === CharCodes.Dash) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CommentEnd;
                // Allow short comments (eg. <!-->)
                this.sequenceIndex = 2;
                this.sectionStart = this.index + 1;
            }
            else {
                this.state = State.InDeclaration;
            }
        };
        Tokenizer.prototype.stateInSpecialComment = function (c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.oncomment(this.sectionStart, this.index, 0);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        };
        Tokenizer.prototype.stateBeforeSpecialS = function (c) {
            var lower = c | 0x20;
            if (lower === Sequences.ScriptEnd[3]) {
                this.startSpecial(Sequences.ScriptEnd, 4);
            }
            else if (lower === Sequences.StyleEnd[3]) {
                this.startSpecial(Sequences.StyleEnd, 4);
            }
            else {
                this.state = State.InTagName;
                this.stateInTagName(c); // Consume the token again
            }
        };
        Tokenizer.prototype.stateBeforeEntity = function (c) {
            // Start excess with 1 to include the '&'
            this.entityExcess = 1;
            this.entityResult = 0;
            if (c === CharCodes.Num) {
                this.state = State.BeforeNumericEntity;
            }
            else if (c === CharCodes.Amp) ;
            else {
                this.trieIndex = 0;
                this.trieCurrent = this.entityTrie[0];
                this.state = State.InNamedEntity;
                this.stateInNamedEntity(c);
            }
        };
        Tokenizer.prototype.stateInNamedEntity = function (c) {
            this.entityExcess += 1;
            this.trieIndex = (0, decode.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
            if (this.trieIndex < 0) {
                this.emitNamedEntity();
                this.index--;
                return;
            }
            this.trieCurrent = this.entityTrie[this.trieIndex];
            var masked = this.trieCurrent & decode.BinTrieFlags.VALUE_LENGTH;
            // If the branch is a value, store it and continue
            if (masked) {
                // The mask is the number of bytes of the value, including the current byte.
                var valueLength = (masked >> 14) - 1;
                // If we have a legacy entity while parsing strictly, just skip the number of bytes
                if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                    this.trieIndex += valueLength;
                }
                else {
                    // Add 1 as we have already incremented the excess
                    var entityStart = this.index - this.entityExcess + 1;
                    if (entityStart > this.sectionStart) {
                        this.emitPartial(this.sectionStart, entityStart);
                    }
                    // If this is a surrogate pair, consume the next two bytes
                    this.entityResult = this.trieIndex;
                    this.trieIndex += valueLength;
                    this.entityExcess = 0;
                    this.sectionStart = this.index + 1;
                    if (valueLength === 0) {
                        this.emitNamedEntity();
                    }
                }
            }
        };
        Tokenizer.prototype.emitNamedEntity = function () {
            this.state = this.baseState;
            if (this.entityResult === 0) {
                return;
            }
            var valueLength = (this.entityTrie[this.entityResult] & decode.BinTrieFlags.VALUE_LENGTH) >>
                14;
            switch (valueLength) {
                case 1:
                    this.emitCodePoint(this.entityTrie[this.entityResult] &
                        ~decode.BinTrieFlags.VALUE_LENGTH);
                    break;
                case 2:
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    break;
                case 3: {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
                }
            }
        };
        Tokenizer.prototype.stateBeforeNumericEntity = function (c) {
            if ((c | 0x20) === CharCodes.LowerX) {
                this.entityExcess++;
                this.state = State.InHexEntity;
            }
            else {
                this.state = State.InNumericEntity;
                this.stateInNumericEntity(c);
            }
        };
        Tokenizer.prototype.emitNumericEntity = function (strict) {
            var entityStart = this.index - this.entityExcess - 1;
            var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
            if (numberStart !== this.index) {
                // Emit leading data if any
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                this.sectionStart = this.index + Number(strict);
                this.emitCodePoint((0, decode.replaceCodePoint)(this.entityResult));
            }
            this.state = this.baseState;
        };
        Tokenizer.prototype.stateInNumericEntity = function (c) {
            if (c === CharCodes.Semi) {
                this.emitNumericEntity(true);
            }
            else if (isNumber(c)) {
                this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
                this.entityExcess++;
            }
            else {
                if (this.allowLegacyEntity()) {
                    this.emitNumericEntity(false);
                }
                else {
                    this.state = this.baseState;
                }
                this.index--;
            }
        };
        Tokenizer.prototype.stateInHexEntity = function (c) {
            if (c === CharCodes.Semi) {
                this.emitNumericEntity(true);
            }
            else if (isNumber(c)) {
                this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
                this.entityExcess++;
            }
            else if (isHexDigit(c)) {
                this.entityResult =
                    this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
                this.entityExcess++;
            }
            else {
                if (this.allowLegacyEntity()) {
                    this.emitNumericEntity(false);
                }
                else {
                    this.state = this.baseState;
                }
                this.index--;
            }
        };
        Tokenizer.prototype.allowLegacyEntity = function () {
            return (!this.xmlMode &&
                (this.baseState === State.Text ||
                    this.baseState === State.InSpecialTag));
        };
        /**
         * Remove data that has already been consumed from the buffer.
         */
        Tokenizer.prototype.cleanup = function () {
            // If we are inside of text or attributes, emit what we already have.
            if (this.running && this.sectionStart !== this.index) {
                if (this.state === State.Text ||
                    (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                    this.cbs.ontext(this.sectionStart, this.index);
                    this.sectionStart = this.index;
                }
                else if (this.state === State.InAttributeValueDq ||
                    this.state === State.InAttributeValueSq ||
                    this.state === State.InAttributeValueNq) {
                    this.cbs.onattribdata(this.sectionStart, this.index);
                    this.sectionStart = this.index;
                }
            }
        };
        Tokenizer.prototype.shouldContinue = function () {
            return this.index < this.buffer.length + this.offset && this.running;
        };
        /**
         * Iterates through the buffer, calling the function corresponding to the current state.
         *
         * States that are more likely to be hit are higher up, as a performance improvement.
         */
        Tokenizer.prototype.parse = function () {
            while (this.shouldContinue()) {
                var c = this.buffer.charCodeAt(this.index - this.offset);
                if (this.state === State.Text) {
                    this.stateText(c);
                }
                else if (this.state === State.SpecialStartSequence) {
                    this.stateSpecialStartSequence(c);
                }
                else if (this.state === State.InSpecialTag) {
                    this.stateInSpecialTag(c);
                }
                else if (this.state === State.CDATASequence) {
                    this.stateCDATASequence(c);
                }
                else if (this.state === State.InAttributeValueDq) {
                    this.stateInAttributeValueDoubleQuotes(c);
                }
                else if (this.state === State.InAttributeName) {
                    this.stateInAttributeName(c);
                }
                else if (this.state === State.InCommentLike) {
                    this.stateInCommentLike(c);
                }
                else if (this.state === State.InSpecialComment) {
                    this.stateInSpecialComment(c);
                }
                else if (this.state === State.BeforeAttributeName) {
                    this.stateBeforeAttributeName(c);
                }
                else if (this.state === State.InTagName) {
                    this.stateInTagName(c);
                }
                else if (this.state === State.InClosingTagName) {
                    this.stateInClosingTagName(c);
                }
                else if (this.state === State.BeforeTagName) {
                    this.stateBeforeTagName(c);
                }
                else if (this.state === State.AfterAttributeName) {
                    this.stateAfterAttributeName(c);
                }
                else if (this.state === State.InAttributeValueSq) {
                    this.stateInAttributeValueSingleQuotes(c);
                }
                else if (this.state === State.BeforeAttributeValue) {
                    this.stateBeforeAttributeValue(c);
                }
                else if (this.state === State.BeforeClosingTagName) {
                    this.stateBeforeClosingTagName(c);
                }
                else if (this.state === State.AfterClosingTagName) {
                    this.stateAfterClosingTagName(c);
                }
                else if (this.state === State.BeforeSpecialS) {
                    this.stateBeforeSpecialS(c);
                }
                else if (this.state === State.InAttributeValueNq) {
                    this.stateInAttributeValueNoQuotes(c);
                }
                else if (this.state === State.InSelfClosingTag) {
                    this.stateInSelfClosingTag(c);
                }
                else if (this.state === State.InDeclaration) {
                    this.stateInDeclaration(c);
                }
                else if (this.state === State.BeforeDeclaration) {
                    this.stateBeforeDeclaration(c);
                }
                else if (this.state === State.BeforeComment) {
                    this.stateBeforeComment(c);
                }
                else if (this.state === State.InProcessingInstruction) {
                    this.stateInProcessingInstruction(c);
                }
                else if (this.state === State.InNamedEntity) {
                    this.stateInNamedEntity(c);
                }
                else if (this.state === State.BeforeEntity) {
                    this.stateBeforeEntity(c);
                }
                else if (this.state === State.InHexEntity) {
                    this.stateInHexEntity(c);
                }
                else if (this.state === State.InNumericEntity) {
                    this.stateInNumericEntity(c);
                }
                else {
                    // `this._state === State.BeforeNumericEntity`
                    this.stateBeforeNumericEntity(c);
                }
                this.index++;
            }
            this.cleanup();
        };
        Tokenizer.prototype.finish = function () {
            if (this.state === State.InNamedEntity) {
                this.emitNamedEntity();
            }
            // If there is remaining data, emit it in a reasonable way
            if (this.sectionStart < this.index) {
                this.handleTrailingData();
            }
            this.cbs.onend();
        };
        /** Handle any trailing data. */
        Tokenizer.prototype.handleTrailingData = function () {
            var endIndex = this.buffer.length + this.offset;
            if (this.state === State.InCommentLike) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, endIndex, 0);
                }
                else {
                    this.cbs.oncomment(this.sectionStart, endIndex, 0);
                }
            }
            else if (this.state === State.InNumericEntity &&
                this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
                // All trailing data will have been consumed
            }
            else if (this.state === State.InHexEntity &&
                this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
                // All trailing data will have been consumed
            }
            else if (this.state === State.InTagName ||
                this.state === State.BeforeAttributeName ||
                this.state === State.BeforeAttributeValue ||
                this.state === State.AfterAttributeName ||
                this.state === State.InAttributeName ||
                this.state === State.InAttributeValueSq ||
                this.state === State.InAttributeValueDq ||
                this.state === State.InAttributeValueNq ||
                this.state === State.InClosingTagName) ;
            else {
                this.cbs.ontext(this.sectionStart, endIndex);
            }
        };
        Tokenizer.prototype.emitPartial = function (start, endIndex) {
            if (this.baseState !== State.Text &&
                this.baseState !== State.InSpecialTag) {
                this.cbs.onattribdata(start, endIndex);
            }
            else {
                this.cbs.ontext(start, endIndex);
            }
        };
        Tokenizer.prototype.emitCodePoint = function (cp) {
            if (this.baseState !== State.Text &&
                this.baseState !== State.InSpecialTag) {
                this.cbs.onattribentity(cp);
            }
            else {
                this.cbs.ontextentity(cp);
            }
        };
        return Tokenizer;
    }());
    exports.default = Tokenizer;

    });

    var Parser_1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_js_1 = __importStar(Tokenizer_1);

    var formTags = new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea",
    ]);
    var pTag = new Set(["p"]);
    var tableSectionTags = new Set(["thead", "tbody"]);
    var ddtTags = new Set(["dd", "dt"]);
    var rtpTags = new Set(["rt", "rp"]);
    var openImpliesClose = new Map([
        ["tr", new Set(["tr", "th", "td"])],
        ["th", new Set(["th"])],
        ["td", new Set(["thead", "th", "td"])],
        ["body", new Set(["head", "link", "script"])],
        ["li", new Set(["li"])],
        ["p", pTag],
        ["h1", pTag],
        ["h2", pTag],
        ["h3", pTag],
        ["h4", pTag],
        ["h5", pTag],
        ["h6", pTag],
        ["select", formTags],
        ["input", formTags],
        ["output", formTags],
        ["button", formTags],
        ["datalist", formTags],
        ["textarea", formTags],
        ["option", new Set(["option"])],
        ["optgroup", new Set(["optgroup", "option"])],
        ["dd", ddtTags],
        ["dt", ddtTags],
        ["address", pTag],
        ["article", pTag],
        ["aside", pTag],
        ["blockquote", pTag],
        ["details", pTag],
        ["div", pTag],
        ["dl", pTag],
        ["fieldset", pTag],
        ["figcaption", pTag],
        ["figure", pTag],
        ["footer", pTag],
        ["form", pTag],
        ["header", pTag],
        ["hr", pTag],
        ["main", pTag],
        ["nav", pTag],
        ["ol", pTag],
        ["pre", pTag],
        ["section", pTag],
        ["table", pTag],
        ["ul", pTag],
        ["rt", rtpTags],
        ["rp", rtpTags],
        ["tbody", tableSectionTags],
        ["tfoot", tableSectionTags],
    ]);
    var voidElements = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    var foreignContextElements = new Set(["math", "svg"]);
    var htmlIntegrationElements = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignobject",
        "desc",
        "title",
    ]);
    var reNameEnd = /\s|\//;
    var Parser = /** @class */ (function () {
        function Parser(cbs, options) {
            if (options === void 0) { options = {}; }
            var _a, _b, _c, _d, _e;
            this.options = options;
            /** The start index of the last event. */
            this.startIndex = 0;
            /** The end index of the last event. */
            this.endIndex = 0;
            /**
             * Store the start index of the current open tag,
             * so we can update the start index for attributes.
             */
            this.openTagStart = 0;
            this.tagname = "";
            this.attribname = "";
            this.attribvalue = "";
            this.attribs = null;
            this.stack = [];
            this.foreignContext = [];
            this.buffers = [];
            this.bufferOffset = 0;
            /** The index of the last written buffer. Used when resuming after a `pause()`. */
            this.writeIndex = 0;
            /** Indicates whether the parser has finished running / `.end` has been called. */
            this.ended = false;
            this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
            this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
            this.lowerCaseAttributeNames =
                (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
            this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
            (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        // Tokenizer event handlers
        /** @internal */
        Parser.prototype.ontext = function (start, endIndex) {
            var _a, _b;
            var data = this.getSlice(start, endIndex);
            this.endIndex = endIndex - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
            this.startIndex = endIndex;
        };
        /** @internal */
        Parser.prototype.ontextentity = function (cp) {
            var _a, _b;
            /*
             * Entities can be emitted on the character, or directly after.
             * We use the section start here to get accurate indices.
             */
            var idx = this.tokenizer.getSectionStart();
            this.endIndex = idx - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode.fromCodePoint)(cp));
            this.startIndex = idx;
        };
        Parser.prototype.isVoidElement = function (name) {
            return !this.options.xmlMode && voidElements.has(name);
        };
        /** @internal */
        Parser.prototype.onopentagname = function (start, endIndex) {
            this.endIndex = endIndex;
            var name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            this.emitOpenTag(name);
        };
        Parser.prototype.emitOpenTag = function (name) {
            var _a, _b, _c, _d;
            this.openTagStart = this.startIndex;
            this.tagname = name;
            var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
            if (impliesClose) {
                while (this.stack.length > 0 &&
                    impliesClose.has(this.stack[this.stack.length - 1])) {
                    var el = this.stack.pop();
                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);
                }
            }
            if (!this.isVoidElement(name)) {
                this.stack.push(name);
                if (foreignContextElements.has(name)) {
                    this.foreignContext.push(true);
                }
                else if (htmlIntegrationElements.has(name)) {
                    this.foreignContext.push(false);
                }
            }
            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
            if (this.cbs.onopentag)
                this.attribs = {};
        };
        Parser.prototype.endOpenTag = function (isImplied) {
            var _a, _b;
            this.startIndex = this.openTagStart;
            if (this.attribs) {
                (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
                this.attribs = null;
            }
            if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
                this.cbs.onclosetag(this.tagname, true);
            }
            this.tagname = "";
        };
        /** @internal */
        Parser.prototype.onopentagend = function (endIndex) {
            this.endIndex = endIndex;
            this.endOpenTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        };
        /** @internal */
        Parser.prototype.onclosetag = function (start, endIndex) {
            var _a, _b, _c, _d, _e, _f;
            this.endIndex = endIndex;
            var name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            if (foreignContextElements.has(name) ||
                htmlIntegrationElements.has(name)) {
                this.foreignContext.pop();
            }
            if (!this.isVoidElement(name)) {
                var pos = this.stack.lastIndexOf(name);
                if (pos !== -1) {
                    if (this.cbs.onclosetag) {
                        var count = this.stack.length - pos;
                        while (count--) {
                            // We know the stack has sufficient elements.
                            this.cbs.onclosetag(this.stack.pop(), count !== 0);
                        }
                    }
                    else
                        this.stack.length = pos;
                }
                else if (!this.options.xmlMode && name === "p") {
                    // Implicit open before close
                    this.emitOpenTag("p");
                    this.closeCurrentTag(true);
                }
            }
            else if (!this.options.xmlMode && name === "br") {
                // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
                (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
                (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
                (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        };
        /** @internal */
        Parser.prototype.onselfclosingtag = function (endIndex) {
            this.endIndex = endIndex;
            if (this.options.xmlMode ||
                this.options.recognizeSelfClosing ||
                this.foreignContext[this.foreignContext.length - 1]) {
                this.closeCurrentTag(false);
                // Set `startIndex` for next node
                this.startIndex = endIndex + 1;
            }
            else {
                // Ignore the fact that the tag is self-closing.
                this.onopentagend(endIndex);
            }
        };
        Parser.prototype.closeCurrentTag = function (isOpenImplied) {
            var _a, _b;
            var name = this.tagname;
            this.endOpenTag(isOpenImplied);
            // Self-closing tags will be on the top of the stack
            if (this.stack[this.stack.length - 1] === name) {
                // If the opening tag isn't implied, the closing tag has to be implied.
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
                this.stack.pop();
            }
        };
        /** @internal */
        Parser.prototype.onattribname = function (start, endIndex) {
            this.startIndex = start;
            var name = this.getSlice(start, endIndex);
            this.attribname = this.lowerCaseAttributeNames
                ? name.toLowerCase()
                : name;
        };
        /** @internal */
        Parser.prototype.onattribdata = function (start, endIndex) {
            this.attribvalue += this.getSlice(start, endIndex);
        };
        /** @internal */
        Parser.prototype.onattribentity = function (cp) {
            this.attribvalue += (0, decode.fromCodePoint)(cp);
        };
        /** @internal */
        Parser.prototype.onattribend = function (quote, endIndex) {
            var _a, _b;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double
                ? '"'
                : quote === Tokenizer_js_1.QuoteType.Single
                    ? "'"
                    : quote === Tokenizer_js_1.QuoteType.NoValue
                        ? undefined
                        : null);
            if (this.attribs &&
                !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
                this.attribs[this.attribname] = this.attribvalue;
            }
            this.attribvalue = "";
        };
        Parser.prototype.getInstructionName = function (value) {
            var idx = value.search(reNameEnd);
            var name = idx < 0 ? value : value.substr(0, idx);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            return name;
        };
        /** @internal */
        Parser.prototype.ondeclaration = function (start, endIndex) {
            this.endIndex = endIndex;
            var value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
                var name = this.getInstructionName(value);
                this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        };
        /** @internal */
        Parser.prototype.onprocessinginstruction = function (start, endIndex) {
            this.endIndex = endIndex;
            var value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
                var name = this.getInstructionName(value);
                this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        };
        /** @internal */
        Parser.prototype.oncomment = function (start, endIndex, offset) {
            var _a, _b, _c, _d;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
            (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        };
        /** @internal */
        Parser.prototype.oncdata = function (start, endIndex, offset) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            this.endIndex = endIndex;
            var value = this.getSlice(start, endIndex - offset);
            if (this.options.xmlMode || this.options.recognizeCDATA) {
                (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
                (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
                (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
            }
            else {
                (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
                (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        };
        /** @internal */
        Parser.prototype.onend = function () {
            var _a, _b;
            if (this.cbs.onclosetag) {
                // Set the end index for all remaining tags
                this.endIndex = this.startIndex;
                for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
                    ;
            }
            (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        /**
         * Resets the parser to a blank state, ready to parse a new HTML document
         */
        Parser.prototype.reset = function () {
            var _a, _b, _c, _d;
            (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
            this.tokenizer.reset();
            this.tagname = "";
            this.attribname = "";
            this.attribs = null;
            this.stack.length = 0;
            this.startIndex = 0;
            this.endIndex = 0;
            (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
            this.buffers.length = 0;
            this.bufferOffset = 0;
            this.writeIndex = 0;
            this.ended = false;
        };
        /**
         * Resets the parser, then parses a complete document and
         * pushes it to the handler.
         *
         * @param data Document to parse.
         */
        Parser.prototype.parseComplete = function (data) {
            this.reset();
            this.end(data);
        };
        Parser.prototype.getSlice = function (start, end) {
            while (start - this.bufferOffset >= this.buffers[0].length) {
                this.shiftBuffer();
            }
            var str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
            while (end - this.bufferOffset > this.buffers[0].length) {
                this.shiftBuffer();
                str += this.buffers[0].slice(0, end - this.bufferOffset);
            }
            return str;
        };
        Parser.prototype.shiftBuffer = function () {
            this.bufferOffset += this.buffers[0].length;
            this.writeIndex--;
            this.buffers.shift();
        };
        /**
         * Parses a chunk of data and calls the corresponding callbacks.
         *
         * @param chunk Chunk to parse.
         */
        Parser.prototype.write = function (chunk) {
            var _a, _b;
            if (this.ended) {
                (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
                return;
            }
            this.buffers.push(chunk);
            if (this.tokenizer.running) {
                this.tokenizer.write(chunk);
                this.writeIndex++;
            }
        };
        /**
         * Parses the end of the buffer and clears the stack, calls onend.
         *
         * @param chunk Optional final chunk to parse.
         */
        Parser.prototype.end = function (chunk) {
            var _a, _b;
            if (this.ended) {
                (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(".end() after done!"));
                return;
            }
            if (chunk)
                this.write(chunk);
            this.ended = true;
            this.tokenizer.end();
        };
        /**
         * Pauses parsing. The parser won't emit events until `resume` is called.
         */
        Parser.prototype.pause = function () {
            this.tokenizer.pause();
        };
        /**
         * Resumes parsing after `pause` was called.
         */
        Parser.prototype.resume = function () {
            this.tokenizer.resume();
            while (this.tokenizer.running &&
                this.writeIndex < this.buffers.length) {
                this.tokenizer.write(this.buffers[this.writeIndex++]);
            }
            if (this.ended)
                this.tokenizer.end();
        };
        /**
         * Alias of `write`, for backwards compatibility.
         *
         * @param chunk Chunk to parse.
         * @deprecated
         */
        Parser.prototype.parseChunk = function (chunk) {
            this.write(chunk);
        };
        /**
         * Alias of `end`, for backwards compatibility.
         *
         * @param chunk Optional final chunk to parse.
         * @deprecated
         */
        Parser.prototype.done = function (chunk) {
            this.end(chunk);
        };
        return Parser;
    }());
    exports.Parser = Parser;

    });

    var lib$5 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    /** Types of elements found in htmlparser2's DOM */
    var ElementType;
    (function (ElementType) {
        /** Type for the root element of a document */
        ElementType["Root"] = "root";
        /** Type for Text */
        ElementType["Text"] = "text";
        /** Type for <? ... ?> */
        ElementType["Directive"] = "directive";
        /** Type for <!-- ... --> */
        ElementType["Comment"] = "comment";
        /** Type for <script> tags */
        ElementType["Script"] = "script";
        /** Type for <style> tags */
        ElementType["Style"] = "style";
        /** Type for Any tag */
        ElementType["Tag"] = "tag";
        /** Type for <![CDATA[ ... ]]> */
        ElementType["CDATA"] = "cdata";
        /** Type for <!doctype ...> */
        ElementType["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    /**
     * Tests whether an element is a tag or not.
     *
     * @param elem Element to test
     */
    function isTag(elem) {
        return (elem.type === ElementType.Tag ||
            elem.type === ElementType.Script ||
            elem.type === ElementType.Style);
    }
    exports.isTag = isTag;
    // Exports for backwards compatibility
    /** Type for the root element of a document */
    exports.Root = ElementType.Root;
    /** Type for Text */
    exports.Text = ElementType.Text;
    /** Type for <? ... ?> */
    exports.Directive = ElementType.Directive;
    /** Type for <!-- ... --> */
    exports.Comment = ElementType.Comment;
    /** Type for <script> tags */
    exports.Script = ElementType.Script;
    /** Type for <style> tags */
    exports.Style = ElementType.Style;
    /** Type for Any tag */
    exports.Tag = ElementType.Tag;
    /** Type for <![CDATA[ ... ]]> */
    exports.CDATA = ElementType.CDATA;
    /** Type for <!doctype ...> */
    exports.Doctype = ElementType.Doctype;
    });

    var node = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;

    /**
     * This object will be used as the prototype for Nodes when creating a
     * DOM-Level-1-compliant structure.
     */
    var Node = /** @class */ (function () {
        function Node() {
            /** Parent of the node */
            this.parent = null;
            /** Previous sibling */
            this.prev = null;
            /** Next sibling */
            this.next = null;
            /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
            this.startIndex = null;
            /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
            this.endIndex = null;
        }
        Object.defineProperty(Node.prototype, "parentNode", {
            // Read-write aliases for properties
            /**
             * Same as {@link parent}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.parent;
            },
            set: function (parent) {
                this.parent = parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "previousSibling", {
            /**
             * Same as {@link prev}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.prev;
            },
            set: function (prev) {
                this.prev = prev;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "nextSibling", {
            /**
             * Same as {@link next}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.next;
            },
            set: function (next) {
                this.next = next;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Clone this node, and optionally its children.
         *
         * @param recursive Clone child nodes as well.
         * @returns A clone of the node.
         */
        Node.prototype.cloneNode = function (recursive) {
            if (recursive === void 0) { recursive = false; }
            return cloneNode(this, recursive);
        };
        return Node;
    }());
    exports.Node = Node;
    /**
     * A node that contains some data.
     */
    var DataNode = /** @class */ (function (_super) {
        __extends(DataNode, _super);
        /**
         * @param data The content of the data node
         */
        function DataNode(data) {
            var _this = _super.call(this) || this;
            _this.data = data;
            return _this;
        }
        Object.defineProperty(DataNode.prototype, "nodeValue", {
            /**
             * Same as {@link data}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.data;
            },
            set: function (data) {
                this.data = data;
            },
            enumerable: false,
            configurable: true
        });
        return DataNode;
    }(Node));
    exports.DataNode = DataNode;
    /**
     * Text within the document.
     */
    var Text = /** @class */ (function (_super) {
        __extends(Text, _super);
        function Text() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = lib$5.ElementType.Text;
            return _this;
        }
        Object.defineProperty(Text.prototype, "nodeType", {
            get: function () {
                return 3;
            },
            enumerable: false,
            configurable: true
        });
        return Text;
    }(DataNode));
    exports.Text = Text;
    /**
     * Comments within the document.
     */
    var Comment = /** @class */ (function (_super) {
        __extends(Comment, _super);
        function Comment() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = lib$5.ElementType.Comment;
            return _this;
        }
        Object.defineProperty(Comment.prototype, "nodeType", {
            get: function () {
                return 8;
            },
            enumerable: false,
            configurable: true
        });
        return Comment;
    }(DataNode));
    exports.Comment = Comment;
    /**
     * Processing instructions, including doc types.
     */
    var ProcessingInstruction = /** @class */ (function (_super) {
        __extends(ProcessingInstruction, _super);
        function ProcessingInstruction(name, data) {
            var _this = _super.call(this, data) || this;
            _this.name = name;
            _this.type = lib$5.ElementType.Directive;
            return _this;
        }
        Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        return ProcessingInstruction;
    }(DataNode));
    exports.ProcessingInstruction = ProcessingInstruction;
    /**
     * A `Node` that can have children.
     */
    var NodeWithChildren = /** @class */ (function (_super) {
        __extends(NodeWithChildren, _super);
        /**
         * @param children Children of the node. Only certain node types can have children.
         */
        function NodeWithChildren(children) {
            var _this = _super.call(this) || this;
            _this.children = children;
            return _this;
        }
        Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
            // Aliases
            /** First child of the node. */
            get: function () {
                var _a;
                return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
            /** Last child of the node. */
            get: function () {
                return this.children.length > 0
                    ? this.children[this.children.length - 1]
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
            /**
             * Same as {@link children}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.children;
            },
            set: function (children) {
                this.children = children;
            },
            enumerable: false,
            configurable: true
        });
        return NodeWithChildren;
    }(Node));
    exports.NodeWithChildren = NodeWithChildren;
    var CDATA = /** @class */ (function (_super) {
        __extends(CDATA, _super);
        function CDATA() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = lib$5.ElementType.CDATA;
            return _this;
        }
        Object.defineProperty(CDATA.prototype, "nodeType", {
            get: function () {
                return 4;
            },
            enumerable: false,
            configurable: true
        });
        return CDATA;
    }(NodeWithChildren));
    exports.CDATA = CDATA;
    /**
     * The root node of the document.
     */
    var Document = /** @class */ (function (_super) {
        __extends(Document, _super);
        function Document() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = lib$5.ElementType.Root;
            return _this;
        }
        Object.defineProperty(Document.prototype, "nodeType", {
            get: function () {
                return 9;
            },
            enumerable: false,
            configurable: true
        });
        return Document;
    }(NodeWithChildren));
    exports.Document = Document;
    /**
     * An element within the DOM.
     */
    var Element = /** @class */ (function (_super) {
        __extends(Element, _super);
        /**
         * @param name Name of the tag, eg. `div`, `span`.
         * @param attribs Object mapping attribute names to attribute values.
         * @param children Children of the node.
         */
        function Element(name, attribs, children, type) {
            if (children === void 0) { children = []; }
            if (type === void 0) { type = name === "script"
                ? lib$5.ElementType.Script
                : name === "style"
                    ? lib$5.ElementType.Style
                    : lib$5.ElementType.Tag; }
            var _this = _super.call(this, children) || this;
            _this.name = name;
            _this.attribs = attribs;
            _this.type = type;
            return _this;
        }
        Object.defineProperty(Element.prototype, "nodeType", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Element.prototype, "tagName", {
            // DOM Level 1 aliases
            /**
             * Same as {@link name}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.name;
            },
            set: function (name) {
                this.name = name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Element.prototype, "attributes", {
            get: function () {
                var _this = this;
                return Object.keys(this.attribs).map(function (name) {
                    var _a, _b;
                    return ({
                        name: name,
                        value: _this.attribs[name],
                        namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                        prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                    });
                });
            },
            enumerable: false,
            configurable: true
        });
        return Element;
    }(NodeWithChildren));
    exports.Element = Element;
    /**
     * @param node Node to check.
     * @returns `true` if the node is a `Element`, `false` otherwise.
     */
    function isTag(node) {
        return (0, lib$5.isTag)(node);
    }
    exports.isTag = isTag;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `CDATA`, `false` otherwise.
     */
    function isCDATA(node) {
        return node.type === lib$5.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Text`, `false` otherwise.
     */
    function isText(node) {
        return node.type === lib$5.ElementType.Text;
    }
    exports.isText = isText;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Comment`, `false` otherwise.
     */
    function isComment(node) {
        return node.type === lib$5.ElementType.Comment;
    }
    exports.isComment = isComment;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDirective(node) {
        return node.type === lib$5.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDocument(node) {
        return node.type === lib$5.ElementType.Root;
    }
    exports.isDocument = isDocument;
    /**
     * @param node Node to check.
     * @returns `true` if the node has children, `false` otherwise.
     */
    function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    /**
     * Clone a node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    function cloneNode(node, recursive) {
        if (recursive === void 0) { recursive = false; }
        var result;
        if (isText(node)) {
            result = new Text(node.data);
        }
        else if (isComment(node)) {
            result = new Comment(node.data);
        }
        else if (isTag(node)) {
            var children = recursive ? cloneChildren(node.children) : [];
            var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
            children.forEach(function (child) { return (child.parent = clone_1); });
            if (node.namespace != null) {
                clone_1.namespace = node.namespace;
            }
            if (node["x-attribsNamespace"]) {
                clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
            }
            if (node["x-attribsPrefix"]) {
                clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
            }
            result = clone_1;
        }
        else if (isCDATA(node)) {
            var children = recursive ? cloneChildren(node.children) : [];
            var clone_2 = new CDATA(children);
            children.forEach(function (child) { return (child.parent = clone_2); });
            result = clone_2;
        }
        else if (isDocument(node)) {
            var children = recursive ? cloneChildren(node.children) : [];
            var clone_3 = new Document(children);
            children.forEach(function (child) { return (child.parent = clone_3); });
            if (node["x-mode"]) {
                clone_3["x-mode"] = node["x-mode"];
            }
            result = clone_3;
        }
        else if (isDirective(node)) {
            var instruction = new ProcessingInstruction(node.name, node.data);
            if (node["x-name"] != null) {
                instruction["x-name"] = node["x-name"];
                instruction["x-publicId"] = node["x-publicId"];
                instruction["x-systemId"] = node["x-systemId"];
            }
            result = instruction;
        }
        else {
            throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
            result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
        var children = childs.map(function (child) { return cloneNode(child, true); });
        for (var i = 1; i < children.length; i++) {
            children[i].prev = children[i - 1];
            children[i - 1].next = children[i];
        }
        return children;
    }
    });

    var lib$4 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;


    __exportStar(node, exports);
    // Default options
    var defaultOpts = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false,
    };
    var DomHandler = /** @class */ (function () {
        /**
         * @param callback Called once parsing has completed.
         * @param options Settings for the handler.
         * @param elementCB Callback whenever a tag is closed.
         */
        function DomHandler(callback, options, elementCB) {
            /** The elements of the DOM */
            this.dom = [];
            /** The root element for the DOM */
            this.root = new node.Document(this.dom);
            /** Indicated whether parsing has been completed. */
            this.done = false;
            /** Stack of open tags. */
            this.tagStack = [this.root];
            /** A data node that is still being written to. */
            this.lastNode = null;
            /** Reference to the parser instance. Used for location information. */
            this.parser = null;
            // Make it possible to skip arguments, for backwards-compatibility
            if (typeof options === "function") {
                elementCB = options;
                options = defaultOpts;
            }
            if (typeof callback === "object") {
                options = callback;
                callback = undefined;
            }
            this.callback = callback !== null && callback !== void 0 ? callback : null;
            this.options = options !== null && options !== void 0 ? options : defaultOpts;
            this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler.prototype.onparserinit = function (parser) {
            this.parser = parser;
        };
        // Resets the handler back to starting state
        DomHandler.prototype.onreset = function () {
            this.dom = [];
            this.root = new node.Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
        };
        // Signals the handler that parsing is done
        DomHandler.prototype.onend = function () {
            if (this.done)
                return;
            this.done = true;
            this.parser = null;
            this.handleCallback(null);
        };
        DomHandler.prototype.onerror = function (error) {
            this.handleCallback(error);
        };
        DomHandler.prototype.onclosetag = function () {
            this.lastNode = null;
            var elem = this.tagStack.pop();
            if (this.options.withEndIndices) {
                elem.endIndex = this.parser.endIndex;
            }
            if (this.elementCB)
                this.elementCB(elem);
        };
        DomHandler.prototype.onopentag = function (name, attribs) {
            var type = this.options.xmlMode ? lib$5.ElementType.Tag : undefined;
            var element = new node.Element(name, attribs, undefined, type);
            this.addNode(element);
            this.tagStack.push(element);
        };
        DomHandler.prototype.ontext = function (data) {
            var lastNode = this.lastNode;
            if (lastNode && lastNode.type === lib$5.ElementType.Text) {
                lastNode.data += data;
                if (this.options.withEndIndices) {
                    lastNode.endIndex = this.parser.endIndex;
                }
            }
            else {
                var node$1 = new node.Text(data);
                this.addNode(node$1);
                this.lastNode = node$1;
            }
        };
        DomHandler.prototype.oncomment = function (data) {
            if (this.lastNode && this.lastNode.type === lib$5.ElementType.Comment) {
                this.lastNode.data += data;
                return;
            }
            var node$1 = new node.Comment(data);
            this.addNode(node$1);
            this.lastNode = node$1;
        };
        DomHandler.prototype.oncommentend = function () {
            this.lastNode = null;
        };
        DomHandler.prototype.oncdatastart = function () {
            var text = new node.Text("");
            var node$1 = new node.CDATA([text]);
            this.addNode(node$1);
            text.parent = node$1;
            this.lastNode = text;
        };
        DomHandler.prototype.oncdataend = function () {
            this.lastNode = null;
        };
        DomHandler.prototype.onprocessinginstruction = function (name, data) {
            var node$1 = new node.ProcessingInstruction(name, data);
            this.addNode(node$1);
        };
        DomHandler.prototype.handleCallback = function (error) {
            if (typeof this.callback === "function") {
                this.callback(error, this.dom);
            }
            else if (error) {
                throw error;
            }
        };
        DomHandler.prototype.addNode = function (node) {
            var parent = this.tagStack[this.tagStack.length - 1];
            var previousSibling = parent.children[parent.children.length - 1];
            if (this.options.withStartIndices) {
                node.startIndex = this.parser.startIndex;
            }
            if (this.options.withEndIndices) {
                node.endIndex = this.parser.endIndex;
            }
            parent.children.push(node);
            if (previousSibling) {
                node.prev = previousSibling;
                previousSibling.next = node;
            }
            node.parent = parent;
            this.lastNode = null;
        };
        return DomHandler;
    }());
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
    });

    // Generated using scripts/write-encode-map.ts

    function restoreDiff(arr) {
        for (var i = 1; i < arr.length; i++) {
            arr[i][0] += arr[i - 1][0] + 1;
        }
        return arr;
    }
    // prettier-ignore
    var _default = new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));


    var encodeHtml = /*#__PURE__*/Object.defineProperty({
    	default: _default
    }, '__esModule', {value: true});

    var _escape = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"],
    ]);
    // For compatibility with node < 4, we wrap `codePointAt`
    exports.getCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null
        ? function (str, index) { return str.codePointAt(index); }
        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            function (c, index) {
                return (c.charCodeAt(index) & 0xfc00) === 0xd800
                    ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                        c.charCodeAt(index + 1) -
                        0xdc00 +
                        0x10000
                    : c.charCodeAt(index);
            };
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using XML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */
    function encodeXML(str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = exports.xmlReplacer.exec(str)) !== null) {
            var i = match.index;
            var char = str.charCodeAt(i);
            var next = xmlCodeMap.get(char);
            if (next !== undefined) {
                ret += str.substring(lastIdx, i) + next;
                lastIdx = i + 1;
            }
            else {
                ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
                // Increase by 1 if we have a surrogate pair
                lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
            }
        }
        return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using numeric hexadecimal reference (eg. `&#xfc;`).
     *
     * Have a look at `escapeUTF8` if you want a more concise output at the expense
     * of reduced transportability.
     *
     * @param data String to escape.
     */
    exports.escape = encodeXML;
    function getEscaper(regex, map) {
        return function escape(data) {
            var match;
            var lastIdx = 0;
            var result = "";
            while ((match = regex.exec(data))) {
                if (lastIdx !== match.index) {
                    result += data.substring(lastIdx, match.index);
                }
                // We know that this chararcter will be in the map.
                result += map.get(match[0].charCodeAt(0));
                // Every match will be of length 1
                lastIdx = match.index + 1;
            }
            return result + data.substring(lastIdx);
        };
    }
    /**
     * Encodes all characters not valid in XML documents using XML entities.
     *
     * Note that the output will be character-set dependent.
     *
     * @param data String to escape.
     */
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    /**
     * Encodes all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     *
     * @param data String to escape.
     */
    exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"],
    ]));
    /**
     * Encodes all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     *
     * @param data String to escape.
     */
    exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"],
    ]));

    });

    var encode = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(encodeHtml);

    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    /**
     * Encodes all characters in the input using HTML entities. This includes
     * characters that are valid ASCII characters in HTML documents, such as `#`.
     *
     * To get a more compact output, consider using the `encodeNonAsciiHTML`
     * function, which will only encode characters that are not valid in HTML
     * documents, as well as non-ASCII characters.
     *
     * If a character has no equivalent entity, a numeric hexadecimal reference
     * (eg. `&#xfc;`) will be used.
     */
    function encodeHTML(data) {
        return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in HTML
     * documents using HTML entities. This function will not encode characters that
     * are valid in HTML documents, such as `#`.
     *
     * If a character has no equivalent entity, a numeric hexadecimal reference
     * (eg. `&#xfc;`) will be used.
     */
    function encodeNonAsciiHTML(data) {
        return encodeHTMLTrieRe(_escape.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = regExp.exec(str)) !== null) {
            var i = match.index;
            ret += str.substring(lastIdx, i);
            var char = str.charCodeAt(i);
            var next = encode_html_js_1.default.get(char);
            if (typeof next === "object") {
                // We are in a branch. Try to match the next char.
                if (i + 1 < str.length) {
                    var nextChar = str.charCodeAt(i + 1);
                    var value = typeof next.n === "number"
                        ? next.n === nextChar
                            ? next.o
                            : undefined
                        : next.n.get(nextChar);
                    if (value !== undefined) {
                        ret += value;
                        lastIdx = regExp.lastIndex += 1;
                        continue;
                    }
                }
                next = next.v;
            }
            // We might have a tree node without a value; skip and use a numeric entitiy.
            if (next !== undefined) {
                ret += next;
                lastIdx = i + 1;
            }
            else {
                var cp = (0, _escape.getCodePoint)(str, i);
                ret += "&#x".concat(cp.toString(16), ";");
                // Increase by 1 if we have a surrogate pair
                lastIdx = regExp.lastIndex += Number(cp !== char);
            }
        }
        return ret + str.substr(lastIdx);
    }

    });

    var lib$3 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.DecodingMode = exports.EntityLevel = void 0;



    /** The level of entities to support. */
    var EntityLevel;
    (function (EntityLevel) {
        /** Support only XML entities. */
        EntityLevel[EntityLevel["XML"] = 0] = "XML";
        /** Support HTML entities, which are a superset of XML entities. */
        EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
    })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
    /** Determines whether some entities are allowed to be written without a trailing `;`. */
    var DecodingMode;
    (function (DecodingMode) {
        /** Support legacy HTML entities. */
        DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
        /** Do not support legacy HTML entities. */
        DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EncodingMode;
    (function (EncodingMode) {
        /**
         * The output is UTF-8 encoded. Only characters that need escaping within
         * XML will be escaped.
         */
        EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
        /**
         * The output consists only of ASCII characters. Characters that need
         * escaping within HTML, and characters that aren't ASCII characters will
         * be escaped.
         */
        EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
        /**
         * Encode all characters that have an equivalent entity, as well as all
         * characters that are not ASCII characters.
         */
        EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
        /**
         * Encode all characters that have to be escaped in HTML attributes,
         * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
         */
        EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
        /**
         * Encode all characters that have to be escaped in HTML text,
         * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
         */
        EncodingMode[EncodingMode["Text"] = 4] = "Text";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    /**
     * Decodes a string with entities.
     *
     * @param data String to decode.
     * @param options Decoding options.
     */
    function decode$1(data, options) {
        if (options === void 0) { options = EntityLevel.XML; }
        var opts = typeof options === "number" ? { level: options } : options;
        if (opts.level === EntityLevel.HTML) {
            if (opts.mode === DecodingMode.Strict) {
                return (0, decode.decodeHTMLStrict)(data);
            }
            return (0, decode.decodeHTML)(data);
        }
        return (0, decode.decodeXML)(data);
    }
    exports.decode = decode$1;
    /**
     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
     *
     * @param data String to decode.
     * @param options Decoding options.
     * @deprecated Use `decode` with the `mode` set to `Strict`.
     */
    function decodeStrict(data, options) {
        if (options === void 0) { options = EntityLevel.XML; }
        var opts = typeof options === "number" ? { level: options } : options;
        if (opts.level === EntityLevel.HTML) {
            if (opts.mode === DecodingMode.Legacy) {
                return (0, decode.decodeHTML)(data);
            }
            return (0, decode.decodeHTMLStrict)(data);
        }
        return (0, decode.decodeXML)(data);
    }
    exports.decodeStrict = decodeStrict;
    /**
     * Encodes a string with entities.
     *
     * @param data String to encode.
     * @param options Encoding options.
     */
    function encode$1(data, options) {
        if (options === void 0) { options = EntityLevel.XML; }
        var opts = typeof options === "number" ? { level: options } : options;
        // Mode `UTF8` just escapes XML entities
        if (opts.mode === EncodingMode.UTF8)
            return (0, _escape.escapeUTF8)(data);
        if (opts.mode === EncodingMode.Attribute)
            return (0, _escape.escapeAttribute)(data);
        if (opts.mode === EncodingMode.Text)
            return (0, _escape.escapeText)(data);
        if (opts.level === EntityLevel.HTML) {
            if (opts.mode === EncodingMode.ASCII) {
                return (0, encode.encodeNonAsciiHTML)(data);
            }
            return (0, encode.encodeHTML)(data);
        }
        // ASCII and Extensive are equivalent
        return (0, _escape.encodeXML)(data);
    }
    exports.encode = encode$1;
    var escape_js_2 = _escape;
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return escape_js_2.encodeXML; } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return escape_js_2.escapeUTF8; } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function () { return escape_js_2.escapeAttribute; } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function () { return escape_js_2.escapeText; } });
    var encode_js_2 = encode;
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_js_2.encodeNonAsciiHTML; } });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });
    var decode_js_2 = decode;
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_js_2.decodeXML; } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_js_2.decodeXML; } });

    });

    var foreignNames = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath",
    ].map(function (val) { return [val.toLowerCase(), val]; }));
    exports.attributeNames = new Map([
        "definitionURL",
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan",
    ].map(function (val) { return [val.toLowerCase(), val]; }));
    });

    var lib$2 = createCommonjsModule(function (module, exports) {
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    /*
     * Module dependencies
     */
    var ElementType = __importStar(lib$5);

    /**
     * Mixed-case SVG and MathML tags & attributes
     * recognized by the HTML parser.
     *
     * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
     */

    var unencodedElements = new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript",
    ]);
    function replaceQuotes(value) {
        return value.replace(/"/g, "&quot;");
    }
    /**
     * Format attributes
     */
    function formatAttributes(attributes, opts) {
        var _a;
        if (!attributes)
            return;
        var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
            ? replaceQuotes
            : opts.xmlMode || opts.encodeEntities !== "utf8"
                ? lib$3.encodeXML
                : lib$3.escapeAttribute;
        return Object.keys(attributes)
            .map(function (key) {
            var _a, _b;
            var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
                /* Fix up mixed-case attribute names */
                key = (_b = foreignNames.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
                return key;
            }
            return "".concat(key, "=\"").concat(encode(value), "\"");
        })
            .join(" ");
    }
    /**
     * Self-enclosing tags
     */
    var singleTag = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    /**
     * Renders a DOM node or an array of DOM nodes to a string.
     *
     * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
     *
     * @param node Node to be rendered.
     * @param options Changes serialization behavior
     */
    function render(node, options) {
        if (options === void 0) { options = {}; }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i = 0; i < nodes.length; i++) {
            output += renderNode(nodes[i], options);
        }
        return output;
    }
    exports.render = render;
    exports.default = render;
    function renderNode(node, options) {
        switch (node.type) {
            case ElementType.Root:
                return render(node.children, options);
            // @ts-expect-error We don't use `Doctype` yet
            case ElementType.Doctype:
            case ElementType.Directive:
                return renderDirective(node);
            case ElementType.Comment:
                return renderComment(node);
            case ElementType.CDATA:
                return renderCdata(node);
            case ElementType.Script:
            case ElementType.Style:
            case ElementType.Tag:
                return renderTag(node, options);
            case ElementType.Text:
                return renderText(node, options);
        }
    }
    var foreignModeIntegrationPoints = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
    ]);
    var foreignElements = new Set(["svg", "math"]);
    function renderTag(elem, opts) {
        var _a;
        // Handle SVG / MathML in HTML
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case element names */
            elem.name = (_a = foreignNames.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
            /* Exit foreign mode at integration points */
            if (elem.parent &&
                foreignModeIntegrationPoints.has(elem.parent.name)) {
                opts = __assign(__assign({}, opts), { xmlMode: false });
            }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<".concat(elem.name);
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
            tag += " ".concat(attribs);
        }
        if (elem.children.length === 0 &&
            (opts.xmlMode
                ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                    opts.selfClosingTags !== false
                : // User explicitly asked for self-closing tags, even in HTML mode
                    opts.selfClosingTags && singleTag.has(elem.name))) {
            if (!opts.xmlMode)
                tag += " ";
            tag += "/>";
        }
        else {
            tag += ">";
            if (elem.children.length > 0) {
                tag += render(elem.children, opts);
            }
            if (opts.xmlMode || !singleTag.has(elem.name)) {
                tag += "</".concat(elem.name, ">");
            }
        }
        return tag;
    }
    function renderDirective(elem) {
        return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
        var _a;
        var data = elem.data || "";
        // If entities weren't decoded, no need to encode them back
        if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
            !(!opts.xmlMode &&
                elem.parent &&
                unencodedElements.has(elem.parent.name))) {
            data =
                opts.xmlMode || opts.encodeEntities !== "utf8"
                    ? (0, lib$3.encodeXML)(data)
                    : (0, lib$3.escapeText)(data);
        }
        return data;
    }
    function renderCdata(elem) {
        return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
        return "<!--".concat(elem.data, "-->");
    }
    });

    var stringify$1 = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;

    var dom_serializer_1 = __importDefault(lib$2);

    /**
     * @category Stringify
     * @deprecated Use the `dom-serializer` module directly.
     * @param node Node to get the outer HTML of.
     * @param options Options for serialization.
     * @returns `node`'s outer HTML.
     */
    function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    /**
     * @category Stringify
     * @deprecated Use the `dom-serializer` module directly.
     * @param node Node to get the inner HTML of.
     * @param options Options for serialization.
     * @returns `node`'s inner HTML.
     */
    function getInnerHTML(node, options) {
        return (0, lib$4.hasChildren)(node)
            ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
            : "";
    }
    exports.getInnerHTML = getInnerHTML;
    /**
     * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
     *
     * @category Stringify
     * @deprecated Use `textContent` instead.
     * @param node Node to get the inner text of.
     * @returns `node`'s inner text.
     */
    function getText(node) {
        if (Array.isArray(node))
            return node.map(getText).join("");
        if ((0, lib$4.isTag)(node))
            return node.name === "br" ? "\n" : getText(node.children);
        if ((0, lib$4.isCDATA)(node))
            return getText(node.children);
        if ((0, lib$4.isText)(node))
            return node.data;
        return "";
    }
    exports.getText = getText;
    /**
     * Get a node's text content.
     *
     * @category Stringify
     * @param node Node to get the text content of.
     * @returns `node`'s text content.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
     */
    function textContent(node) {
        if (Array.isArray(node))
            return node.map(textContent).join("");
        if ((0, lib$4.hasChildren)(node) && !(0, lib$4.isComment)(node)) {
            return textContent(node.children);
        }
        if ((0, lib$4.isText)(node))
            return node.data;
        return "";
    }
    exports.textContent = textContent;
    /**
     * Get a node's inner text.
     *
     * @category Stringify
     * @param node Node to get the inner text of.
     * @returns `node`'s inner text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
     */
    function innerText(node) {
        if (Array.isArray(node))
            return node.map(innerText).join("");
        if ((0, lib$4.hasChildren)(node) && (node.type === lib$5.ElementType.Tag || (0, lib$4.isCDATA)(node))) {
            return innerText(node.children);
        }
        if ((0, lib$4.isText)(node))
            return node.data;
        return "";
    }
    exports.innerText = innerText;

    });

    var traversal = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;

    /**
     * Get a node's children.
     *
     * @category Traversal
     * @param elem Node to get the children of.
     * @returns `elem`'s children, or an empty array.
     */
    function getChildren(elem) {
        return (0, lib$4.hasChildren)(elem) ? elem.children : [];
    }
    exports.getChildren = getChildren;
    /**
     * Get a node's parent.
     *
     * @category Traversal
     * @param elem Node to get the parent of.
     * @returns `elem`'s parent node.
     */
    function getParent(elem) {
        return elem.parent || null;
    }
    exports.getParent = getParent;
    /**
     * Gets an elements siblings, including the element itself.
     *
     * Attempts to get the children through the element's parent first. If we don't
     * have a parent (the element is a root node), we walk the element's `prev` &
     * `next` to get all remaining nodes.
     *
     * @category Traversal
     * @param elem Element to get the siblings of.
     * @returns `elem`'s siblings.
     */
    function getSiblings(elem) {
        var _a, _b;
        var parent = getParent(elem);
        if (parent != null)
            return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev, next = elem.next;
        while (prev != null) {
            siblings.unshift(prev);
            (_a = prev, prev = _a.prev);
        }
        while (next != null) {
            siblings.push(next);
            (_b = next, next = _b.next);
        }
        return siblings;
    }
    exports.getSiblings = getSiblings;
    /**
     * Gets an attribute from an element.
     *
     * @category Traversal
     * @param elem Element to check.
     * @param name Attribute name to retrieve.
     * @returns The element's attribute value, or `undefined`.
     */
    function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    /**
     * Checks whether an element has an attribute.
     *
     * @category Traversal
     * @param elem Element to check.
     * @param name Attribute name to look for.
     * @returns Returns whether `elem` has the attribute `name`.
     */
    function hasAttrib(elem, name) {
        return (elem.attribs != null &&
            Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
            elem.attribs[name] != null);
    }
    exports.hasAttrib = hasAttrib;
    /**
     * Get the tag name of an element.
     *
     * @category Traversal
     * @param elem The element to get the name for.
     * @returns The tag name of `elem`.
     */
    function getName(elem) {
        return elem.name;
    }
    exports.getName = getName;
    /**
     * Returns the next element sibling of a node.
     *
     * @category Traversal
     * @param elem The element to get the next sibling of.
     * @returns `elem`'s next sibling that is a tag.
     */
    function nextElementSibling(elem) {
        var _a;
        var next = elem.next;
        while (next !== null && !(0, lib$4.isTag)(next))
            (_a = next, next = _a.next);
        return next;
    }
    exports.nextElementSibling = nextElementSibling;
    /**
     * Returns the previous element sibling of a node.
     *
     * @category Traversal
     * @param elem The element to get the previous sibling of.
     * @returns `elem`'s previous sibling that is a tag.
     */
    function prevElementSibling(elem) {
        var _a;
        var prev = elem.prev;
        while (prev !== null && !(0, lib$4.isTag)(prev))
            (_a = prev, prev = _a.prev);
        return prev;
    }
    exports.prevElementSibling = prevElementSibling;

    });

    var manipulation = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    /**
     * Remove an element from the dom
     *
     * @category Manipulation
     * @param elem The element to be removed
     */
    function removeElement(elem) {
        if (elem.prev)
            elem.prev.next = elem.next;
        if (elem.next)
            elem.next.prev = elem.prev;
        if (elem.parent) {
            var childs = elem.parent.children;
            childs.splice(childs.lastIndexOf(elem), 1);
        }
    }
    exports.removeElement = removeElement;
    /**
     * Replace an element in the dom
     *
     * @category Manipulation
     * @param elem The element to be replaced
     * @param replacement The element to be added
     */
    function replaceElement(elem, replacement) {
        var prev = (replacement.prev = elem.prev);
        if (prev) {
            prev.next = replacement;
        }
        var next = (replacement.next = elem.next);
        if (next) {
            next.prev = replacement;
        }
        var parent = (replacement.parent = elem.parent);
        if (parent) {
            var childs = parent.children;
            childs[childs.lastIndexOf(elem)] = replacement;
            elem.parent = null;
        }
    }
    exports.replaceElement = replaceElement;
    /**
     * Append a child to an element.
     *
     * @category Manipulation
     * @param elem The element to append to.
     * @param child The element to be added as a child.
     */
    function appendChild(elem, child) {
        removeElement(child);
        child.next = null;
        child.parent = elem;
        if (elem.children.push(child) > 1) {
            var sibling = elem.children[elem.children.length - 2];
            sibling.next = child;
            child.prev = sibling;
        }
        else {
            child.prev = null;
        }
    }
    exports.appendChild = appendChild;
    /**
     * Append an element after another.
     *
     * @category Manipulation
     * @param elem The element to append after.
     * @param next The element be added.
     */
    function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
            currNext.prev = next;
            if (parent) {
                var childs = parent.children;
                childs.splice(childs.lastIndexOf(currNext), 0, next);
            }
        }
        else if (parent) {
            parent.children.push(next);
        }
    }
    exports.append = append;
    /**
     * Prepend a child to an element.
     *
     * @category Manipulation
     * @param elem The element to prepend before.
     * @param child The element to be added as a child.
     */
    function prependChild(elem, child) {
        removeElement(child);
        child.parent = elem;
        child.prev = null;
        if (elem.children.unshift(child) !== 1) {
            var sibling = elem.children[1];
            sibling.prev = child;
            child.next = sibling;
        }
        else {
            child.next = null;
        }
    }
    exports.prependChild = prependChild;
    /**
     * Prepend an element before another.
     *
     * @category Manipulation
     * @param elem The element to prepend before.
     * @param prev The element be added.
     */
    function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
            elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
    }
    exports.prepend = prepend;

    });

    var querying = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;

    /**
     * Search a node and its children for nodes passing a test function.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param node Node to search. Will be included in the result set if it matches.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes passing `test`.
     */
    function filter(test, node, recurse, limit) {
        if (recurse === void 0) { recurse = true; }
        if (limit === void 0) { limit = Infinity; }
        if (!Array.isArray(node))
            node = [node];
        return find(test, node, recurse, limit);
    }
    exports.filter = filter;
    /**
     * Search an array of node and its children for nodes passing a test function.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes passing `test`.
     */
    function find(test, nodes, recurse, limit) {
        var result = [];
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var elem = nodes_1[_i];
            if (test(elem)) {
                result.push(elem);
                if (--limit <= 0)
                    break;
            }
            if (recurse && (0, lib$4.hasChildren)(elem) && elem.children.length > 0) {
                var children = find(test, elem.children, recurse, limit);
                result.push.apply(result, children);
                limit -= children.length;
                if (limit <= 0)
                    break;
            }
        }
        return result;
    }
    exports.find = find;
    /**
     * Finds the first element inside of an array that matches a test function.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns The first node in the array that passes `test`.
     * @deprecated Use `Array.prototype.find` directly.
     */
    function findOneChild(test, nodes) {
        return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    /**
     * Finds one element in a tree that passes a test.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @param recurse Also consider child nodes.
     * @returns The first child node that passes `test`.
     */
    function findOne(test, nodes, recurse) {
        if (recurse === void 0) { recurse = true; }
        var elem = null;
        for (var i = 0; i < nodes.length && !elem; i++) {
            var checked = nodes[i];
            if (!(0, lib$4.isTag)(checked)) {
                continue;
            }
            else if (test(checked)) {
                elem = checked;
            }
            else if (recurse && checked.children.length > 0) {
                elem = findOne(test, checked.children, true);
            }
        }
        return elem;
    }
    exports.findOne = findOne;
    /**
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns Whether a tree of nodes contains at least one node passing the test.
     */
    function existsOne(test, nodes) {
        return nodes.some(function (checked) {
            return (0, lib$4.isTag)(checked) &&
                (test(checked) ||
                    (checked.children.length > 0 &&
                        existsOne(test, checked.children)));
        });
    }
    exports.existsOne = existsOne;
    /**
     * Search and array of nodes and its children for elements passing a test function.
     *
     * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns All nodes passing `test`.
     */
    function findAll(test, nodes) {
        var _a;
        var result = [];
        var stack = nodes.filter(lib$4.isTag);
        var elem;
        while ((elem = stack.shift())) {
            var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(lib$4.isTag);
            if (children && children.length > 0) {
                stack.unshift.apply(stack, children);
            }
            if (test(elem))
                result.push(elem);
        }
        return result;
    }
    exports.findAll = findAll;

    });

    var legacy = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;


    var Checks = {
        tag_name: function (name) {
            if (typeof name === "function") {
                return function (elem) { return (0, lib$4.isTag)(elem) && name(elem.name); };
            }
            else if (name === "*") {
                return lib$4.isTag;
            }
            return function (elem) { return (0, lib$4.isTag)(elem) && elem.name === name; };
        },
        tag_type: function (type) {
            if (typeof type === "function") {
                return function (elem) { return type(elem.type); };
            }
            return function (elem) { return elem.type === type; };
        },
        tag_contains: function (data) {
            if (typeof data === "function") {
                return function (elem) { return (0, lib$4.isText)(elem) && data(elem.data); };
            }
            return function (elem) { return (0, lib$4.isText)(elem) && elem.data === data; };
        },
    };
    /**
     * @param attrib Attribute to check.
     * @param value Attribute value to look for.
     * @returns A function to check whether the a node has an attribute with a
     *   particular value.
     */
    function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
            return function (elem) { return (0, lib$4.isTag)(elem) && value(elem.attribs[attrib]); };
        }
        return function (elem) { return (0, lib$4.isTag)(elem) && elem.attribs[attrib] === value; };
    }
    /**
     * @param a First function to combine.
     * @param b Second function to combine.
     * @returns A function taking a node and returning `true` if either of the input
     *   functions returns `true` for the node.
     */
    function combineFuncs(a, b) {
        return function (elem) { return a(elem) || b(elem); };
    }
    /**
     * @param options An object describing nodes to look for.
     * @returns A function executing all checks in `options` and returning `true` if
     *   any of them match a node.
     */
    function compileTest(options) {
        var funcs = Object.keys(options).map(function (key) {
            var value = options[key];
            return Object.prototype.hasOwnProperty.call(Checks, key)
                ? Checks[key](value)
                : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    /**
     * @category Legacy Query Functions
     * @param options An object describing nodes to look for.
     * @param node The element to test.
     * @returns Whether the element matches the description in `options`.
     */
    function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
    }
    exports.testElement = testElement;
    /**
     * @category Legacy Query Functions
     * @param options An object describing nodes to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes that match `options`.
     */
    function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) { limit = Infinity; }
        var test = compileTest(options);
        return test ? (0, querying.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    /**
     * @category Legacy Query Functions
     * @param id The unique ID attribute value to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @returns The node with the supplied ID.
     */
    function getElementById(id, nodes, recurse) {
        if (recurse === void 0) { recurse = true; }
        if (!Array.isArray(nodes))
            nodes = [nodes];
        return (0, querying.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    /**
     * @category Legacy Query Functions
     * @param tagName Tag name to search for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes with the supplied `tagName`.
     */
    function getElementsByTagName(tagName, nodes, recurse, limit) {
        if (recurse === void 0) { recurse = true; }
        if (limit === void 0) { limit = Infinity; }
        return (0, querying.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    /**
     * @category Legacy Query Functions
     * @param type Element type to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes with the supplied `type`.
     */
    function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) { recurse = true; }
        if (limit === void 0) { limit = Infinity; }
        return (0, querying.filter)(Checks["tag_type"](type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;

    });

    var helpers = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;

    /**
     * Given an array of nodes, remove any member that is contained by another.
     *
     * @category Helpers
     * @param nodes Nodes to filter.
     * @returns Remaining nodes that aren't subtrees of each other.
     */
    function removeSubsets(nodes) {
        var idx = nodes.length;
        /*
         * Check if each node (or one of its ancestors) is already contained in the
         * array.
         */
        while (--idx >= 0) {
            var node = nodes[idx];
            /*
             * Remove the node if it is not unique.
             * We are going through the array from the end, so we only
             * have to check nodes that preceed the node under consideration in the array.
             */
            if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
                nodes.splice(idx, 1);
                continue;
            }
            for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
                if (nodes.includes(ancestor)) {
                    nodes.splice(idx, 1);
                    break;
                }
            }
        }
        return nodes;
    }
    exports.removeSubsets = removeSubsets;
    /**
     * @category Helpers
     * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
     */
    var DocumentPosition;
    (function (DocumentPosition) {
        DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
        DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
        DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
        DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
        DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
    /**
     * Compare the position of one node against another node in any other document.
     * The return value is a bitmask with the values from {@link DocumentPosition}.
     *
     * Document order:
     * > There is an ordering, document order, defined on all the nodes in the
     * > document corresponding to the order in which the first character of the
     * > XML representation of each node occurs in the XML representation of the
     * > document after expansion of general entities. Thus, the document element
     * > node will be the first node. Element nodes occur before their children.
     * > Thus, document order orders element nodes in order of the occurrence of
     * > their start-tag in the XML (after expansion of entities). The attribute
     * > nodes of an element occur after the element and before its children. The
     * > relative order of attribute nodes is implementation-dependent.
     *
     * Source:
     * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
     *
     * @category Helpers
     * @param nodeA The first node to use in the comparison
     * @param nodeB The second node to use in the comparison
     * @returns A bitmask describing the input nodes' relative position.
     *
     * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
     * a description of these values.
     */
    function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
            return 0;
        }
        var current = (0, lib$4.hasChildren)(nodeA) ? nodeA : nodeA.parent;
        while (current) {
            aParents.unshift(current);
            current = current.parent;
        }
        current = (0, lib$4.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
            bParents.unshift(current);
            current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
            idx++;
        }
        if (idx === 0) {
            return DocumentPosition.DISCONNECTED;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
            if (sharedParent === nodeB) {
                return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
            }
            return DocumentPosition.FOLLOWING;
        }
        if (sharedParent === nodeA) {
            return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
        }
        return DocumentPosition.PRECEDING;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    /**
     * Sort an array of nodes based on their relative position in the document and
     * remove any duplicate nodes. If the array contains nodes that do not belong to
     * the same document, sort order is unspecified.
     *
     * @category Helpers
     * @param nodes Array of DOM nodes.
     * @returns Collection of unique nodes, sorted in document order.
     */
    function uniqueSort(nodes) {
        nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
        nodes.sort(function (a, b) {
            var relative = compareDocumentPosition(a, b);
            if (relative & DocumentPosition.PRECEDING) {
                return -1;
            }
            else if (relative & DocumentPosition.FOLLOWING) {
                return 1;
            }
            return 0;
        });
        return nodes;
    }
    exports.uniqueSort = uniqueSort;

    });

    var feeds = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;


    /**
     * Get the feed object from the root of a DOM tree.
     *
     * @category Feeds
     * @param doc - The DOM to to extract the feed from.
     * @returns The feed.
     */
    function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot
            ? null
            : feedRoot.name === "feed"
                ? getAtomFeed(feedRoot)
                : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    /**
     * Parse an Atom feed.
     *
     * @param feedRoot The root of the feed.
     * @returns The parsed feed.
     */
    function getAtomFeed(feedRoot) {
        var _a;
        var childs = feedRoot.children;
        var feed = {
            type: "atom",
            items: (0, legacy.getElementsByTagName)("entry", childs).map(function (item) {
                var _a;
                var children = item.children;
                var entry = { media: getMediaElements(children) };
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
                if (href) {
                    entry.link = href;
                }
                var description = fetch("summary", children) || fetch("content", children);
                if (description) {
                    entry.description = description;
                }
                var pubDate = fetch("updated", children);
                if (pubDate) {
                    entry.pubDate = new Date(pubDate);
                }
                return entry;
            }),
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
        if (href) {
            feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch("updated", childs);
        if (updated) {
            feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
    }
    /**
     * Parse a RSS feed.
     *
     * @param feedRoot The root of the feed.
     * @returns The parsed feed.
     */
    function getRssFeed(feedRoot) {
        var _a, _b;
        var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        var feed = {
            type: feedRoot.name.substr(0, 3),
            id: "",
            items: (0, legacy.getElementsByTagName)("item", feedRoot.children).map(function (item) {
                var children = item.children;
                var entry = { media: getMediaElements(children) };
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                var pubDate = fetch("pubDate", children);
                if (pubDate)
                    entry.pubDate = new Date(pubDate);
                return entry;
            }),
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch("lastBuildDate", childs);
        if (updated) {
            feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width",
    ];
    /**
     * Get all media elements of a feed item.
     *
     * @param where Nodes to search in.
     * @returns Media elements.
     */
    function getMediaElements(where) {
        return (0, legacy.getElementsByTagName)("media:content", where).map(function (elem) {
            var attribs = elem.attribs;
            var media = {
                medium: attribs["medium"],
                isDefault: !!attribs["isDefault"],
            };
            for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
                var attrib = MEDIA_KEYS_STRING_1[_i];
                if (attribs[attrib]) {
                    media[attrib] = attribs[attrib];
                }
            }
            for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
                var attrib = MEDIA_KEYS_INT_1[_a];
                if (attribs[attrib]) {
                    media[attrib] = parseInt(attribs[attrib], 10);
                }
            }
            if (attribs["expression"]) {
                media.expression = attribs["expression"];
            }
            return media;
        });
    }
    /**
     * Get one element by tag name.
     *
     * @param tagName Tag name to look for
     * @param node Node to search in
     * @returns The element or null
     */
    function getOneElement(tagName, node) {
        return (0, legacy.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    /**
     * Get the text content of an element with a certain tag name.
     *
     * @param tagName Tag name to look for.
     * @param where Node to search in.
     * @param recurse Whether to recurse into child nodes.
     * @returns The text content of the element.
     */
    function fetch(tagName, where, recurse) {
        if (recurse === void 0) { recurse = false; }
        return (0, stringify$1.textContent)((0, legacy.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    /**
     * Adds a property to an object if it has a value.
     *
     * @param obj Object to be extended
     * @param prop Property name
     * @param tagName Tag name that contains the conditionally added property
     * @param where Element to search for the property
     * @param recurse Whether to recurse into child nodes.
     */
    function addConditionally(obj, prop, tagName, where, recurse) {
        if (recurse === void 0) { recurse = false; }
        var val = fetch(tagName, where, recurse);
        if (val)
            obj[prop] = val;
    }
    /**
     * Checks if an element is a feed root node.
     *
     * @param value The name of the element to check.
     * @returns Whether an element is a feed root node.
     */
    function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
    }

    });

    var lib$1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(stringify$1, exports);
    __exportStar(traversal, exports);
    __exportStar(manipulation, exports);
    __exportStar(querying, exports);
    __exportStar(legacy, exports);
    __exportStar(helpers, exports);
    __exportStar(feeds, exports);
    /** @deprecated Use these methods from `domhandler` directly. */

    Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return lib$4.isTag; } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return lib$4.isCDATA; } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return lib$4.isText; } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return lib$4.isComment; } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return lib$4.isDocument; } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return lib$4.hasChildren; } });

    });

    var lib = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultHandler = exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;

    Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_1.Parser; } });

    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function () { return lib$4.DomHandler; } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function () { return lib$4.DomHandler; } });
    // Helper methods
    /**
     * Parses the data, returns the resulting document.
     *
     * @param data The data that should be parsed.
     * @param options Optional options for the parser and DOM builder.
     */
    function parseDocument(data, options) {
        var handler = new lib$4.DomHandler(undefined, options);
        new Parser_1.Parser(handler, options).end(data);
        return handler.root;
    }
    exports.parseDocument = parseDocument;
    /**
     * Parses data, returns an array of the root nodes.
     *
     * Note that the root nodes still have a `Document` node as their parent.
     * Use `parseDocument` to get the `Document` node instead.
     *
     * @param data The data that should be parsed.
     * @param options Optional options for the parser and DOM builder.
     * @deprecated Use `parseDocument` instead.
     */
    function parseDOM(data, options) {
        return parseDocument(data, options).children;
    }
    exports.parseDOM = parseDOM;
    /**
     * Creates a parser instance, with an attached DOM handler.
     *
     * @param cb A callback that will be called once parsing has been completed.
     * @param options Optional options for the parser and DOM builder.
     * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
     */
    function createDomStream(cb, options, elementCb) {
        var handler = new lib$4.DomHandler(cb, options, elementCb);
        return new Parser_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;

    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } });
    /*
     * All of the following exports exist for backwards-compatibility.
     * They should probably be removed eventually.
     */
    var ElementType = __importStar(lib$5);
    exports.ElementType = ElementType;

    Object.defineProperty(exports, "getFeed", { enumerable: true, get: function () { return lib$1.getFeed; } });
    /**
     * Parse a feed.
     *
     * @param feed The feed that should be parsed, as a string.
     * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
     */
    function parseFeed(feed, options) {
        if (options === void 0) { options = { xmlMode: true }; }
        return (0, lib$1.getFeed)(parseDOM(feed, options));
    }
    exports.parseFeed = parseFeed;
    exports.DomUtils = __importStar(lib$1);

    });

    var escapeStringRegexp = string => {
    	if (typeof string !== 'string') {
    		throw new TypeError('Expected a string');
    	}

    	// Escape characters with special meaning either inside or outside character sets.
    	// Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
    	return string
    		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
    		.replace(/-/g, '\\x2d');
    };

    /*!
     * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */

    function isObject(o) {
      return Object.prototype.toString.call(o) === '[object Object]';
    }

    function isPlainObject$1(o) {
      var ctor,prot;

      if (isObject(o) === false) return false;

      // If has modified constructor
      ctor = o.constructor;
      if (ctor === undefined) return true;

      // If has modified prototype
      prot = ctor.prototype;
      if (isObject(prot) === false) return false;

      // If constructor does not have an Object-specific method
      if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
      }

      // Most likely a plain Object
      return true;
    }

    var isPlainObject_2 = isPlainObject$1;

    var isPlainObject_1 = /*#__PURE__*/Object.defineProperty({
    	isPlainObject: isPlainObject_2
    }, '__esModule', {value: true});

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return target.propertyIsEnumerable(symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    /**
     * Srcset Parser
     *
     * By Alex Bell |  MIT License
     *
     * JS Parser for the string value that appears in markup <img srcset="here">
     *
     * @returns Array [{url: _, d: _, w: _, h:_}, ...]
     *
     * Based super duper closely on the reference algorithm at:
     * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
     *
     * Most comments are copied in directly from the spec
     * (except for comments in parens).
     */

    var parseSrcset = createCommonjsModule(function (module) {
    (function (root, factory) {
    	if (module.exports) {
    		// Node. Does not work with strict CommonJS, but
    		// only CommonJS-like environments that support module.exports,
    		// like Node.
    		module.exports = factory();
    	} else {
    		// Browser globals (root is window)
    		root.parseSrcset = factory();
    	}
    }(commonjsGlobal, function () {

    	// 1. Let input be the value passed to this algorithm.
    	return function (input) {

    		// UTILITY FUNCTIONS

    		// Manual is faster than RegEx
    		// http://bjorn.tipling.com/state-and-regular-expressions-in-javascript
    		// http://jsperf.com/whitespace-character/5
    		function isSpace(c) {
    			return (c === "\u0020" || // space
    			c === "\u0009" || // horizontal tab
    			c === "\u000A" || // new line
    			c === "\u000C" || // form feed
    			c === "\u000D");  // carriage return
    		}

    		function collectCharacters(regEx) {
    			var chars,
    				match = regEx.exec(input.substring(pos));
    			if (match) {
    				chars = match[ 0 ];
    				pos += chars.length;
    				return chars;
    			}
    		}

    		var inputLength = input.length,

    			// (Don't use \s, to avoid matching non-breaking space)
    			regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
    			regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
    			regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
    			regexTrailingCommas = /[,]+$/,
    			regexNonNegativeInteger = /^\d+$/,

    			// ( Positive or negative or unsigned integers or decimals, without or without exponents.
    			// Must include at least one digit.
    			// According to spec tests any decimal point must be followed by a digit.
    			// No leading plus sign is allowed.)
    			// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
    			regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,

    			url,
    			descriptors,
    			currentDescriptor,
    			state,
    			c,

    			// 2. Let position be a pointer into input, initially pointing at the start
    			//    of the string.
    			pos = 0,

    			// 3. Let candidates be an initially empty source set.
    			candidates = [];

    		// 4. Splitting loop: Collect a sequence of characters that are space
    		//    characters or U+002C COMMA characters. If any U+002C COMMA characters
    		//    were collected, that is a parse error.
    		while (true) {
    			collectCharacters(regexLeadingCommasOrSpaces);

    			// 5. If position is past the end of input, return candidates and abort these steps.
    			if (pos >= inputLength) {
    				return candidates; // (we're done, this is the sole return path)
    			}

    			// 6. Collect a sequence of characters that are not space characters,
    			//    and let that be url.
    			url = collectCharacters(regexLeadingNotSpaces);

    			// 7. Let descriptors be a new empty list.
    			descriptors = [];

    			// 8. If url ends with a U+002C COMMA character (,), follow these substeps:
    			//		(1). Remove all trailing U+002C COMMA characters from url. If this removed
    			//         more than one character, that is a parse error.
    			if (url.slice(-1) === ",") {
    				url = url.replace(regexTrailingCommas, "");
    				// (Jump ahead to step 9 to skip tokenization and just push the candidate).
    				parseDescriptors();

    				//	Otherwise, follow these substeps:
    			} else {
    				tokenize();
    			} // (close else of step 8)

    			// 16. Return to the step labeled splitting loop.
    		} // (Close of big while loop.)

    		/**
    		 * Tokenizes descriptor properties prior to parsing
    		 * Returns undefined.
    		 */
    		function tokenize() {

    			// 8.1. Descriptor tokeniser: Skip whitespace
    			collectCharacters(regexLeadingSpaces);

    			// 8.2. Let current descriptor be the empty string.
    			currentDescriptor = "";

    			// 8.3. Let state be in descriptor.
    			state = "in descriptor";

    			while (true) {

    				// 8.4. Let c be the character at position.
    				c = input.charAt(pos);

    				//  Do the following depending on the value of state.
    				//  For the purpose of this step, "EOF" is a special character representing
    				//  that position is past the end of input.

    				// In descriptor
    				if (state === "in descriptor") {
    					// Do the following, depending on the value of c:

    					// Space character
    					// If current descriptor is not empty, append current descriptor to
    					// descriptors and let current descriptor be the empty string.
    					// Set state to after descriptor.
    					if (isSpace(c)) {
    						if (currentDescriptor) {
    							descriptors.push(currentDescriptor);
    							currentDescriptor = "";
    							state = "after descriptor";
    						}

    						// U+002C COMMA (,)
    						// Advance position to the next character in input. If current descriptor
    						// is not empty, append current descriptor to descriptors. Jump to the step
    						// labeled descriptor parser.
    					} else if (c === ",") {
    						pos += 1;
    						if (currentDescriptor) {
    							descriptors.push(currentDescriptor);
    						}
    						parseDescriptors();
    						return;

    						// U+0028 LEFT PARENTHESIS (()
    						// Append c to current descriptor. Set state to in parens.
    					} else if (c === "\u0028") {
    						currentDescriptor = currentDescriptor + c;
    						state = "in parens";

    						// EOF
    						// If current descriptor is not empty, append current descriptor to
    						// descriptors. Jump to the step labeled descriptor parser.
    					} else if (c === "") {
    						if (currentDescriptor) {
    							descriptors.push(currentDescriptor);
    						}
    						parseDescriptors();
    						return;

    						// Anything else
    						// Append c to current descriptor.
    					} else {
    						currentDescriptor = currentDescriptor + c;
    					}
    					// (end "in descriptor"

    					// In parens
    				} else if (state === "in parens") {

    					// U+0029 RIGHT PARENTHESIS ())
    					// Append c to current descriptor. Set state to in descriptor.
    					if (c === ")") {
    						currentDescriptor = currentDescriptor + c;
    						state = "in descriptor";

    						// EOF
    						// Append current descriptor to descriptors. Jump to the step labeled
    						// descriptor parser.
    					} else if (c === "") {
    						descriptors.push(currentDescriptor);
    						parseDescriptors();
    						return;

    						// Anything else
    						// Append c to current descriptor.
    					} else {
    						currentDescriptor = currentDescriptor + c;
    					}

    					// After descriptor
    				} else if (state === "after descriptor") {

    					// Do the following, depending on the value of c:
    					// Space character: Stay in this state.
    					if (isSpace(c)) ; else if (c === "") {
    						parseDescriptors();
    						return;

    						// Anything else
    						// Set state to in descriptor. Set position to the previous character in input.
    					} else {
    						state = "in descriptor";
    						pos -= 1;

    					}
    				}

    				// Advance position to the next character in input.
    				pos += 1;

    				// Repeat this step.
    			} // (close while true loop)
    		}

    		/**
    		 * Adds descriptor properties to a candidate, pushes to the candidates array
    		 * @return undefined
    		 */
    		// Declared outside of the while loop so that it's only created once.
    		function parseDescriptors() {

    			// 9. Descriptor parser: Let error be no.
    			var pError = false,

    				// 10. Let width be absent.
    				// 11. Let density be absent.
    				// 12. Let future-compat-h be absent. (We're implementing it now as h)
    				w, d, h, i,
    				candidate = {},
    				desc, lastChar, value, intVal, floatVal;

    			// 13. For each descriptor in descriptors, run the appropriate set of steps
    			// from the following list:
    			for (i = 0 ; i < descriptors.length; i++) {
    				desc = descriptors[ i ];

    				lastChar = desc[ desc.length - 1 ];
    				value = desc.substring(0, desc.length - 1);
    				intVal = parseInt(value, 10);
    				floatVal = parseFloat(value);

    				// If the descriptor consists of a valid non-negative integer followed by
    				// a U+0077 LATIN SMALL LETTER W character
    				if (regexNonNegativeInteger.test(value) && (lastChar === "w")) {

    					// If width and density are not both absent, then let error be yes.
    					if (w || d) {pError = true;}

    					// Apply the rules for parsing non-negative integers to the descriptor.
    					// If the result is zero, let error be yes.
    					// Otherwise, let width be the result.
    					if (intVal === 0) {pError = true;} else {w = intVal;}

    					// If the descriptor consists of a valid floating-point number followed by
    					// a U+0078 LATIN SMALL LETTER X character
    				} else if (regexFloatingPoint.test(value) && (lastChar === "x")) {

    					// If width, density and future-compat-h are not all absent, then let error
    					// be yes.
    					if (w || d || h) {pError = true;}

    					// Apply the rules for parsing floating-point number values to the descriptor.
    					// If the result is less than zero, let error be yes. Otherwise, let density
    					// be the result.
    					if (floatVal < 0) {pError = true;} else {d = floatVal;}

    					// If the descriptor consists of a valid non-negative integer followed by
    					// a U+0068 LATIN SMALL LETTER H character
    				} else if (regexNonNegativeInteger.test(value) && (lastChar === "h")) {

    					// If height and density are not both absent, then let error be yes.
    					if (h || d) {pError = true;}

    					// Apply the rules for parsing non-negative integers to the descriptor.
    					// If the result is zero, let error be yes. Otherwise, let future-compat-h
    					// be the result.
    					if (intVal === 0) {pError = true;} else {h = intVal;}

    					// Anything else, Let error be yes.
    				} else {pError = true;}
    			} // (close step 13 for loop)

    			// 15. If error is still no, then append a new image source to candidates whose
    			// URL is url, associated with a width width if not absent and a pixel
    			// density density if not absent. Otherwise, there is a parse error.
    			if (!pError) {
    				candidate.url = url;
    				if (w) { candidate.w = w;}
    				if (d) { candidate.d = d;}
    				if (h) { candidate.h = h;}
    				candidates.push(candidate);
    			} else if (console && console.log) {
    				console.log("Invalid srcset descriptor found in '" +
    					input + "' at '" + desc + "'.");
    			}
    		} // (close parseDescriptors fn)

    	}
    }));
    });

    var x$2=String;
    var create=function() {return {isColorSupported:false,reset:x$2,bold:x$2,dim:x$2,italic:x$2,underline:x$2,inverse:x$2,hidden:x$2,strikethrough:x$2,black:x$2,red:x$2,green:x$2,yellow:x$2,blue:x$2,magenta:x$2,cyan:x$2,white:x$2,gray:x$2,bgBlack:x$2,bgRed:x$2,bgGreen:x$2,bgYellow:x$2,bgBlue:x$2,bgMagenta:x$2,bgCyan:x$2,bgWhite:x$2}};
    var picocolors_browser=create();
    var createColors = create;
    picocolors_browser.createColors = createColors;

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    class CssSyntaxError extends Error {
      constructor(message, line, column, source, file, plugin) {
        super(message);
        this.name = 'CssSyntaxError';
        this.reason = message;

        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line !== 'undefined' && typeof column !== 'undefined') {
          if (typeof line === 'number') {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }

        this.setMessage();

        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError);
        }
      }

      setMessage() {
        this.message = this.plugin ? this.plugin + ': ' : '';
        this.message += this.file ? this.file : '<css input>';
        if (typeof this.line !== 'undefined') {
          this.message += ':' + this.line + ':' + this.column;
        }
        this.message += ': ' + this.reason;
      }

      showSourceCode(color) {
        if (!this.source) return ''

        let css = this.source;
        if (color == null) color = picocolors_browser.isColorSupported;
        if (require$$2) {
          if (color) css = require$$2(css);
        }

        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);

        let maxWidth = String(end).length;

        let mark, aside;
        if (color) {
          let { bold, red, gray } = picocolors_browser.createColors(true);
          mark = text => bold(red(text));
          aside = text => gray(text);
        } else {
          mark = aside = str => str;
        }

        return lines
          .slice(start, end)
          .map((line, index) => {
            let number = start + 1 + index;
            let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
            if (number === this.line) {
              let spacing =
                aside(gutter.replace(/\d/g, ' ')) +
                line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
              return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^')
            }
            return ' ' + aside(gutter) + line
          })
          .join('\n')
      }

      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = '\n\n' + code + '\n';
        }
        return this.name + ': ' + this.message + code
      }
    }

    var cssSyntaxError = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;

    var isClean$3 = Symbol('isClean');

    var my$3 = Symbol('my');

    var symbols = {
    	isClean: isClean$3,
    	my: my$3
    };

    const DEFAULT_RAW = {
      colon: ': ',
      indent: '    ',
      beforeDecl: '\n',
      beforeRule: '\n',
      beforeOpen: ' ',
      beforeClose: '\n',
      beforeComment: '\n',
      after: '\n',
      emptyBody: '',
      commentLeft: ' ',
      commentRight: ' ',
      semicolon: false
    };

    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1)
    }

    class Stringifier {
      constructor(builder) {
        this.builder = builder;
      }

      stringify(node, semicolon) {
        /* c8 ignore start */
        if (!this[node.type]) {
          throw new Error(
            'Unknown AST node type ' +
              node.type +
              '. ' +
              'Maybe you need to change PostCSS stringifier.'
          )
        }
        /* c8 ignore stop */
        this[node.type](node, semicolon);
      }

      document(node) {
        this.body(node);
      }

      root(node) {
        this.body(node);
        if (node.raws.after) this.builder(node.raws.after);
      }

      comment(node) {
        let left = this.raw(node, 'left', 'commentLeft');
        let right = this.raw(node, 'right', 'commentRight');
        this.builder('/*' + left + node.text + right + '*/', node);
      }

      decl(node, semicolon) {
        let between = this.raw(node, 'between', 'colon');
        let string = node.prop + between + this.rawValue(node, 'value');

        if (node.important) {
          string += node.raws.important || ' !important';
        }

        if (semicolon) string += ';';
        this.builder(string, node);
      }

      rule(node) {
        this.block(node, this.rawValue(node, 'selector'));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, 'end');
        }
      }

      atrule(node, semicolon) {
        let name = '@' + node.name;
        let params = node.params ? this.rawValue(node, 'params') : '';

        if (typeof node.raws.afterName !== 'undefined') {
          name += node.raws.afterName;
        } else if (params) {
          name += ' ';
        }

        if (node.nodes) {
          this.block(node, name + params);
        } else {
          let end = (node.raws.between || '') + (semicolon ? ';' : '');
          this.builder(name + params + end, node);
        }
      }

      body(node) {
        let last = node.nodes.length - 1;
        while (last > 0) {
          if (node.nodes[last].type !== 'comment') break
          last -= 1;
        }

        let semicolon = this.raw(node, 'semicolon');
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          let before = this.raw(child, 'before');
          if (before) this.builder(before);
          this.stringify(child, last !== i || semicolon);
        }
      }

      block(node, start) {
        let between = this.raw(node, 'between', 'beforeOpen');
        this.builder(start + between + '{', node, 'start');

        let after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, 'after');
        } else {
          after = this.raw(node, 'after', 'emptyBody');
        }

        if (after) this.builder(after);
        this.builder('}', node, 'end');
      }

      raw(node, own, detect) {
        let value;
        if (!detect) detect = own;

        // Already had
        if (own) {
          value = node.raws[own];
          if (typeof value !== 'undefined') return value
        }

        let parent = node.parent;

        if (detect === 'before') {
          // Hack for first rule in CSS
          if (!parent || (parent.type === 'root' && parent.first === node)) {
            return ''
          }

          // `root` nodes in `document` should use only their own raws
          if (parent && parent.type === 'document') {
            return ''
          }
        }

        // Floating child without parent
        if (!parent) return DEFAULT_RAW[detect]

        // Detect style by other nodes
        let root = node.root();
        if (!root.rawCache) root.rawCache = {};
        if (typeof root.rawCache[detect] !== 'undefined') {
          return root.rawCache[detect]
        }

        if (detect === 'before' || detect === 'after') {
          return this.beforeAfter(node, detect)
        } else {
          let method = 'raw' + capitalize(detect);
          if (this[method]) {
            value = this[method](root, node);
          } else {
            root.walk(i => {
              value = i.raws[own];
              if (typeof value !== 'undefined') return false
            });
          }
        }

        if (typeof value === 'undefined') value = DEFAULT_RAW[detect];

        root.rawCache[detect] = value;
        return value
      }

      rawSemicolon(root) {
        let value;
        root.walk(i => {
          if (i.nodes && i.nodes.length && i.last.type === 'decl') {
            value = i.raws.semicolon;
            if (typeof value !== 'undefined') return false
          }
        });
        return value
      }

      rawEmptyBody(root) {
        let value;
        root.walk(i => {
          if (i.nodes && i.nodes.length === 0) {
            value = i.raws.after;
            if (typeof value !== 'undefined') return false
          }
        });
        return value
      }

      rawIndent(root) {
        if (root.raws.indent) return root.raws.indent
        let value;
        root.walk(i => {
          let p = i.parent;
          if (p && p !== root && p.parent && p.parent === root) {
            if (typeof i.raws.before !== 'undefined') {
              let parts = i.raws.before.split('\n');
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, '');
              return false
            }
          }
        });
        return value
      }

      rawBeforeComment(root, node) {
        let value;
        root.walkComments(i => {
          if (typeof i.raws.before !== 'undefined') {
            value = i.raws.before;
            if (value.includes('\n')) {
              value = value.replace(/[^\n]+$/, '');
            }
            return false
          }
        });
        if (typeof value === 'undefined') {
          value = this.raw(node, null, 'beforeDecl');
        } else if (value) {
          value = value.replace(/\S/g, '');
        }
        return value
      }

      rawBeforeDecl(root, node) {
        let value;
        root.walkDecls(i => {
          if (typeof i.raws.before !== 'undefined') {
            value = i.raws.before;
            if (value.includes('\n')) {
              value = value.replace(/[^\n]+$/, '');
            }
            return false
          }
        });
        if (typeof value === 'undefined') {
          value = this.raw(node, null, 'beforeRule');
        } else if (value) {
          value = value.replace(/\S/g, '');
        }
        return value
      }

      rawBeforeRule(root) {
        let value;
        root.walk(i => {
          if (i.nodes && (i.parent !== root || root.first !== i)) {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;
              if (value.includes('\n')) {
                value = value.replace(/[^\n]+$/, '');
              }
              return false
            }
          }
        });
        if (value) value = value.replace(/\S/g, '');
        return value
      }

      rawBeforeClose(root) {
        let value;
        root.walk(i => {
          if (i.nodes && i.nodes.length > 0) {
            if (typeof i.raws.after !== 'undefined') {
              value = i.raws.after;
              if (value.includes('\n')) {
                value = value.replace(/[^\n]+$/, '');
              }
              return false
            }
          }
        });
        if (value) value = value.replace(/\S/g, '');
        return value
      }

      rawBeforeOpen(root) {
        let value;
        root.walk(i => {
          if (i.type !== 'decl') {
            value = i.raws.between;
            if (typeof value !== 'undefined') return false
          }
        });
        return value
      }

      rawColon(root) {
        let value;
        root.walkDecls(i => {
          if (typeof i.raws.between !== 'undefined') {
            value = i.raws.between.replace(/[^\s:]/g, '');
            return false
          }
        });
        return value
      }

      beforeAfter(node, detect) {
        let value;
        if (node.type === 'decl') {
          value = this.raw(node, null, 'beforeDecl');
        } else if (node.type === 'comment') {
          value = this.raw(node, null, 'beforeComment');
        } else if (detect === 'before') {
          value = this.raw(node, null, 'beforeRule');
        } else {
          value = this.raw(node, null, 'beforeClose');
        }

        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== 'root') {
          depth += 1;
          buf = buf.parent;
        }

        if (value.includes('\n')) {
          let indent = this.raw(node, null, 'indent');
          if (indent.length) {
            for (let step = 0; step < depth; step++) value += indent;
          }
        }

        return value
      }

      rawValue(node, prop) {
        let value = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw
        }

        return value
      }
    }

    var stringifier = Stringifier;
    Stringifier.default = Stringifier;

    function stringify(node, builder) {
      let str = new stringifier(builder);
      str.stringify(node);
    }

    var stringify_1 = stringify;
    stringify.default = stringify;

    let { isClean: isClean$2, my: my$2 } = symbols;




    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();

      for (let i in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i)) {
          /* c8 ignore next 2 */
          continue
        }
        if (i === 'proxyCache') continue
        let value = obj[i];
        let type = typeof value;

        if (i === 'parent' && type === 'object') {
          if (parent) cloned[i] = parent;
        } else if (i === 'source') {
          cloned[i] = value;
        } else if (Array.isArray(value)) {
          cloned[i] = value.map(j => cloneNode(j, cloned));
        } else {
          if (type === 'object' && value !== null) value = cloneNode(value);
          cloned[i] = value;
        }
      }

      return cloned
    }

    class Node$1 {
      constructor(defaults = {}) {
        this.raws = {};
        this[isClean$2] = false;
        this[my$2] = true;

        for (let name in defaults) {
          if (name === 'nodes') {
            this.nodes = [];
            for (let node of defaults[name]) {
              if (typeof node.clone === 'function') {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name] = defaults[name];
          }
        }
      }

      error(message, opts = {}) {
        if (this.source) {
          let { start, end } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { line: start.line, column: start.column },
            { line: end.line, column: end.column },
            opts
          )
        }
        return new cssSyntaxError(message)
      }

      warn(result, text, opts) {
        let data = { node: this };
        for (let i in opts) data[i] = opts[i];
        return result.warn(text, data)
      }

      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this
      }

      toString(stringifier = stringify_1) {
        if (stringifier.stringify) stringifier = stringifier.stringify;
        let result = '';
        stringifier(this, i => {
          result += i;
        });
        return result
      }

      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this
      }

      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned
      }

      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned
      }

      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned
      }

      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }

          if (!foundSelf) {
            this.remove();
          }
        }

        return this
      }

      next() {
        if (!this.parent) return undefined
        let index = this.parent.index(this);
        return this.parent.nodes[index + 1]
      }

      prev() {
        if (!this.parent) return undefined
        let index = this.parent.index(this);
        return this.parent.nodes[index - 1]
      }

      before(add) {
        this.parent.insertBefore(this, add);
        return this
      }

      after(add) {
        this.parent.insertAfter(this, add);
        return this
      }

      root() {
        let result = this;
        while (result.parent && result.parent.type !== 'document') {
          result = result.parent;
        }
        return result
      }

      raw(prop, defaultType) {
        let str = new stringifier();
        return str.raw(this, prop, defaultType)
      }

      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
      }

      toJSON(_, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || new Map();
        let inputsNextIndex = 0;

        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            /* c8 ignore next 2 */
            continue
          }
          if (name === 'parent' || name === 'proxyCache') continue
          let value = this[name];

          if (Array.isArray(value)) {
            fixed[name] = value.map(i => {
              if (typeof i === 'object' && i.toJSON) {
                return i.toJSON(null, inputs)
              } else {
                return i
              }
            });
          } else if (typeof value === 'object' && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === 'source') {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              inputId,
              start: value.start,
              end: value.end
            };
          } else {
            fixed[name] = value;
          }
        }

        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
        }

        return fixed
      }

      positionInside(index) {
        let string = this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;

        for (let i = 0; i < index; i++) {
          if (string[i] === '\n') {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }

        return { line, column }
      }

      positionBy(opts) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index);
        } else if (opts.word) {
          let index = this.toString().indexOf(opts.word);
          if (index !== -1) pos = this.positionInside(index);
        }
        return pos
      }

      rangeBy(opts) {
        let start = {
          line: this.source.start.line,
          column: this.source.start.column
        };
        let end = this.source.end
          ? {
              line: this.source.end.line,
              column: this.source.end.column + 1
            }
          : {
              line: start.line,
              column: start.column + 1
            };

        if (opts.word) {
          let index = this.toString().indexOf(opts.word);
          if (index !== -1) {
            start = this.positionInside(index);
            end = this.positionInside(index + opts.word.length);
          }
        } else {
          if (opts.start) {
            start = {
              line: opts.start.line,
              column: opts.start.column
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }

          if (opts.end) {
            end = {
              line: opts.end.line,
              column: opts.end.column
            };
          } else if (opts.endIndex) {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }

        if (
          end.line < start.line ||
          (end.line === start.line && end.column <= start.column)
        ) {
          end = { line: start.line, column: start.column + 1 };
        }

        return { start, end }
      }

      getProxyProcessor() {
        return {
          set(node, prop, value) {
            if (node[prop] === value) return true
            node[prop] = value;
            if (
              prop === 'prop' ||
              prop === 'value' ||
              prop === 'name' ||
              prop === 'params' ||
              prop === 'important' ||
              /* c8 ignore next */
              prop === 'text'
            ) {
              node.markDirty();
            }
            return true
          },

          get(node, prop) {
            if (prop === 'proxyOf') {
              return node
            } else if (prop === 'root') {
              return () => node.root().toProxy()
            } else {
              return node[prop]
            }
          }
        }
      }

      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache
      }

      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
          );
        }
        return error
      }

      markDirty() {
        if (this[isClean$2]) {
          this[isClean$2] = false;
          let next = this;
          while ((next = next.parent)) {
            next[isClean$2] = false;
          }
        }
      }

      get proxyOf() {
        return this
      }
    }

    var node_1 = Node$1;
    Node$1.default = Node$1;

    class Declaration extends node_1 {
      constructor(defaults) {
        if (
          defaults &&
          typeof defaults.value !== 'undefined' &&
          typeof defaults.value !== 'string'
        ) {
          defaults = { ...defaults, value: String(defaults.value) };
        }
        super(defaults);
        this.type = 'decl';
      }

      get variable() {
        return this.prop.startsWith('--') || this.prop[0] === '$'
      }
    }

    var declaration = Declaration;
    Declaration.default = Declaration;

    let urlAlphabet =
      'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
    let customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = '';
        let i = size;
        while (i--) {
          id += alphabet[(Math.random() * alphabet.length) | 0];
        }
        return id
      }
    };
    let nanoid$1 = (size = 21) => {
      let id = '';
      let i = size;
      while (i--) {
        id += urlAlphabet[(Math.random() * 64) | 0];
      }
      return id
    };
    var nonSecure = { nanoid: nanoid$1, customAlphabet };

    let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require$$2;
    let { existsSync, readFileSync } = require$$2;
    let { dirname: dirname$1, join } = require$$2;

    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, 'base64').toString()
      } else {
        /* c8 ignore next 2 */
        return window.atob(str)
      }
    }

    class PreviousMap {
      constructor(css, opts) {
        if (opts.map === false) return
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, 'data:');

        let prev = opts.map ? opts.map.prev : undefined;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile) this.root = dirname$1(this.mapFile);
        if (text) this.text = text;
      }

      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer$2(this.text);
        }
        return this.consumerCache
      }

      withContent() {
        return !!(
          this.consumer().sourcesContent &&
          this.consumer().sourcesContent.length > 0
        )
      }

      startWith(string, start) {
        if (!string) return false
        return string.substr(0, start.length) === start
      }

      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
      }

      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments) return

        // sourceMappingURLs from comments, strings, etc.
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf('*/', start);

        if (start > -1 && end > -1) {
          // Locate the last sourceMappingURL to avoid pickin
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }

      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;

        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length))
        }

        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length))
        }

        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error('Unsupported source map encoding ' + encoding)
      }

      loadFile(path) {
        this.root = dirname$1(path);
        if (existsSync(path)) {
          this.mapFile = path;
          return readFileSync(path, 'utf-8').toString().trim()
        }
      }

      loadMap(file, prev) {
        if (prev === false) return false

        if (prev) {
          if (typeof prev === 'string') {
            return prev
          } else if (typeof prev === 'function') {
            let prevPath = prev(file);
            if (prevPath) {
              let map = this.loadFile(prevPath);
              if (!map) {
                throw new Error(
                  'Unable to load previous source map: ' + prevPath.toString()
                )
              }
              return map
            }
          } else if (prev instanceof SourceMapConsumer$2) {
            return SourceMapGenerator$2.fromSourceMap(prev).toString()
          } else if (prev instanceof SourceMapGenerator$2) {
            return prev.toString()
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev)
          } else {
            throw new Error(
              'Unsupported previous source map format: ' + prev.toString()
            )
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation)
        } else if (this.annotation) {
          let map = this.annotation;
          if (file) map = join(dirname$1(file), map);
          return this.loadFile(map)
        }
      }

      isMap(map) {
        if (typeof map !== 'object') return false
        return (
          typeof map.mappings === 'string' ||
          typeof map._mappings === 'string' ||
          Array.isArray(map.sections)
        )
      }
    }

    var previousMap = PreviousMap;
    PreviousMap.default = PreviousMap;

    let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require$$2;
    let { fileURLToPath, pathToFileURL: pathToFileURL$1 } = require$$2;
    let { resolve: resolve$1, isAbsolute } = require$$2;
    let { nanoid } = nonSecure;





    let fromOffsetCache = Symbol('fromOffsetCache');

    let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
    let pathAvailable$1 = Boolean(resolve$1 && isAbsolute);

    class Input {
      constructor(css, opts = {}) {
        if (
          css === null ||
          typeof css === 'undefined' ||
          (typeof css === 'object' && !css.toString)
        ) {
          throw new Error(`PostCSS received ${css} instead of CSS string`)
        }

        this.css = css.toString();

        if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }

        if (opts.from) {
          if (
            !pathAvailable$1 ||
            /^\w+:\/\//.test(opts.from) ||
            isAbsolute(opts.from)
          ) {
            this.file = opts.from;
          } else {
            this.file = resolve$1(opts.from);
          }
        }

        if (pathAvailable$1 && sourceMapAvailable$1) {
          let map = new previousMap(this.css, opts);
          if (map.text) {
            this.map = map;
            let file = map.consumer().file;
            if (!this.file && file) this.file = this.mapResolve(file);
          }
        }

        if (!this.file) {
          this.id = '<input css ' + nanoid(6) + '>';
        }
        if (this.map) this.map.file = this.from;
      }

      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split('\n');
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;

          for (let i = 0, l = lines.length; i < l; i++) {
            lineToIndex[i] = prevIndex;
            prevIndex += lines[i].length + 1;
          }

          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];

        let min = 0;
        if (offset >= lastLine) {
          min = lineToIndex.length - 1;
        } else {
          let max = lineToIndex.length - 2;
          let mid;
          while (min < max) {
            mid = min + ((max - min) >> 1);
            if (offset < lineToIndex[mid]) {
              max = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min = mid + 1;
            } else {
              min = mid;
              break
            }
          }
        }
        return {
          line: min + 1,
          col: offset - lineToIndex[min] + 1
        }
      }

      error(message, line, column, opts = {}) {
        let result, endLine, endColumn;

        if (line && typeof line === 'object') {
          let start = line;
          let end = column;
          if (typeof line.offset === 'number') {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === 'number') {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }

        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result = new cssSyntaxError(
            message,
            origin.endLine === undefined
              ? origin.line
              : { line: origin.line, column: origin.column },
            origin.endLine === undefined
              ? origin.column
              : { line: origin.endLine, column: origin.endColumn },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new cssSyntaxError(
            message,
            endLine === undefined ? line : { line, column },
            endLine === undefined ? column : { line: endLine, column: endColumn },
            this.css,
            this.file,
            opts.plugin
          );
        }

        result.input = { line, column, endLine, endColumn, source: this.css };
        if (this.file) {
          if (pathToFileURL$1) {
            result.input.url = pathToFileURL$1(this.file).toString();
          }
          result.input.file = this.file;
        }

        return result
      }

      origin(line, column, endLine, endColumn) {
        if (!this.map) return false
        let consumer = this.map.consumer();

        let from = consumer.originalPositionFor({ line, column });
        if (!from.source) return false

        let to;
        if (typeof endLine === 'number') {
          to = consumer.originalPositionFor({ line: endLine, column: endColumn });
        }

        let fromUrl;

        if (isAbsolute(from.source)) {
          fromUrl = pathToFileURL$1(from.source);
        } else {
          fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile)
          );
        }

        let result = {
          url: fromUrl.toString(),
          line: from.line,
          column: from.column,
          endLine: to && to.line,
          endColumn: to && to.column
        };

        if (fromUrl.protocol === 'file:') {
          if (fileURLToPath) {
            result.file = fileURLToPath(fromUrl);
          } else {
            /* c8 ignore next 2 */
            throw new Error(`file: protocol is not available in this PostCSS build`)
          }
        }

        let source = consumer.sourceContentFor(from.source);
        if (source) result.source = source;

        return result
      }

      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file
        }
        return resolve$1(this.map.consumer().sourceRoot || this.map.root || '.', file)
      }

      get from() {
        return this.file || this.id
      }

      toJSON() {
        let json = {};
        for (let name of ['hasBOM', 'css', 'file', 'id']) {
          if (this[name] != null) {
            json[name] = this[name];
          }
        }
        if (this.map) {
          json.map = { ...this.map };
          if (json.map.consumerCache) {
            json.map.consumerCache = undefined;
          }
        }
        return json
      }
    }

    var input = Input;
    Input.default = Input;

    if (require$$2 && require$$2.registerInput) {
      require$$2.registerInput(Input);
    }

    let { SourceMapConsumer, SourceMapGenerator } = require$$2;
    let { dirname, resolve, relative, sep } = require$$2;
    let { pathToFileURL } = require$$2;



    let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    let pathAvailable = Boolean(dirname && resolve && relative && sep);

    class MapGenerator {
      constructor(stringify, root, opts, cssString) {
        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
        this.css = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
      }

      isMap() {
        if (typeof this.opts.map !== 'undefined') {
          return !!this.opts.map
        }
        return this.previous().length > 0
      }

      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk(node => {
              if (node.source && node.source.input.map) {
                let map = node.source.input.map;
                if (!this.previousMaps.includes(map)) {
                  this.previousMaps.push(map);
                }
              }
            });
          } else {
            let input$1 = new input(this.css, this.opts);
            if (input$1.map) this.previousMaps.push(input$1.map);
          }
        }

        return this.previousMaps
      }

      isInline() {
        if (typeof this.mapOpts.inline !== 'undefined') {
          return this.mapOpts.inline
        }

        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== 'undefined' && annotation !== true) {
          return false
        }

        if (this.previous().length) {
          return this.previous().some(i => i.inline)
        }
        return true
      }

      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== 'undefined') {
          return this.mapOpts.sourcesContent
        }
        if (this.previous().length) {
          return this.previous().some(i => i.withContent())
        }
        return true
      }

      clearAnnotation() {
        if (this.mapOpts.annotation === false) return

        if (this.root) {
          let node;
          for (let i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== 'comment') continue
            if (node.text.indexOf('# sourceMappingURL=') === 0) {
              this.root.removeChild(i);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '');
        }
      }

      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk(node => {
            if (node.source) {
              let from = node.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                let fromUrl = this.usesFileUrls
                  ? this.toFileUrl(from)
                  : this.toUrl(this.path(from));
                this.map.setSourceContent(fromUrl, node.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from
            ? this.toUrl(this.path(this.opts.from))
            : '<no source>';
          this.map.setSourceContent(from, this.css);
        }
      }

      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root = prev.root || dirname(prev.file);
          let map;

          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev.text);
            if (map.sourcesContent) {
              map.sourcesContent = map.sourcesContent.map(() => null);
            }
          } else {
            map = prev.consumer();
          }

          this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
        }
      }

      isAnnotation() {
        if (this.isInline()) {
          return true
        }
        if (typeof this.mapOpts.annotation !== 'undefined') {
          return this.mapOpts.annotation
        }
        if (this.previous().length) {
          return this.previous().some(i => i.annotation)
        }
        return true
      }

      toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString('base64')
        } else {
          return window.btoa(unescape(encodeURIComponent(str)))
        }
      }

      addAnnotation() {
        let content;

        if (this.isInline()) {
          content =
            'data:application/json;base64,' + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === 'string') {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === 'function') {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + '.map';
        }
        let eol = '\n';
        if (this.css.includes('\r\n')) eol = '\r\n';

        this.css += eol + '/*# sourceMappingURL=' + content + ' */';
      }

      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to)
        } else if (this.opts.from) {
          return this.path(this.opts.from)
        } else {
          return 'to.css'
        }
      }

      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev);
        } else {
          this.map = new SourceMapGenerator({ file: this.outputFile() });
          this.map.addMapping({
            source: this.opts.from
              ? this.toUrl(this.path(this.opts.from))
              : '<no source>',
            generated: { line: 1, column: 0 },
            original: { line: 1, column: 0 }
          });
        }

        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.root && this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();

        if (this.isInline()) {
          return [this.css]
        } else {
          return [this.css, this.map]
        }
      }

      path(file) {
        if (file.indexOf('<') === 0) return file
        if (/^\w+:\/\//.test(file)) return file
        if (this.mapOpts.absolute) return file

        let from = this.opts.to ? dirname(this.opts.to) : '.';

        if (typeof this.mapOpts.annotation === 'string') {
          from = dirname(resolve(from, this.mapOpts.annotation));
        }

        file = relative(from, file);
        return file
      }

      toUrl(path) {
        if (sep === '\\') {
          path = path.replace(/\\/g, '/');
        }
        return encodeURI(path).replace(/[#?]/g, encodeURIComponent)
      }

      toFileUrl(path) {
        if (pathToFileURL) {
          return pathToFileURL(path).toString()
        } else {
          throw new Error(
            '`map.absolute` option is not available in this PostCSS build'
          )
        }
      }

      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from)
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node.source.input.from)
        } else {
          return this.toUrl(this.path(node.source.input.from))
        }
      }

      generateString() {
        this.css = '';
        this.map = new SourceMapGenerator({ file: this.outputFile() });

        let line = 1;
        let column = 1;

        let noSource = '<no source>';
        let mapping = {
          source: '',
          generated: { line: 0, column: 0 },
          original: { line: 0, column: 0 }
        };

        let lines, last;
        this.stringify(this.root, (str, node, type) => {
          this.css += str;

          if (node && type !== 'end') {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }

          lines = str.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str.lastIndexOf('\n');
            column = str.length - last;
          } else {
            column += str.length;
          }

          if (node && type !== 'start') {
            let p = node.parent || { raws: {} };
            let childless =
              node.type === 'decl' || (node.type === 'atrule' && !node.nodes);
            if (!childless || node !== p.last || p.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }

      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap()
        } else {
          let result = '';
          this.stringify(this.root, i => {
            result += i;
          });
          return [result]
        }
      }
    }

    var mapGenerator = MapGenerator;

    class Comment extends node_1 {
      constructor(defaults) {
        super(defaults);
        this.type = 'comment';
      }
    }

    var comment = Comment;
    Comment.default = Comment;

    let { isClean: isClean$1, my: my$1 } = symbols;




    let parse$1, Rule$1, AtRule$1, Root$1;

    function cleanSource(nodes) {
      return nodes.map(i => {
        if (i.nodes) i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i
      })
    }

    function markDirtyUp(node) {
      node[isClean$1] = false;
      if (node.proxyOf.nodes) {
        for (let i of node.proxyOf.nodes) {
          markDirtyUp(i);
        }
      }
    }

    class Container extends node_1 {
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this
      }

      each(callback) {
        if (!this.proxyOf.nodes) return undefined
        let iterator = this.getIterator();

        let index, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index], index);
          if (result === false) break

          this.indexes[iterator] += 1;
        }

        delete this.indexes[iterator];
        return result
      }

      walk(callback) {
        return this.each((child, i) => {
          let result;
          try {
            result = callback(child, i);
          } catch (e) {
            throw child.addToError(e)
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }

          return result
        })
      }

      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i) => {
            if (child.type === 'decl') {
              return callback(child, i)
            }
          })
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === 'decl' && prop.test(child.prop)) {
              return callback(child, i)
            }
          })
        }
        return this.walk((child, i) => {
          if (child.type === 'decl' && child.prop === prop) {
            return callback(child, i)
          }
        })
      }

      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;

          return this.walk((child, i) => {
            if (child.type === 'rule') {
              return callback(child, i)
            }
          })
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === 'rule' && selector.test(child.selector)) {
              return callback(child, i)
            }
          })
        }
        return this.walk((child, i) => {
          if (child.type === 'rule' && child.selector === selector) {
            return callback(child, i)
          }
        })
      }

      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i) => {
            if (child.type === 'atrule') {
              return callback(child, i)
            }
          })
        }
        if (name instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === 'atrule' && name.test(child.name)) {
              return callback(child, i)
            }
          })
        }
        return this.walk((child, i) => {
          if (child.type === 'atrule' && child.name === name) {
            return callback(child, i)
          }
        })
      }

      walkComments(callback) {
        return this.walk((child, i) => {
          if (child.type === 'comment') {
            return callback(child, i)
          }
        })
      }

      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes) this.proxyOf.nodes.push(node);
        }

        this.markDirty();

        return this
      }

      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, 'prepend').reverse();
          for (let node of nodes) this.proxyOf.nodes.unshift(node);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }

        this.markDirty();

        return this
      }

      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes) node.cleanRaws(keepBetween);
        }
      }

      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type = existIndex === 0 ? 'prepend' : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
        existIndex = this.index(exist);
        for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);

        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (existIndex <= index) {
            this.indexes[id] = index + nodes.length;
          }
        }

        this.markDirty();

        return this
      }

      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);

        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (existIndex < index) {
            this.indexes[id] = index + nodes.length;
          }
        }

        this.markDirty();

        return this
      }

      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = undefined;
        this.proxyOf.nodes.splice(child, 1);

        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }

        this.markDirty();

        return this
      }

      removeAll() {
        for (let node of this.proxyOf.nodes) node.parent = undefined;
        this.proxyOf.nodes = [];

        this.markDirty();

        return this
      }

      replaceValues(pattern, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }

        this.walkDecls(decl => {
          if (opts.props && !opts.props.includes(decl.prop)) return
          if (opts.fast && !decl.value.includes(opts.fast)) return

          decl.value = decl.value.replace(pattern, callback);
        });

        this.markDirty();

        return this
      }

      every(condition) {
        return this.nodes.every(condition)
      }

      some(condition) {
        return this.nodes.some(condition)
      }

      index(child) {
        if (typeof child === 'number') return child
        if (child.proxyOf) child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child)
      }

      get first() {
        if (!this.proxyOf.nodes) return undefined
        return this.proxyOf.nodes[0]
      }

      get last() {
        if (!this.proxyOf.nodes) return undefined
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
      }

      normalize(nodes, sample) {
        if (typeof nodes === 'string') {
          nodes = cleanSource(parse$1(nodes).nodes);
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i of nodes) {
            if (i.parent) i.parent.removeChild(i, 'ignore');
          }
        } else if (nodes.type === 'root' && this.type !== 'document') {
          nodes = nodes.nodes.slice(0);
          for (let i of nodes) {
            if (i.parent) i.parent.removeChild(i, 'ignore');
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === 'undefined') {
            throw new Error('Value field is missed in node creation')
          } else if (typeof nodes.value !== 'string') {
            nodes.value = String(nodes.value);
          }
          nodes = [new declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule$1(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule$1(nodes)];
        } else if (nodes.text) {
          nodes = [new comment(nodes)];
        } else {
          throw new Error('Unknown node type in node creation')
        }

        let processed = nodes.map(i => {
          /* c8 ignore next */
          if (!i[my$1]) Container.rebuild(i);
          i = i.proxyOf;
          if (i.parent) i.parent.removeChild(i);
          if (i[isClean$1]) markDirtyUp(i);
          if (typeof i.raws.before === 'undefined') {
            if (sample && typeof sample.raws.before !== 'undefined') {
              i.raws.before = sample.raws.before.replace(/\S/g, '');
            }
          }
          i.parent = this.proxyOf;
          return i
        });

        return processed
      }

      getProxyProcessor() {
        return {
          set(node, prop, value) {
            if (node[prop] === value) return true
            node[prop] = value;
            if (prop === 'name' || prop === 'params' || prop === 'selector') {
              node.markDirty();
            }
            return true
          },

          get(node, prop) {
            if (prop === 'proxyOf') {
              return node
            } else if (!node[prop]) {
              return node[prop]
            } else if (
              prop === 'each' ||
              (typeof prop === 'string' && prop.startsWith('walk'))
            ) {
              return (...args) => {
                return node[prop](
                  ...args.map(i => {
                    if (typeof i === 'function') {
                      return (child, index) => i(child.toProxy(), index)
                    } else {
                      return i
                    }
                  })
                )
              }
            } else if (prop === 'every' || prop === 'some') {
              return cb => {
                return node[prop]((child, ...other) =>
                  cb(child.toProxy(), ...other)
                )
              }
            } else if (prop === 'root') {
              return () => node.root().toProxy()
            } else if (prop === 'nodes') {
              return node.nodes.map(i => i.toProxy())
            } else if (prop === 'first' || prop === 'last') {
              return node[prop].toProxy()
            } else {
              return node[prop]
            }
          }
        }
      }

      getIterator() {
        if (!this.lastEach) this.lastEach = 0;
        if (!this.indexes) this.indexes = {};

        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;

        return iterator
      }
    }

    Container.registerParse = dependant => {
      parse$1 = dependant;
    };

    Container.registerRule = dependant => {
      Rule$1 = dependant;
    };

    Container.registerAtRule = dependant => {
      AtRule$1 = dependant;
    };

    Container.registerRoot = dependant => {
      Root$1 = dependant;
    };

    var container = Container;
    Container.default = Container;

    /* c8 ignore start */
    Container.rebuild = node => {
      if (node.type === 'atrule') {
        Object.setPrototypeOf(node, AtRule$1.prototype);
      } else if (node.type === 'rule') {
        Object.setPrototypeOf(node, Rule$1.prototype);
      } else if (node.type === 'decl') {
        Object.setPrototypeOf(node, declaration.prototype);
      } else if (node.type === 'comment') {
        Object.setPrototypeOf(node, comment.prototype);
      } else if (node.type === 'root') {
        Object.setPrototypeOf(node, Root$1.prototype);
      }

      node[my$1] = true;

      if (node.nodes) {
        node.nodes.forEach(child => {
          Container.rebuild(child);
        });
      }
    };

    let LazyResult$2, Processor$2;

    class Document$1 extends container {
      constructor(defaults) {
        // type needs to be passed to super, otherwise child roots won't be normalized correctly
        super({ type: 'document', ...defaults });

        if (!this.nodes) {
          this.nodes = [];
        }
      }

      toResult(opts = {}) {
        let lazy = new LazyResult$2(new Processor$2(), this, opts);

        return lazy.stringify()
      }
    }

    Document$1.registerLazyResult = dependant => {
      LazyResult$2 = dependant;
    };

    Document$1.registerProcessor = dependant => {
      Processor$2 = dependant;
    };

    var document$1 = Document$1;
    Document$1.default = Document$1;

    /* eslint-disable no-console */

    let printed = {};

    var warnOnce = function warnOnce(message) {
      if (printed[message]) return
      printed[message] = true;

      if (typeof console !== 'undefined' && console.warn) {
        console.warn(message);
      }
    };

    class Warning {
      constructor(text, opts = {}) {
        this.type = 'warning';
        this.text = text;

        if (opts.node && opts.node.source) {
          let range = opts.node.rangeBy(opts);
          this.line = range.start.line;
          this.column = range.start.column;
          this.endLine = range.end.line;
          this.endColumn = range.end.column;
        }

        for (let opt in opts) this[opt] = opts[opt];
      }

      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            plugin: this.plugin,
            index: this.index,
            word: this.word
          }).message
        }

        if (this.plugin) {
          return this.plugin + ': ' + this.text
        }

        return this.text
      }
    }

    var warning = Warning;
    Warning.default = Warning;

    class Result {
      constructor(processor, root, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root;
        this.opts = opts;
        this.css = undefined;
        this.map = undefined;
      }

      toString() {
        return this.css
      }

      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }

        let warning$1 = new warning(text, opts);
        this.messages.push(warning$1);

        return warning$1
      }

      warnings() {
        return this.messages.filter(i => i.type === 'warning')
      }

      get content() {
        return this.css
      }
    }

    var result = Result;
    Result.default = Result;

    const SINGLE_QUOTE = "'".charCodeAt(0);
    const DOUBLE_QUOTE = '"'.charCodeAt(0);
    const BACKSLASH = '\\'.charCodeAt(0);
    const SLASH = '/'.charCodeAt(0);
    const NEWLINE = '\n'.charCodeAt(0);
    const SPACE = ' '.charCodeAt(0);
    const FEED = '\f'.charCodeAt(0);
    const TAB = '\t'.charCodeAt(0);
    const CR = '\r'.charCodeAt(0);
    const OPEN_SQUARE = '['.charCodeAt(0);
    const CLOSE_SQUARE = ']'.charCodeAt(0);
    const OPEN_PARENTHESES = '('.charCodeAt(0);
    const CLOSE_PARENTHESES = ')'.charCodeAt(0);
    const OPEN_CURLY = '{'.charCodeAt(0);
    const CLOSE_CURLY = '}'.charCodeAt(0);
    const SEMICOLON = ';'.charCodeAt(0);
    const ASTERISK = '*'.charCodeAt(0);
    const COLON = ':'.charCodeAt(0);
    const AT = '@'.charCodeAt(0);

    const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    const RE_BAD_BRACKET = /.[\n"'(/\\]/;
    const RE_HEX_ESCAPE = /[\da-f]/i;

    var tokenize = function tokenizer(input, options = {}) {
      let css = input.css.valueOf();
      let ignore = options.ignoreErrors;

      let code, next, quote, content, escape;
      let escaped, escapePos, prev, n, currentToken;

      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];

      function position() {
        return pos
      }

      function unclosed(what) {
        throw input.error('Unclosed ' + what, pos)
      }

      function endOfFile() {
        return returned.length === 0 && pos >= length
      }

      function nextToken(opts) {
        if (returned.length) return returned.pop()
        if (pos >= length) return

        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;

        code = css.charCodeAt(pos);

        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (
              code === SPACE ||
              code === NEWLINE ||
              code === TAB ||
              code === CR ||
              code === FEED
            )

            currentToken = ['space', css.slice(pos, next)];
            pos = next - 1;
            break
          }

          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break
          }

          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : '';
            n = css.charCodeAt(pos + 1);
            if (
              prev === 'url' &&
              n !== SINGLE_QUOTE &&
              n !== DOUBLE_QUOTE &&
              n !== SPACE &&
              n !== NEWLINE &&
              n !== TAB &&
              n !== FEED &&
              n !== CR
            ) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(')', next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break
                  } else {
                    unclosed('bracket');
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped)

              currentToken = ['brackets', css.slice(pos, next + 1), pos, next];

              pos = next;
            } else {
              next = css.indexOf(')', pos + 1);
              content = css.slice(pos, next + 1);

              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ['(', '(', pos];
              } else {
                currentToken = ['brackets', content, pos, next];
                pos = next;
              }
            }

            break
          }

          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break
                } else {
                  unclosed('string');
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped)

            currentToken = ['string', css.slice(pos, next + 1), pos, next];
            pos = next;
            break
          }

          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }

            currentToken = ['at-word', css.slice(pos, next + 1), pos, next];

            pos = next;
            break
          }

          case BACKSLASH: {
            next = pos;
            escape = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape = !escape;
            }
            code = css.charCodeAt(next + 1);
            if (
              escape &&
              code !== SLASH &&
              code !== SPACE &&
              code !== NEWLINE &&
              code !== TAB &&
              code !== CR &&
              code !== FEED
            ) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }

            currentToken = ['word', css.slice(pos, next + 1), pos, next];

            pos = next;
            break
          }

          default: {
            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf('*/', pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed('comment');
                }
              }

              currentToken = ['comment', css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }

              currentToken = ['word', css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }

            break
          }
        }

        pos++;
        return currentToken
      }

      function back(token) {
        returned.push(token);
      }

      return {
        back,
        nextToken,
        endOfFile,
        position
      }
    };

    class AtRule extends container {
      constructor(defaults) {
        super(defaults);
        this.type = 'atrule';
      }

      append(...children) {
        if (!this.proxyOf.nodes) this.nodes = [];
        return super.append(...children)
      }

      prepend(...children) {
        if (!this.proxyOf.nodes) this.nodes = [];
        return super.prepend(...children)
      }
    }

    var atRule = AtRule;
    AtRule.default = AtRule;

    container.registerAtRule(AtRule);

    let LazyResult$1, Processor$1;

    class Root extends container {
      constructor(defaults) {
        super(defaults);
        this.type = 'root';
        if (!this.nodes) this.nodes = [];
      }

      removeChild(child, ignore) {
        let index = this.index(child);

        if (!ignore && index === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index].raws.before;
        }

        return super.removeChild(child)
      }

      normalize(child, sample, type) {
        let nodes = super.normalize(child);

        if (sample) {
          if (type === 'prepend') {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node of nodes) {
              node.raws.before = sample.raws.before;
            }
          }
        }

        return nodes
      }

      toResult(opts = {}) {
        let lazy = new LazyResult$1(new Processor$1(), this, opts);
        return lazy.stringify()
      }
    }

    Root.registerLazyResult = dependant => {
      LazyResult$1 = dependant;
    };

    Root.registerProcessor = dependant => {
      Processor$1 = dependant;
    };

    var root = Root;
    Root.default = Root;

    container.registerRoot(Root);

    let list = {
      split(string, separators, last) {
        let array = [];
        let current = '';
        let split = false;

        let func = 0;
        let inQuote = false;
        let prevQuote = '';
        let escape = false;

        for (let letter of string) {
          if (escape) {
            escape = false;
          } else if (letter === '\\') {
            escape = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === '(') {
            func += 1;
          } else if (letter === ')') {
            if (func > 0) func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter)) split = true;
          }

          if (split) {
            if (current !== '') array.push(current.trim());
            current = '';
            split = false;
          } else {
            current += letter;
          }
        }

        if (last || current !== '') array.push(current.trim());
        return array
      },

      space(string) {
        let spaces = [' ', '\n', '\t'];
        return list.split(string, spaces)
      },

      comma(string) {
        return list.split(string, [','], true)
      }
    };

    var list_1 = list;
    list.default = list;

    class Rule extends container {
      constructor(defaults) {
        super(defaults);
        this.type = 'rule';
        if (!this.nodes) this.nodes = [];
      }

      get selectors() {
        return list_1.comma(this.selector)
      }

      set selectors(values) {
        let match = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
        this.selector = values.join(sep);
      }
    }

    var rule = Rule;
    Rule.default = Rule;

    container.registerRule(Rule);

    const SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };

    function findLastWithPosition(tokens) {
      for (let i = tokens.length - 1; i >= 0; i--) {
        let token = tokens[i];
        let pos = token[3] || token[2];
        if (pos) return pos
      }
    }

    class Parser {
      constructor(input) {
        this.input = input;

        this.root = new root();
        this.current = this.root;
        this.spaces = '';
        this.semicolon = false;
        this.customProperty = false;

        this.createTokenizer();
        this.root.source = { input, start: { offset: 0, line: 1, column: 1 } };
      }

      createTokenizer() {
        this.tokenizer = tokenize(this.input);
      }

      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();

          switch (token[0]) {
            case 'space':
              this.spaces += token[1];
              break

            case ';':
              this.freeSemicolon(token);
              break

            case '}':
              this.end(token);
              break

            case 'comment':
              this.comment(token);
              break

            case 'at-word':
              this.atrule(token);
              break

            case '{':
              this.emptyRule(token);
              break

            default:
              this.other(token);
              break
          }
        }
        this.endFile();
      }

      comment(token) {
        let node = new comment();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);

        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = '';
          node.raws.left = text;
          node.raws.right = '';
        } else {
          let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      }

      emptyRule(token) {
        let node = new rule();
        this.init(node, token[2]);
        node.selector = '';
        node.raws.between = '';
        this.current = node;
      }

      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith('--');

        let tokens = [];
        let token = start;
        while (token) {
          type = token[0];
          tokens.push(token);

          if (type === '(' || type === '[') {
            if (!bracket) bracket = token;
            brackets.push(type === '(' ? ')' : ']');
          } else if (customProperty && colon && type === '{') {
            if (!bracket) bracket = token;
            brackets.push('}');
          } else if (brackets.length === 0) {
            if (type === ';') {
              if (colon) {
                this.decl(tokens, customProperty);
                return
              } else {
                break
              }
            } else if (type === '{') {
              this.rule(tokens);
              return
            } else if (type === '}') {
              this.tokenizer.back(tokens.pop());
              end = true;
              break
            } else if (type === ':') {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0) bracket = null;
          }

          token = this.tokenizer.nextToken();
        }

        if (this.tokenizer.endOfFile()) end = true;
        if (brackets.length > 0) this.unclosedBracket(bracket);

        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== 'space' && token !== 'comment') break
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }

      rule(tokens) {
        tokens.pop();

        let node = new rule();
        this.init(node, tokens[0][2]);

        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, 'selector', tokens);
        this.current = node;
      }

      decl(tokens, customProperty) {
        let node = new declaration();
        this.init(node, tokens[0][2]);

        let last = tokens[tokens.length - 1];
        if (last[0] === ';') {
          this.semicolon = true;
          tokens.pop();
        }

        node.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens)
        );

        while (tokens[0][0] !== 'word') {
          if (tokens.length === 1) this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);

        node.prop = '';
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ':' || type === 'space' || type === 'comment') {
            break
          }
          node.prop += tokens.shift()[1];
        }

        node.raws.between = '';

        let token;
        while (tokens.length) {
          token = tokens.shift();

          if (token[0] === ':') {
            node.raws.between += token[1];
            break
          } else {
            if (token[0] === 'word' && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }

        if (node.prop[0] === '_' || node.prop[0] === '*') {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }

        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== 'space' && next !== 'comment') break
          firstSpaces.push(tokens.shift());
        }

        this.precheckMissedSemicolon(tokens);

        for (let i = tokens.length - 1; i >= 0; i--) {
          token = tokens[i];
          if (token[1].toLowerCase() === '!important') {
            node.important = true;
            let string = this.stringFrom(tokens, i);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== ' !important') node.raws.important = string;
            break
          } else if (token[1].toLowerCase() === 'important') {
            let cache = tokens.slice(0);
            let str = '';
            for (let j = i; j > 0; j--) {
              let type = cache[j][0];
              if (str.trim().indexOf('!') === 0 && type !== 'space') {
                break
              }
              str = cache.pop()[1] + str;
            }
            if (str.trim().indexOf('!') === 0) {
              node.important = true;
              node.raws.important = str;
              tokens = cache;
            }
          }

          if (token[0] !== 'space' && token[0] !== 'comment') {
            break
          }
        }

        let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');

        if (hasWord) {
          node.raws.between += firstSpaces.map(i => i[1]).join('');
          firstSpaces = [];
        }
        this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);

        if (node.value.includes(':') && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }

      atrule(token) {
        let node = new atRule();
        node.name = token[1].slice(1);
        if (node.name === '') {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);

        let type;
        let prev;
        let shift;
        let last = false;
        let open = false;
        let params = [];
        let brackets = [];

        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type = token[0];

          if (type === '(' || type === '[') {
            brackets.push(type === '(' ? ')' : ']');
          } else if (type === '{' && brackets.length > 0) {
            brackets.push('}');
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }

          if (brackets.length === 0) {
            if (type === ';') {
              node.source.end = this.getPosition(token[2]);
              this.semicolon = true;
              break
            } else if (type === '{') {
              open = true;
              break
            } else if (type === '}') {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === 'space') {
                  prev = params[--shift];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                }
              }
              this.end(token);
              break
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }

          if (this.tokenizer.endOfFile()) {
            last = true;
            break
          }
        }

        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, 'params', params);
          if (last) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            this.spaces = node.raws.between;
            node.raws.between = '';
          }
        } else {
          node.raws.afterName = '';
          node.params = '';
        }

        if (open) {
          node.nodes = [];
          this.current = node;
        }
      }

      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;

        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        this.spaces = '';

        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }

      endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
      }

      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = '';
          }
        }
      }

      // Helpers

      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          offset,
          line: pos.line,
          column: pos.col
        }
      }

      init(node, offset) {
        this.current.push(node);
        node.source = {
          start: this.getPosition(offset),
          input: this.input
        };
        node.raws.before = this.spaces;
        this.spaces = '';
        if (node.type !== 'comment') this.semicolon = false;
      }

      raw(node, prop, tokens, customProperty) {
        let token, type;
        let length = tokens.length;
        let value = '';
        let clean = true;
        let next, prev;

        for (let i = 0; i < length; i += 1) {
          token = tokens[i];
          type = token[0];
          if (type === 'space' && i === length - 1 && !customProperty) {
            clean = false;
          } else if (type === 'comment') {
            prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
            next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value.slice(-1) === ',') {
                clean = false;
              } else {
                value += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i) => all + i[1], '');
          node.raws[prop] = { value, raw };
        }
        node[prop] = value;
      }

      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = '';
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces
      }

      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = '';
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== 'space' && next !== 'comment') break
          spaces += tokens.shift()[1];
        }
        return spaces
      }

      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = '';
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== 'space') break
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces
      }

      stringFrom(tokens, from) {
        let result = '';
        for (let i = from; i < tokens.length; i++) {
          result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result
      }

      colon(tokens) {
        let brackets = 0;
        let token, type, prev;
        for (let [i, element] of tokens.entries()) {
          token = element;
          type = token[0];

          if (type === '(') {
            brackets += 1;
          }
          if (type === ')') {
            brackets -= 1;
          }
          if (brackets === 0 && type === ':') {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === 'word' && prev[1] === 'progid') {
              continue
            } else {
              return i
            }
          }

          prev = token;
        }
        return false
      }

      // Errors

      unclosedBracket(bracket) {
        throw this.input.error(
          'Unclosed bracket',
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        )
      }

      unknownWord(tokens) {
        throw this.input.error(
          'Unknown word',
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        )
      }

      unexpectedClose(token) {
        throw this.input.error(
          'Unexpected }',
          { offset: token[2] },
          { offset: token[2] + 1 }
        )
      }

      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error('Unclosed block', pos.line, pos.column)
      }

      doubleColon(token) {
        throw this.input.error(
          'Double colon',
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        )
      }

      unnamedAtrule(node, token) {
        throw this.input.error(
          'At-rule without name',
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        )
      }

      precheckMissedSemicolon(/* tokens */) {
        // Hook for Safe Parser
      }

      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false) return

        let founded = 0;
        let token;
        for (let j = colon - 1; j >= 0; j--) {
          token = tokens[j];
          if (token[0] !== 'space') {
            founded += 1;
            if (founded === 2) break
          }
        }
        // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
        // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
        // And because we need it after that one we do +1 to get the next one.
        throw this.input.error(
          'Missed semicolon',
          token[0] === 'word' ? token[3] + 1 : token[2]
        )
      }
    }

    var parser$1 = Parser;

    function parse(css, opts) {
      let input$1 = new input(css, opts);
      let parser = new parser$1(input$1);
      try {
        parser.parse();
      } catch (e) {
        if (process.env.NODE_ENV !== 'production') {
          if (e.name === 'CssSyntaxError' && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e.message +=
                '\nYou tried to parse SCSS with ' +
                'the standard CSS parser; ' +
                'try again with the postcss-scss parser';
            } else if (/\.sass/i.test(opts.from)) {
              e.message +=
                '\nYou tried to parse Sass with ' +
                'the standard CSS parser; ' +
                'try again with the postcss-sass parser';
            } else if (/\.less$/i.test(opts.from)) {
              e.message +=
                '\nYou tried to parse Less with ' +
                'the standard CSS parser; ' +
                'try again with the postcss-less parser';
            }
          }
        }
        throw e
      }

      return parser.root
    }

    var parse_1 = parse;
    parse.default = parse;

    container.registerParse(parse);

    let { isClean, my } = symbols;









    const TYPE_TO_CLASS_NAME = {
      document: 'Document',
      root: 'Root',
      atrule: 'AtRule',
      rule: 'Rule',
      decl: 'Declaration',
      comment: 'Comment'
    };

    const PLUGIN_PROPS = {
      postcssPlugin: true,
      prepare: true,
      Once: true,
      Document: true,
      Root: true,
      Declaration: true,
      Rule: true,
      AtRule: true,
      Comment: true,
      DeclarationExit: true,
      RuleExit: true,
      AtRuleExit: true,
      CommentExit: true,
      RootExit: true,
      DocumentExit: true,
      OnceExit: true
    };

    const NOT_VISITORS = {
      postcssPlugin: true,
      prepare: true,
      Once: true
    };

    const CHILDREN = 0;

    function isPromise(obj) {
      return typeof obj === 'object' && typeof obj.then === 'function'
    }

    function getEvents(node) {
      let key = false;
      let type = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === 'decl') {
        key = node.prop.toLowerCase();
      } else if (node.type === 'atrule') {
        key = node.name.toLowerCase();
      }

      if (key && node.append) {
        return [
          type,
          type + '-' + key,
          CHILDREN,
          type + 'Exit',
          type + 'Exit-' + key
        ]
      } else if (key) {
        return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
      } else if (node.append) {
        return [type, CHILDREN, type + 'Exit']
      } else {
        return [type, type + 'Exit']
      }
    }

    function toStack(node) {
      let events;
      if (node.type === 'document') {
        events = ['Document', CHILDREN, 'DocumentExit'];
      } else if (node.type === 'root') {
        events = ['Root', CHILDREN, 'RootExit'];
      } else {
        events = getEvents(node);
      }

      return {
        node,
        events,
        eventIndex: 0,
        visitors: [],
        visitorIndex: 0,
        iterator: 0
      }
    }

    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
      return node
    }

    let postcss$1 = {};

    class LazyResult {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;

        let root;
        if (
          typeof css === 'object' &&
          css !== null &&
          (css.type === 'root' || css.type === 'document')
        ) {
          root = cleanMarks(css);
        } else if (css instanceof LazyResult || css instanceof result) {
          root = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === 'undefined') opts.map = {};
            if (!opts.map.inline) opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser = parse_1;
          if (opts.syntax) parser = opts.syntax.parse;
          if (opts.parser) parser = opts.parser;
          if (parser.parse) parser = parser.parse;

          try {
            root = parser(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }

          if (root && !root[my]) {
            /* c8 ignore next 2 */
            container.rebuild(root);
          }
        }

        this.result = new result(processor, root, opts);
        this.helpers = { ...postcss$1, result: this.result, postcss: postcss$1 };
        this.plugins = this.processor.plugins.map(plugin => {
          if (typeof plugin === 'object' && plugin.prepare) {
            return { ...plugin, ...plugin.prepare(this.result) }
          } else {
            return plugin
          }
        });
      }

      get [Symbol.toStringTag]() {
        return 'LazyResult'
      }

      get processor() {
        return this.result.processor
      }

      get opts() {
        return this.result.opts
      }

      get css() {
        return this.stringify().css
      }

      get content() {
        return this.stringify().content
      }

      get map() {
        return this.stringify().map
      }

      get root() {
        return this.sync().root
      }

      get messages() {
        return this.sync().messages
      }

      warnings() {
        return this.sync().warnings()
      }

      toString() {
        return this.css
      }

      then(onFulfilled, onRejected) {
        if (process.env.NODE_ENV !== 'production') {
          if (!('from' in this.opts)) {
            warnOnce(
              'Without `from` option PostCSS could generate wrong source map ' +
                'and will not find Browserslist config. Set it to CSS file path ' +
                'or to `undefined` to prevent this warning.'
            );
          }
        }
        return this.async().then(onFulfilled, onRejected)
      }

      catch(onRejected) {
        return this.async().catch(onRejected)
      }

      finally(onFinally) {
        return this.async().then(onFinally, onFinally)
      }

      async() {
        if (this.error) return Promise.reject(this.error)
        if (this.processed) return Promise.resolve(this.result)
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing
      }

      sync() {
        if (this.error) throw this.error
        if (this.processed) return this.result
        this.processed = true;

        if (this.processing) {
          throw this.getAsyncError()
        }

        for (let plugin of this.plugins) {
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            throw this.getAsyncError()
          }
        }

        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            this.walkSync(root);
          }
          if (this.listeners.OnceExit) {
            if (root.type === 'document') {
              for (let subRoot of root.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root);
            }
          }
        }

        return this.result
      }

      stringify() {
        if (this.error) throw this.error
        if (this.stringified) return this.result
        this.stringified = true;

        this.sync();

        let opts = this.result.opts;
        let str = stringify_1;
        if (opts.syntax) str = opts.syntax.stringify;
        if (opts.stringifier) str = opts.stringifier;
        if (str.stringify) str = str.stringify;

        let map = new mapGenerator(str, this.result.root, this.result.opts);
        let data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];

        return this.result
      }

      walkSync(node) {
        node[isClean] = true;
        let events = getEvents(node);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each(child => {
                if (!child[isClean]) this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy())) return
            }
          }
        }
      }

      visitSync(visitors, node) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e) {
            throw this.handleError(e, node.proxyOf)
          }
          if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
            return true
          }
          if (isPromise(promise)) {
            throw this.getAsyncError()
          }
        }
      }

      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === 'object' && plugin.Once) {
            if (this.result.root.type === 'document') {
              let roots = this.result.root.nodes.map(root =>
                plugin.Once(root, this.helpers)
              );

              if (isPromise(roots[0])) {
                return Promise.all(roots)
              }

              return roots
            }

            return plugin.Once(this.result.root, this.helpers)
          } else if (typeof plugin === 'function') {
            return plugin(this.result.root, this.result)
          }
        } catch (error) {
          throw this.handleError(error)
        }
      }

      getAsyncError() {
        throw new Error('Use process(css).then(cb) to work with async plugins')
      }

      handleError(error, node) {
        let plugin = this.result.lastPlugin;
        try {
          if (node) node.addToError(error);
          this.error = error;
          if (error.name === 'CssSyntaxError' && !error.plugin) {
            error.plugin = plugin.postcssPlugin;
            error.setMessage();
          } else if (plugin.postcssVersion) {
            if (process.env.NODE_ENV !== 'production') {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a = pluginVer.split('.');
              let b = runtimeVer.split('.');

              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                // eslint-disable-next-line no-console
                console.error(
                  'Unknown error from PostCSS plugin. Your current PostCSS ' +
                    'version is ' +
                    runtimeVer +
                    ', but ' +
                    pluginName +
                    ' uses ' +
                    pluginVer +
                    '. Perhaps this is the source of the error below.'
                );
              }
            }
          }
        } catch (err) {
          /* c8 ignore next 3 */
          // eslint-disable-next-line no-console
          if (console && console.error) console.error(err);
        }
        return error
      }

      async runAsync() {
        this.plugin = 0;
        for (let i = 0; i < this.plugins.length; i++) {
          let plugin = this.plugins[i];
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error)
            }
          }
        }

        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            let stack = [toStack(root)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e, node)
                }
              }
            }
          }

          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root.type === 'document') {
                  let roots = root.nodes.map(subRoot =>
                    visitor(subRoot, this.helpers)
                  );

                  await Promise.all(roots);
                } else {
                  await visitor(root, this.helpers);
                }
              } catch (e) {
                throw this.handleError(e)
              }
            }
          }
        }

        this.processed = true;
        return this.stringify()
      }

      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type, cb) => {
          if (!this.listeners[type]) this.listeners[type] = [];
          this.listeners[type].push([plugin, cb]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === 'object') {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                    `Try to update PostCSS (${this.processor.version} now).`
                )
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === 'object') {
                  for (let filter in plugin[event]) {
                    if (filter === '*') {
                      add(plugin, event, plugin[event][filter]);
                    } else {
                      add(
                        plugin,
                        event + '-' + filter.toLowerCase(),
                        plugin[event][filter]
                      );
                    }
                  }
                } else if (typeof plugin[event] === 'function') {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }

      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;

        if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
          stack.pop();
          return
        }

        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node.toProxy(), this.helpers)
          } catch (e) {
            throw this.handleError(e, node)
          }
        }

        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while ((child = node.nodes[node.indexes[iterator]])) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }

        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return
          }
        }
        stack.pop();
      }
    }

    LazyResult.registerPostcss = dependant => {
      postcss$1 = dependant;
    };

    var lazyResult = LazyResult;
    LazyResult.default = LazyResult;

    root.registerLazyResult(LazyResult);
    document$1.registerLazyResult(LazyResult);

    class NoWorkResult {
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;

        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = undefined;
        let root;

        let str = stringify_1;
        this.result = new result(this._processor, root, this._opts);
        this.result.css = css;

        let self = this;
        Object.defineProperty(this.result, 'root', {
          get() {
            return self.root
          }
        });

        let map = new mapGenerator(str, root, this._opts, css);
        if (map.isMap()) {
          let [generatedCSS, generatedMap] = map.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        }
      }

      get [Symbol.toStringTag]() {
        return 'NoWorkResult'
      }

      get processor() {
        return this.result.processor
      }

      get opts() {
        return this.result.opts
      }

      get css() {
        return this.result.css
      }

      get content() {
        return this.result.css
      }

      get map() {
        return this.result.map
      }

      get root() {
        if (this._root) {
          return this._root
        }

        let root;
        let parser = parse_1;

        try {
          root = parser(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }

        if (this.error) {
          throw this.error
        } else {
          this._root = root;
          return root
        }
      }

      get messages() {
        return []
      }

      warnings() {
        return []
      }

      toString() {
        return this._css
      }

      then(onFulfilled, onRejected) {
        if (process.env.NODE_ENV !== 'production') {
          if (!('from' in this._opts)) {
            warnOnce(
              'Without `from` option PostCSS could generate wrong source map ' +
                'and will not find Browserslist config. Set it to CSS file path ' +
                'or to `undefined` to prevent this warning.'
            );
          }
        }

        return this.async().then(onFulfilled, onRejected)
      }

      catch(onRejected) {
        return this.async().catch(onRejected)
      }

      finally(onFinally) {
        return this.async().then(onFinally, onFinally)
      }

      async() {
        if (this.error) return Promise.reject(this.error)
        return Promise.resolve(this.result)
      }

      sync() {
        if (this.error) throw this.error
        return this.result
      }
    }

    var noWorkResult = NoWorkResult;
    NoWorkResult.default = NoWorkResult;

    class Processor {
      constructor(plugins = []) {
        this.version = '8.4.20';
        this.plugins = this.normalize(plugins);
      }

      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this
      }

      process(css, opts = {}) {
        if (
          this.plugins.length === 0 &&
          typeof opts.parser === 'undefined' &&
          typeof opts.stringifier === 'undefined' &&
          typeof opts.syntax === 'undefined'
        ) {
          return new noWorkResult(this, css, opts)
        } else {
          return new lazyResult(this, css, opts)
        }
      }

      normalize(plugins) {
        let normalized = [];
        for (let i of plugins) {
          if (i.postcss === true) {
            i = i();
          } else if (i.postcss) {
            i = i.postcss;
          }

          if (typeof i === 'object' && Array.isArray(i.plugins)) {
            normalized = normalized.concat(i.plugins);
          } else if (typeof i === 'object' && i.postcssPlugin) {
            normalized.push(i);
          } else if (typeof i === 'function') {
            normalized.push(i);
          } else if (typeof i === 'object' && (i.parse || i.stringify)) {
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(
                'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
                  'one of the syntax/parser/stringifier options as outlined ' +
                  'in your PostCSS runner documentation.'
              )
            }
          } else {
            throw new Error(i + ' is not a PostCSS plugin')
          }
        }
        return normalized
      }
    }

    var processor = Processor;
    Processor.default = Processor;

    root.registerProcessor(Processor);
    document$1.registerProcessor(Processor);

    function fromJSON(json, inputs) {
      if (Array.isArray(json)) return json.map(n => fromJSON(n))

      let { inputs: ownInputs, ...defaults } = json;
      if (ownInputs) {
        inputs = [];
        for (let input$1 of ownInputs) {
          let inputHydrated = { ...input$1, __proto__: input.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: previousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults.nodes) {
        defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
      }
      if (defaults.source) {
        let { inputId, ...source } = defaults.source;
        defaults.source = source;
        if (inputId != null) {
          defaults.source.input = inputs[inputId];
        }
      }
      if (defaults.type === 'root') {
        return new root(defaults)
      } else if (defaults.type === 'decl') {
        return new declaration(defaults)
      } else if (defaults.type === 'rule') {
        return new rule(defaults)
      } else if (defaults.type === 'comment') {
        return new comment(defaults)
      } else if (defaults.type === 'atrule') {
        return new atRule(defaults)
      } else {
        throw new Error('Unknown node type: ' + json.type)
      }
    }

    var fromJSON_1 = fromJSON;
    fromJSON.default = fromJSON;

    function postcss(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new processor(plugins)
    }

    postcss.plugin = function plugin(name, initializer) {
      let warningPrinted = false;
      function creator(...args) {
        // eslint-disable-next-line no-console
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          // eslint-disable-next-line no-console
          console.warn(
            name +
              ': postcss.plugin was deprecated. Migration guide:\n' +
              'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
          );
          if (process.env.LANG && process.env.LANG.startsWith('cn')) {
            /* c8 ignore next 7 */
            // eslint-disable-next-line no-console
            console.warn(
              name +
                ':  postcss.plugin . :\n' +
                'https://www.w3ctech.com/topic/2226'
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new processor().version;
        return transformer
      }

      let cache;
      Object.defineProperty(creator, 'postcss', {
        get() {
          if (!cache) cache = creator();
          return cache
        }
      });

      creator.process = function (css, processOpts, pluginOpts) {
        return postcss([creator(pluginOpts)]).process(css, processOpts)
      };

      return creator
    };

    postcss.stringify = stringify_1;
    postcss.parse = parse_1;
    postcss.fromJSON = fromJSON_1;
    postcss.list = list_1;

    postcss.comment = defaults => new comment(defaults);
    postcss.atRule = defaults => new atRule(defaults);
    postcss.decl = defaults => new declaration(defaults);
    postcss.rule = defaults => new rule(defaults);
    postcss.root = defaults => new root(defaults);
    postcss.document = defaults => new document$1(defaults);

    postcss.CssSyntaxError = cssSyntaxError;
    postcss.Declaration = declaration;
    postcss.Container = container;
    postcss.Processor = processor;
    postcss.Document = document$1;
    postcss.Comment = comment;
    postcss.Warning = warning;
    postcss.AtRule = atRule;
    postcss.Result = result;
    postcss.Input = input;
    postcss.Rule = rule;
    postcss.Root = root;
    postcss.Node = node_1;

    lazyResult.registerPostcss(postcss);

    var postcss_1 = postcss;
    postcss.default = postcss;

    const { isPlainObject } = isPlainObject_1;


    const { parse: postcssParse } = postcss_1;
    // Tags that can conceivably represent stand-alone media.
    const mediaTags = [
      'img', 'audio', 'video', 'picture', 'svg',
      'object', 'map', 'iframe', 'embed'
    ];
    // Tags that are inherently vulnerable to being used in XSS attacks.
    const vulnerableTags = [ 'script', 'style' ];

    function each(obj, cb) {
      if (obj) {
        Object.keys(obj).forEach(function (key) {
          cb(obj[key], key);
        });
      }
    }

    // Avoid false positives with .__proto__, .hasOwnProperty, etc.
    function has(obj, key) {
      return ({}).hasOwnProperty.call(obj, key);
    }

    // Returns those elements of `a` for which `cb(a)` returns truthy
    function filter(a, cb) {
      const n = [];
      each(a, function(v) {
        if (cb(v)) {
          n.push(v);
        }
      });
      return n;
    }

    function isEmptyObject(obj) {
      for (const key in obj) {
        if (has(obj, key)) {
          return false;
        }
      }
      return true;
    }

    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error('URL missing');
        }

        return (
          part.url +
          (part.w ? ` ${part.w}w` : '') +
          (part.h ? ` ${part.h}h` : '') +
          (part.d ? ` ${part.d}x` : '')
        );
      }).join(', ');
    }

    var sanitizeHtml_1 = sanitizeHtml;

    // A valid attribute name.
    // We use a tolerant definition based on the set of strings defined by
    // html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
    // and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .
    // The characters accepted are ones which can be appended to the attribute
    // name buffer without triggering a parse error:
    //   * unexpected-equals-sign-before-attribute-name
    //   * unexpected-null-character
    //   * unexpected-character-in-attribute-name
    // We exclude the empty string because it's impossible to get to the after
    // attribute name state with an empty attribute name buffer.
    const VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;

    // Ignore the _recursing flag; it's there for recursive
    // invocation as a guard against this exploit:
    // https://github.com/fb55/htmlparser2/issues/105

    function sanitizeHtml(html, options, _recursing) {
      if (html == null) {
        return '';
      }
      if (typeof html === 'number') {
        html = html.toString();
      }

      let result = '';
      // Used for hot swapping the result variable with an empty string in order to "capture" the text written to it.
      let tempResult = '';

      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result.length;
        this.text = ''; // Node inner text
        this.mediaChildren = [];

        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };

        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }

      options = Object.assign({}, sanitizeHtml.defaults, options);
      options.parser = Object.assign({}, htmlParserDefaults, options.parser);

      // vulnerableTags
      vulnerableTags.forEach(function (tag) {
        if (
          options.allowedTags !== false && (options.allowedTags || []).indexOf(tag) > -1 &&
          !options.allowVulnerableTags
        ) {
          console.warn(`\n\n Your \`allowedTags\` option includes, \`${tag}\`, which is inherently\nvulnerable to XSS attacks. Please remove it from \`allowedTags\`.\nOr, to disable this warning, add the \`allowVulnerableTags\` option\nand ensure you are accounting for this risk.\n\n`);
        }
      });

      // Tags that contain something other than HTML, or where discarding
      // the text when the tag is disallowed makes sense for other reasons.
      // If we are not allowing these tags, we should drop their content too.
      // For other tags you would drop the tag but keep its content.
      const nonTextTagsArray = options.nonTextTags || [
        'script',
        'style',
        'textarea',
        'option'
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each(options.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === 'string' && obj.indexOf('*') >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, '.*'));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each(options.allowedClasses, function(classes, tag) {
        // Implicitly allows the class attribute
        if (allowedAttributesMap) {
          if (!has(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push('class');
        }

        allowedClassesMap[tag] = [];
        allowedClassesRegexMap[tag] = [];
        const globRegex = [];
        classes.forEach(function(obj) {
          if (typeof obj === 'string' && obj.indexOf('*') >= 0) {
            globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, '.*'));
          } else if (obj instanceof RegExp) {
            allowedClassesRegexMap[tag].push(obj);
          } else {
            allowedClassesMap[tag].push(obj);
          }
        });
        if (globRegex.length) {
          allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');
        }
      });

      const transformTagsMap = {};
      let transformTagsAll;
      each(options.transformTags, function(transform, tag) {
        let transFun;
        if (typeof transform === 'function') {
          transFun = transform;
        } else if (typeof transform === 'string') {
          transFun = sanitizeHtml.simpleTransform(transform);
        }
        if (tag === '*') {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });

      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;

      initializeState();

      const parser = new lib.Parser({
        onopentag: function(name, attribs) {
          // If `enforceHtmlBoundary` is `true` and this has found the opening
          // `html` tag, reset the state.
          if (options.enforceHtmlBoundary && name === 'html') {
            initializeState();
          }

          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name, attribs);
          stack.push(frame);

          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has(transformTagsMap, name)) {
            transformedTag = transformTagsMap[name](name, attribs);

            frame.attribs = attribs = transformedTag.attribs;

            if (transformedTag.text !== undefined) {
              frame.innerText = transformedTag.text;
            }

            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name, attribs);

            frame.attribs = attribs = transformedTag.attribs;
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }

          if ((options.allowedTags !== false && (options.allowedTags || []).indexOf(name) === -1) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {
            skip = true;
            skipMap[depth] = true;
            if (options.disallowedTagsMode === 'discard') {
              if (nonTextTagsArray.indexOf(name) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
            skipMap[depth] = true;
          }
          depth++;
          if (skip) {
            if (options.disallowedTagsMode === 'discard') {
              // We want the contents but not this tag
              return;
            }
            tempResult = result;
            result = '';
          }
          result += '<' + name;

          if (name === 'script') {
            if (options.allowedScriptHostnames || options.allowedScriptDomains) {
              frame.innerText = '';
            }
          }

          if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {
            each(attribs, function(value, a) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
                // This prevents part of an attribute name in the output from being
                // interpreted as the end of an attribute, or end of a tag.
                delete frame.attribs[a];
                return;
              }
              // check allowedAttributesMap for the element and attribute and modify the value
              // as necessary if there are specific values defined.
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap ||
                (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||
                (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||
                (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||
                (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                for (const o of allowedAttributesMap[name]) {
                  if (isPlainObject(o) && o.name && (o.name === a)) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = '';
                    if (o.multiple === true) {
                      // verify the values that are allowed
                      const splitStrArray = value.split(' ');
                      for (const s of splitStrArray) {
                        if (o.values.indexOf(s) !== -1) {
                          if (newValue === '') {
                            newValue = s;
                          } else {
                            newValue += ' ' + s;
                          }
                        }
                      }
                    } else if (o.values.indexOf(value) >= 0) {
                      // verified an allowed value matches the entire attribute value
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
                  if (naughtyHref(name, value)) {
                    delete frame.attribs[a];
                    return;
                  }
                }

                if (name === 'script' && a === 'src') {

                  let allowed = true;

                  try {
                    const parsed = parseUrl(value);

                    if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                      const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e) {
                    allowed = false;
                  }

                  if (!allowed) {
                    delete frame.attribs[a];
                    return;
                  }
                }

                if (name === 'iframe' && a === 'src') {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);

                    if (parsed.isRelativeUrl) {
                      // default value of allowIframeRelativeUrls is true
                      // unless allowedIframeHostnames or allowedIframeDomains specified
                      allowed = has(options, 'allowIframeRelativeUrls')
                        ? options.allowIframeRelativeUrls
                        : (!options.allowedIframeHostnames && !options.allowedIframeDomains);
                    } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                      const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e) {
                    // Unparseable iframe src
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === 'srcset') {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value) {
                      if (naughtyHref('srcset', value.url)) {
                        value.evil = true;
                      }
                    });
                    parsed = filter(parsed, function(v) {
                      return !v.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a];
                      return;
                    } else {
                      value = stringifySrcset(filter(parsed, function(v) {
                        return !v.evil;
                      }));
                      frame.attribs[a] = value;
                    }
                  } catch (e) {
                    // Unparseable srcset
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === 'class') {
                  const allowedSpecificClasses = allowedClassesMap[name];
                  const allowedWildcardClasses = allowedClassesMap['*'];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ]
                    .concat(allowedSpecificClassesRegex)
                    .filter(function (t) {
                      return t;
                    });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, cjs(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === 'style') {
                  try {
                    const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');
                    const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);

                    value = stringifyStyleAttributes(filteredAST);

                    if (value.length === 0) {
                      delete frame.attribs[a];
                      return;
                    }
                  } catch (e) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                result += ' ' + a;
                if (value && value.length) {
                  result += '="' + escapeHtml(value, true) + '"';
                }
              } else {
                delete frame.attribs[a];
              }
            });
          }
          if (options.selfClosing.indexOf(name) !== -1) {
            result += ' />';
          } else {
            result += '>';
            if (frame.innerText && !hasText && !options.textFilter) {
              result += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result = tempResult + escapeHtml(result);
            tempResult = '';
          }
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;

          if (lastFrame) {
            tag = lastFrame.tag;
            // If inner text was set by transform function then let's use it
            text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;
          }

          if (options.disallowedTagsMode === 'discard' && ((tag === 'script') || (tag === 'style'))) {
            // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing
            // script tags is, by definition, game over for XSS protection, so if that's
            // your concern, don't allow them. The same is essentially true for style tags
            // which have their own collection of XSS vectors.
            result += text;
          } else {
            const escaped = escapeHtml(text, false);
            if (options.textFilter && !addedText) {
              result += options.textFilter(escaped, tag);
            } else if (!addedText) {
              result += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name) {

          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }

          const frame = stack.pop();
          if (!frame) {
            // Do not crash on bad markup
            return;
          }

          if (frame.tag !== name) {
            // Another case of bad markup.
            // Push to stack, so that it will be used in future closing tags.
            stack.push(frame);
            return;
          }

          skipText = options.enforceHtmlBoundary ? name === 'html' : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options.disallowedTagsMode === 'discard') {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result;
            result = '';
          }

          if (transformMap[depth]) {
            name = transformMap[depth];
            delete transformMap[depth];
          }

          if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
            result = result.substr(0, frame.tagPosition);
            return;
          }

          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();

          if (options.selfClosing.indexOf(name) !== -1) {
            // Already output />
            if (skip) {
              result = tempResult;
              tempResult = '';
            }
            return;
          }

          result += '</' + name + '>';
          if (skip) {
            result = tempResult + escapeHtml(result);
            tempResult = '';
          }
          addedText = false;
        }
      }, options.parser);
      parser.write(html);
      parser.end();

      return result;

      function initializeState() {
        result = '';
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }

      function escapeHtml(s, quote) {
        if (typeof (s) !== 'string') {
          s = s + '';
        }
        if (options.parser.decodeEntities) {
          s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          if (quote) {
            s = s.replace(/"/g, '&quot;');
          }
        }
        // TODO: this is inadequate because it will pass `&0;`. This approach
        // will not work, each & must be considered with regard to whether it
        // is followed by a 100% syntactically valid entity or not, and escaped
        // if it is not. If this bothers you, don't set parser.decodeEntities
        // to false. (The default is true.)
        s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
        if (quote) {
          s = s.replace(/"/g, '&quot;');
        }
        return s;
      }

      function naughtyHref(name, href) {
        // Browsers ignore character codes of 32 (space) and below in a surprising
        // number of situations. Start reading here:
        // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab
        // eslint-disable-next-line no-control-regex
        href = href.replace(/[\x00-\x20]+/g, '');
        // Clobber any comments in URLs, which the browser might
        // interpret inside an XML data island, allowing
        // a javascript: URL to be snuck through
        while (true) {
          const firstIndex = href.indexOf('<!--');
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf('-->', firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        // Case insensitive so we don't get faked out by JAVASCRIPT #1
        // Allow more characters after the first so we don't get faked
        // out by certain schemes browsers accept
        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches) {
          // Protocol-relative URL starting with any combination of '/' and '\'
          if (href.match(/^[/\\]{2}/)) {
            return !options.allowProtocolRelative;
          }

          // No scheme
          return false;
        }
        const scheme = matches[1].toLowerCase();

        if (has(options.allowedSchemesByTag, name)) {
          return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
        }

        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
      }

      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, '$1//');
        if (value.startsWith('relative:')) {
          // An attempt to exploit our workaround for base URLs being
          // mandatory for relative URL validation in the WHATWG
          // URL parser, reject it
          throw new Error('relative: exploit attempt');
        }
        // naughtyHref is in charge of whether protocol relative URLs
        // are cool. Here we are concerned just with allowed hostnames and
        // whether to allow relative URLs.
        //
        // Build a placeholder "base URL" against which any reasonable
        // relative URL may be parsed successfully
        let base = 'relative://relative-site';
        for (let i = 0; (i < 100); i++) {
          base += `/${i}`;
        }

        const parsed = new URL(value, base);

        const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      /**
       * Filters user input css properties by allowlisted regex attributes.
       * Modifies the abstractSyntaxTree object.
       *
       * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.
       * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.
       * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).
       * @return {object}                    - The modified tree.
       */
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }

        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;

        // Merge global and tag-specific styles into new AST.
        if (allowedStyles[astRules.selector] && allowedStyles['*']) {
          selectedRule = cjs(
            allowedStyles[astRules.selector],
            allowedStyles['*']
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];
        }

        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }

        return abstractSyntaxTree;
      }

      /**
       * Extracts the style attributes from an AbstractSyntaxTree and formats those
       * values in the inline style attribute format.
       *
       * @param  {AbstractSyntaxTree} filteredAST
       * @return {string}             - Example: "color:yellow;text-align:center !important;font-family:helvetica;"
       */
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes
          .reduce(function(extractedAttributes, attrObject) {
            extractedAttributes.push(
              `${attrObject.prop}:${attrObject.value}${attrObject.important ? ' !important' : ''}`
            );
            return extractedAttributes;
          }, [])
          .join(';');
      }

      /**
        * Filters the existing attributes for the given property. Discards any attributes
        * which don't match the allowlist.
        *
        * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }
        * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.
        * @param  {object} attributeObject          - Object representing the current css property.
        * @property {string} attributeObject.type   - Typically 'declaration'.
        * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.
        * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.
        * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects
        */
      function filterDeclarations(selectedRule) {
        return function (allowedDeclarationsList, attributeObject) {
          // If this property is allowlisted...
          if (has(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });

            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }

      function filterClasses(classes, allowed, allowedGlobs) {
        if (!allowed) {
          // The class attribute is allowed without filtering on this tag
          return classes;
        }
        classes = classes.split(/\s+/);
        return classes.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
            return glob.test(clss);
          });
        }).join(' ');
      }
    }

    // Defaults are accessible to you so that you can use them as a starting point
    // programmatically if you wish

    const htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        'address', 'article', 'aside', 'footer', 'header',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',
        'main', 'nav', 'section',
        // Text content
        'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',
        'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',
        // Inline text semantics
        'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',
        'em', 'i', 'kbd', 'mark', 'q',
        'rb', 'rp', 'rt', 'rtc', 'ruby',
        's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',
        // Table content
        'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',
        'thead', 'tr'
      ],
      disallowedTagsMode: 'discard',
      allowedAttributes: {
        a: [ 'href', 'name', 'target' ],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]
      },
      // Lots of these won't come up by default because we don't allow them
      selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],
      // URL schemes we permit
      allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false
    };

    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
      merge = (merge === undefined) ? true : merge;
      newAttribs = newAttribs || {};

      return function(tagName, attribs) {
        let attrib;
        if (merge) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }

        return {
          tagName: newTagName,
          attribs: attribs
        };
      };
    };

    /**
     * @class CollectionsDetails
     * @description Given a course Id retrieve and possibly update the content of
     * the Canvas Collections Configuration page
     *
     * Process here is
     * - requestConfigPageContents
     *   Ask to get the contents of the page
     * - if successful
     *   - TODO check to see if it's moved from other course (and other checks)
     *      - only if in edit mode
     *   - parse the JSON into a data structure
     *   - TODO retrieve last collection viewed
     * - if not successful (i.e. page doesn't exist)
     *   (only if edit mode)
     *   - initialise config page
     *   - save the config page
     */
    class CollectionsDetails {
        constructor(finishedCallBack, config) {
            this.importedCourseId = null;
            this.finishedCallBack = finishedCallBack;
            this.config = config;
            this.configStore = get_store_value(configStore);
            this.collectionsPageResponse = null;
            this.collections = null;
            this.ccOn = false;
            this.ccPublished = true;
            this.currentHostName = document.location.hostname;
            this.baseApiUrl = `https://${this.currentHostName}/api/v1`;
            // convert courseId to integer - probably unnecessary at this stage
            this["config"]["courseId"] = parseInt(this.config["courseId"]);
            this.requestCollectionsPage();
        }
        /**
         * @function requestConfigPageContents
         * @description Request the contents of the Collections Configuration page
         *
         */
        requestCollectionsPage() {
            wf_fetchData(`${this.baseApiUrl}/courses/${this.config["courseId"]}/pages/canvas-collections-configuration`).then((msg) => {
                if (msg.status === 200) {
                    this.collectionsPageResponse = msg.body;
                    this.parseCollectionsPage();
                }
                else {
                    this.finishedCallBack("no collections config");
                }
            });
        }
        /**
         * @function parseCollectionsPage
         * @description Parse the JSON from the Canvas Collections Configuration page
         * contained in this.collectionsPageResponse.body and store it in this.collections
         */
        parseCollectionsPage() {
            // does this.collectionsPageResponse have a body?
            // e.g.
            // - status: "unauthorized" suggesting student view and can't access it
            // - ?? if there isn't one
            if (!this.collectionsPageResponse.hasOwnProperty("body")) {
                if (this.collectionsPageResponse.hasOwnProperty("status")) {
                    if (this.collectionsPageResponse["status"] === "unauthorized") {
                        this.ccOn = false;
                        this.ccPublished = false;
                        this.finishedCallBack();
                        return null;
                    }
                }
                else {
                    throw new Error("No body in collectionsPageResponse");
                }
            }
            const body = this["collectionsPageResponse"]["body"];
            const parsed = new DOMParser().parseFromString(body, "text/html");
            // Collections configuration is in div.cc_json
            let config = parsed.querySelector("div.cc_json");
            if (!config) {
                throw new Error(`CollectionsDetails: parseCollectionsPage: no div.cc_json found in page`);
            }
            this.collections = JSON.parse(config.innerHTML);
            // decode various fields in the collections
            this.decodeCollections();
            // misc. updates to handle old style collections configuration
            this.updateCollections();
            const courseImages = parsed.querySelector("div.cc-card-images");
            this.checkForImportedCollections(courseImages);
            // initialise the controller etc
            //this.ccOn = this.collections.STATUS === "on";
            this.ccPublished = this.collectionsPageResponse.published;
            this.finishedCallBack();
            // add a COLLECTIONS_ORDER array to the config if it's not there
            if (!this.collections.hasOwnProperty("COLLECTIONS_ORDER")) {
                this.collections["COLLECTIONS_ORDER"] = Object.keys(this.collections["COLLECTIONS"]);
            }
            /*		for (let key in this.collections['MODULES']) {
                // double check that we're not an import from another course
                let courseImages = parsed.querySelector('div.cc-card-images');
                const importConverted = this.checkConvertImport(courseImages);
                // and make it gets saved if there was a change
                if (importConverted) {
                    this.configConverted = importConverted;
                }
                const updatesConverted = this.checkConvertUpdates();
                if ( updatesConverted ) {
                    this.configConverted = updatesConverted;
                }
        
                // also need to decode the collection names in
                // - keys for this.cc_configuration.COLLECTIONS
                // - values in this.cc_configuration.COLLECTIONS_ORDER
                // - values in this.cc_configuration.DEFAULT_ACTIVE_COLLECTION
        
                // decode the keys for this.cc_configuration.COLLECTIONS
                const collections = {};
                for (let key in this.parentController.cc_configuration.COLLECTIONS) {
                    const collection = this.parentController.cc_configuration.COLLECTIONS[key];
                    collections[this.decodeHTML(key)] = collection;
                }
                this.parentController.cc_configuration.COLLECTIONS = collections;
                // decode the values in this.cc_configuration.COLLECTIONS_ORDER
                this.parentController.cc_configuration.COLLECTIONS_ORDER = this.parentController.cc_configuration.COLLECTIONS_ORDER.map((collection) => {
                    return this.decodeHTML(collection);
                });
                // decode the value in the string this.cc_configuration.DEFAULT_ACTIVE_COLLECTION
                this.parentController.cc_configuration.DEFAULT_ACTIVE_COLLECTION = this.decodeHTML(
                    this.parentController.cc_configuration.DEFAULT_ACTIVE_COLLECTION);
            */
        }
        /**
         * @function checkForImportedCollections
         * @param {??} courseImages - DOM element from collections configuration containing ...
         * @description Check courseImages for suggestion that this collections config was imported
         * from another course. If found it defines the courseImages and importedCourseId settings
         * which are used by CanvasCollections to identify a problem
         * The rest of the loading of collections will proceed
         */
        checkForImportedCollections(courseImages) {
            const imagesCourseId = parseInt(courseImages.id.replace("cc-course-", ""));
            if (this.config.courseId !== imagesCourseId) {
                this.courseImages = courseImages;
                this.importedCourseId = imagesCourseId;
                this.convertCourseImagesDiv();
            }
        }
        /**
         * @function convertCourseImagesDiv
         * @description Convert the courseImages div into an array of objects
         *  { moduleId:  the id of the imported module
         *   src:  the img.src that has been updated in the course copy
         *          to match for the current course
         * }
         */
        convertCourseImagesDiv() {
            this.importedImages = [];
            const imgElements = this.courseImages.querySelectorAll("img.cc-moduleImage");
            imgElements.forEach((imgElement) => {
                let moduleId = imgElement.id.replace("cc-moduleImage-", "");
                let moduleName = "<em>not found</em>";
                if (this.collections["MODULES"][parseInt(moduleId)]) {
                    moduleName = this.collections["MODULES"][parseInt(moduleId)].name;
                }
                this.importedImages.push({
                    moduleId: moduleId,
                    moduleName: moduleName,
                    src: imgElement.src,
                    details: false, // flag if have Canvas API data yet
                });
            });
        }
        /**
         * @function initialiseModules
         * @description Create the two module objects
         * - currentModuleDetails - keyed on moduleIds in the current Canvas course
         *     { matched: boolean,  importedModuleId: number ... }
         * - importModuleDetails - keyed on moduleIds in the imported Canvas course
         *         ???
         */
        initialiseModules(currentModules) {
            this.importedModuleIds = Object.keys(this.collections["MODULES"]);
            // set this.currentModuleIds to the id attributes of the currentModules objects
            this.currentModuleIds = currentModules.map((module) => {
                return module.id;
            });
            this.importModuleDetails = {};
            this.currentModuleDetails = {};
            // create importModuleDetails keyed on importedModuleIds
            this.importedModuleIds.forEach((importedModuleId) => {
                this.importModuleDetails[importedModuleId] = {
                    matched: false,
                    importedModuleId: parseInt(importedModuleId),
                    currentModuleId: null,
                };
            });
            // create currentDetails keyed on moduleIds
            this.currentModuleIds.forEach((moduleId) => {
                this.currentModuleDetails[moduleId] = {
                    matched: false,
                    importedModuleId: null,
                    currentModuleId: parseInt(moduleId),
                };
            });
        }
        /**
         * @function matchModuleNames
         * @description loop thru each of the imported modules and try to match the name
         * to a module in the current course
         */
        matchModuleNames(currentModulesList) {
            // create a hash of currentModules keyed on moduleIds
            const currentModules = {};
            currentModulesList.forEach((module) => {
                currentModules[module.id] = module;
            });
            // do the matching
            this.importedModuleIds.forEach((importedModuleId) => {
                let importedModuleName = this.collections["MODULES"][importedModuleId].name;
                this.currentModuleIds.forEach((currentModuleId) => {
                    let currentModuleName = currentModules[currentModuleId].name;
                    if (importedModuleName === currentModuleName) {
                        this.importModuleDetails[importedModuleId].matched = true;
                        this.importModuleDetails[importedModuleId].currentModuleId =
                            currentModuleId;
                        this.currentModuleDetails[currentModuleId].matched = true;
                        this.currentModuleDetails[currentModuleId].importedModuleId =
                            importedModuleId;
                    }
                });
            });
            // calculate the results
            this.numImportsMatched = Object.keys(this.importModuleDetails).reduce((acc, key) => {
                if (this.importModuleDetails[key].matched) {
                    return acc + 1;
                }
                else {
                    return acc;
                }
            }, 0);
            // calculate numCurrentMatched as number of currentModuleDetails where matched is true
            this.numCurrentMatched = Object.keys(this.currentModuleDetails).reduce((acc, key) => {
                if (this.currentModuleDetails[key].matched) {
                    return acc + 1;
                }
                else {
                    return acc;
                }
            }, 0);
        }
        /**
         * @function migrateImportedCollectionsConfiguration
         * @description User has chosen to "proceed" with the migration
         * Tasks include
         * - Modifying the images in collections modules to use the new ones from importedImages
         */
        migrateCollectionsConfiguration() {
            let modules = this.collections["MODULES"];
            // loop through importedModuleDetails
            this.importedModuleIds.forEach((importedModuleId) => {
                if (this.importModuleDetails[importedModuleId].matched) {
                    // there's a matching currentModuleId
                    let currentModuleId = this.importModuleDetails[importedModuleId].currentModuleId;
                    // make a new copy of modules[importedModuleId] and assign it to modules[currentModuleId]
                    modules[currentModuleId] = JSON.parse(JSON.stringify(modules[importedModuleId]));
                    modules[currentModuleId].id = currentModuleId;
                    delete modules[importedModuleId];
                }
            });
            // this.importedImages contains entries for each imported image
            // { moduleId: moduleName: src: ....}
            // this.importModuleDetails is an object keyed on moduleId
            // { matched: boolean; currentModuleId }
            // loop thru each imported image
            this.importedImages.forEach((importedImage) => {
                // if the imported image has been matched to a current module
                if (this.importModuleDetails[importedImage.moduleId].matched) {
                    // get the currentModuleId
                    let currentModuleId = this.importModuleDetails[importedImage.moduleId].currentModuleId;
                    // get the current module
                    let currentModule = modules[currentModuleId];
                    // update the image src
                    if (currentModule && currentModule.hasOwnProperty("image")) {
                        currentModule.image = importedImage.src;
                    }
                }
            });
        }
        getImportedModuleIds() {
            return this.importedModuleIds;
        }
        getImportModuleDetails() {
            return this.importModuleDetails;
        }
        getCurrentModuleDetails() {
            return this.currentModuleDetails;
        }
        getImportedCourseId() {
            return this.importedCourseId;
        }
        getNumCurrentModules() {
            return this.currentModuleIds.length;
        }
        getNumCurrentMatched() {
            return this.numCurrentMatched;
        }
        getNumCurrentNotMatched() {
            return this.getNumCurrentModules() - this.numCurrentMatched;
        }
        getNumImportsMatched() {
            return this.numImportsMatched;
        }
        getNumImportsNotMatched() {
            return this.getNumImportedModules() - this.numImportsMatched;
        }
        getNumImportedModules() {
            return this.importedModuleIds.length;
        }
        getCourseImages() {
            return this.courseImages;
        }
        getImportedImages() {
            return this.importedImages;
        }
        resetImport() {
            this.importedCourseId = null;
            this.importedModuleIds = [];
            this.importModuleDetails = {};
            this.currentModuleIds = [];
            this.currentModuleDetails = {};
            this.numImportsMatched = 0;
            this.numCurrentMatched = 0;
            this.courseImages = [];
            this.importedImages = [];
        }
        /**
         * @method isImportedCollection
         * @returns {boolean} true if this is an imported collection
         */
        isImportedCollection() {
            return this.importedCourseId !== null;
        }
        /**
         * @function decodeCollections
         * @description collections config has been loaded, some fields will contain
         * encoded HTML and other stuff that needs decoding
         */
        decodeCollections() {
            if (this.collections.hasOwnProperty("MODULES")) {
                const modules = this.collections["MODULES"];
                for (let key in modules) {
                    const module = modules[key];
                    module.description = this.decodeHTML(module.description);
                    module.collection = this.decodeHTML(module.collection);
                    module.name = this.decodeHTML(module.name);
                    if (module.hasOwnProperty("iframe") && module.iframe !== "") {
                        module.iframe = this.decodeHTML(module.iframe, true);
                    }
                    if (module.hasOwnProperty("image") && module.image.startsWith("/")) {
                        module.image = `https://${window.location.hostname}${module.image}`;
                    }
                    // decode each of the metadata fields
                    for (let key in module.metadata) {
                        module.metadata[key] = this.decodeHTML(module.metadata[key]);
                    }
                    // need to check the URL for image as the RCE screws with the URL
                    // TODO is this needed?
                    /*if (module.hasOwnProperty('image') && module.image.startsWith('/')) {
                            module.image = `https://${window.location.hostname}${module.image}`;
                        }*/
                }
            }
        }
        /**
         * @function updateCollections
         * @description collectons config has been loaded, but the config file may be
         * old school. Do misc updates, including
         * - any module's collection attribute ==='' is set to null
         * - each module has an attribute 'configVisible' set to false
         * - each module has an attribute 'actualNum' set to ""
         * - each module has a proper date structure
         */
        updateCollections() {
            // modify Collections settings
            if (this.collections.hasOwnProperty("STATUS")) {
                this.collections["VISIBILITY"] = "no-one";
                if (this.collections["STATUS"] === "on") {
                    this.collections["VISIBILITY"] = "all";
                }
                delete this.collections["STATUS"];
            }
            // modify settings for each collection
            if (this.collections.hasOwnProperty("COLLECTIONS")) {
                for (let collectionName in this.collections["COLLECTIONS"]) {
                    const collection = this.collections["COLLECTIONS"][collectionName];
                    if (!collection.hasOwnProperty("unallocated")) {
                        collection.unallocated = false;
                    }
                    ["includePage", "outputPage"].forEach((field) => {
                        if (!collection.hasOwnProperty(field)) {
                            collection[field] = "";
                        }
                    });
                    if (collection.hasOwnProperty("dateHide")) {
                        delete collection.dateHide;
                    }
                }
            }
            // Focus on updates to modules
            if (this.collections.hasOwnProperty("MODULES")) {
                const modules = this.collections["MODULES"];
                for (let key in modules) {
                    const module = modules[key];
                    if (module.collection === "") {
                        module.collection = null;
                    }
                    if (!module.hasOwnProperty("configVisible")) {
                        module.configVisible = false;
                    }
                    if (!module.hasOwnProperty("actualNum")) {
                        module.actualNum = "";
                    }
                    if (!module.hasOwnProperty("label")) {
                        module.label = "";
                    }
                    if (!module.hasOwnProperty("metadata")) {
                        module.metadata = {};
                    }
                    this.handleModuleDate(module);
                    this.removeCanvasModuleDetails(module);
                }
            }
        }
        /**
         * @function removeCanvasModuleDetails
         * @param module - module object
         * @description Remove from the Collections module object any Canvas
         * module fields that shouldn't be here
         *
         * Idea is we want to refresh these (if any) that we'll add later
         * Make sure any old crusty left overs aren't there
         */
        removeCanvasModuleDetails(module) {
            const canvasModuleFields = [
                "position",
                "unlock_at",
                "require_sequential_progress",
                "published",
                "items_url",
                "prerequisite_module_ids",
                "completion_requirements",
            ];
            for (let field of canvasModuleFields) {
                if (module.hasOwnProperty(field)) {
                    delete module[field];
                }
            }
        }
        /**
         * @function handleModuleDate
         * @param module - module object
         * @description module has a date attribute, which may be a string or an object
         * Each module should have a date structure that matches the following
         * {
         *   "label": "", "day": "Monday", "week": "3", "time": "",
         *   "to": {
         *    	"day": "", "week": "", "time": ""
         *	},
         *	"date": 20,
         *	"month": "Mar",
         *	"year": 2023
         * }
         * Make sure it does
         */
        handleModuleDate(module) {
            if (!module.hasOwnProperty("dateHide")) {
                module.dateHide = {
                    day: false,
                    week: false,
                    time: false,
                    calendarDate: false,
                };
            }
            else {
                ["date", "month"].forEach((field) => {
                    if (module.dateHide.hasOwnProperty(field)) {
                        delete module.dateHide[field];
                        module.dateHide.calendarDate = false;
                    }
                });
            }
            if (!module.hasOwnProperty("date")) {
                module.date = {
                    label: "",
                    day: "",
                    week: "",
                    time: "",
                    to: { day: "", week: "", time: "" },
                    date: "",
                    month: "",
                    year: "",
                };
            }
            else {
                // check each of the components
                const components = [
                    "label",
                    "day",
                    "week",
                    "time",
                    "date",
                    "month",
                    "year",
                ];
                for (let i = 0; i < components.length; i++) {
                    const component = components[i];
                    if (!module.date.hasOwnProperty(component)) {
                        module.date[component] = "";
                    }
                }
                if (!module.date.hasOwnProperty("to")) {
                    module.date.to = { day: "", week: "", time: "" };
                }
            }
        }
        /**
         * @function decodeHTML
         * @param html - HTML
         * @returns {string} - removed any HTML encodings and sanitised
         */
        decodeHTML(html, iframeAllowed = false) {
            let txt = document.createElement("textarea");
            txt.innerHTML = html;
            let value = txt.value;
            // do some sanitisation of the HTML https://github.com/apostrophecms/sanitize-html
            let allowedTags = sanitizeHtml_1.defaults.allowedTags;
            let allowedAttributes = {};
            if (iframeAllowed) {
                allowedTags = allowedTags.concat("iframe");
                allowedAttributes = {
                    iframe: ["src", "width", "height", "frameborder", "allowfullscreen"],
                };
            }
            value = sanitizeHtml_1(value, {
                allowedTags: allowedTags,
                allowedAttributes: allowedAttributes,
            });
            return value;
        }
        encodeHTML(html, json = true) {
            let txt = document.createElement("textarea");
            txt.innerHTML = html;
            let value = txt.innerHTML;
            /*		if (json) {
                    // for Canvas JSON, escape the quotes
                    return value.replaceAll(/"/g, '\"');
        
                } else {
                    // for not JSON (i.e. HTML) encode the quotes
                    return value.replaceAll(/"/g, '&quot;');
                } */
            return value;
        }
        /**
         * @function saveCollections(editMode,needToSave)
         * @param {Object} collectionsStore latest detail from collections in memory
         * @param {boolean} editMode true if in edit mode
         * @param {boolean} needToSave true if need to save
         * @param {Function} callBack set needToSave store to false depending on result
         * @description if editMode && needToSave save the collections config page
         * and run callBack with result
         */
        saveCollections(collectionsStore, editMode, needToSave, callBack) {
            if (editMode && needToSave) {
                let callUrl = `/api/v1/courses/${this["config"]["courseId"]}/pages/canvas-collections-configuration`;
                const content = this.generateConfigPageContent(collectionsStore);
                let _body = {
                    wiki_page: {
                        title: "Canvas Collections Configuration",
                        body: content,
                    },
                };
                let method = "put";
                const bodyString = JSON.stringify(_body);
                wf_postData(callUrl, bodyString, this["config"]["csrfToken"], method).then((data) => {
                    callBack(data !== null);
                });
            }
        }
        /**
         * @function generateConfigPageContent
         * @param {Object} collectionsStore latest detail from collections in memory
         * @returns {string} HTML content for the Canvas Collections Configuration page
         * @description Using the latest copy of collections passed in
         * Generate and return the HTML to be added into the Canvas Collections Configuration page
         * including
         * - div.cc-config-explanation
         *   User facing detail about the purpose of the file, a warning, and the time it was
         *   last updated
         * - div.cc_json
         *   Invisible, encoded JSON representation of collections configuration data
         * - div.cc-card-images id="cc-course-<courseId>"
         *   Invisible, collection of img elements for any module collections images that
         *   are in the course files area. Placed here to help with course copy (i.e. Canvas
         *   will update these URLs which Collections will then handle)
         */
        generateConfigPageContent(collectionsStore) {
            // construct the new content for the page
            // - boiler plate description HTML to start
            let content = CONFIGURATION_PAGE_HTML_TEMPLATE;
            /*		if (
                    this.parentController.hasOwnProperty('cc_configuration') &&
                    this.parentController.cc_configuration.hasOwnProperty('MODULES')) { */
            // files URL might be
            // - direct or
            //    https://lms.griffith.edu.au/files/
            // - via the course
            //    https://lms.../courses/12345/files/
            // - or without the hostname starting with /
            const filesUrl = `${window.location.hostname}/files/`;
            const courseFilesUrl = `${window.location.hostname}/courses/${this["config"]["courseId"]}/files/`;
            // loop thru each module in cc_configuration
            // - if it has an image, add an img element to the div.cc-card-images
            //   with the image URL
            let images = "";
            const modules = collectionsStore["MODULES"];
            for (let moduleId in modules) {
                const module = modules[moduleId];
                if (!module.image) {
                    continue;
                }
                // add the hostname to module.image if it doesn't have it
                if (module.image.startsWith("/")) {
                    module.image = `https://${window.location.hostname}${module.image}`;
                }
                // if module has an image and it contains courseFilesUrl
                if (module.image.includes(courseFilesUrl) ||
                    module.image.includes(filesUrl)) {
                    images += `
					<img src="${module.image}" id="cc-moduleImage-${moduleId}" class="cc-moduleImage" />
					`;
                }
            }
            content = content.replace("{{COURSE_IMAGES}}", images);
            //		}
            // - div.json containing
            //   - JSON stringify of this.parentController.cc_configuration
            //   - however, each module needs to have it's description encoded as HTML
            for (let key in modules) {
                const module = modules[key];
                module.description = this.encodeHTML(module.description);
                module.collection = this.encodeHTML(module.collection);
                if (module.hasOwnProperty("iframe") && module.iframe !== "") {
                    module.iframe = this.encodeHTML(module.iframe);
                }
                module.name = this.encodeHTML(module.name);
                // need to encode each of the metadata values
                for (let metaKey in module.metadata) {
                    module.metadata[metaKey] = this.encodeHTML(module.metadata[metaKey]);
                }
            }
            let safeContent = JSON.stringify(this.collections);
            if (safeContent) {
                content = content.replace("{{CONFIG}}", safeContent);
            }
            // need to de-encode the description for the page so that
            // it continues to work normally for live operation
            for (let key in modules) {
                const module = modules[key];
                module.description = this.decodeHTML(module.description, true);
                module.collection = this.decodeHTML(module.collection);
                module.name = this.decodeHTML(module.name);
                if (module.hasOwnProperty("iframe") && module.iframe !== "") {
                    module.iframe = this.decodeHTML(module.iframe, true);
                }
                for (let metaKey in module.metadata) {
                    module.metadata[metaKey] = this.decodeHTML(module.metadata[metaKey]);
                }
            }
            // get the current time as string
            let time = new Date().toLocaleString();
            content = content.replace("{{VISIBLE_TEXT}}", `<p>saved at ${time}</p>`);
            content = content.replace("{{COURSE_ID}}", this["config"]["courseId"]);
            //<div class="cc-card-images" id="cc-course{{COURSE_ID}}" style="display:none"></div>
            return content;
        }
        /**
         * @method saveLastCollectionViewed
         * @description Save the name of the collection that was last viewed in local storage
         */
        saveLastCollectionViewed(collectionName) {
            let hostname = window.location.hostname;
            localStorage.setItem(`cc-${hostname}-${this.config["courseId"]}-last-collection`, collectionName);
        }
        /**
         * @method getCurrentCollection
         * @description Return the name of the collection that should be displayed - current collection
         * This will need to consider
         * - whether the URL specifies a collection using #cc-collection-X
         * - whether a cookie/local storage is set for the collection the user last viewed
         * - or by default using the DEFAULT_ACTIVE_COLLECTION
         */
        getCurrentCollection() {
            const urlHashCollection = this.getUrlHashCollection();
            if (urlHashCollection) {
                return urlHashCollection;
            }
            let hostname = window.location.hostname;
            const lastCollectionViewed = localStorage.getItem(`cc-${hostname}-${this.config["courseId"]}-last-collection`);
            if (lastCollectionViewed) {
                // check that the collection name still exists
                if (this["collections"]["COLLECTIONS"].hasOwnProperty(lastCollectionViewed)) {
                    return lastCollectionViewed;
                }
            }
            // by default return the DEFAULT_ACTIVE_COLLECTION
            const defaultCollection = this["collections"]["DEFAULT_ACTIVE_COLLECTION"];
            if (defaultCollection) {
                return defaultCollection;
            }
            return "";
        }
        /**
         * @method getUrlHashCollectionNum
         * @returns the name of the collection matching the X in #cc-collection-X
         * if it exists, otherwise null
         */
        getUrlHashCollection() {
            let url = new URL(window.location.href);
            // check if there's a cc-collection-\d+ in the hash
            // this is the case for internal navigation within collections
            // i.e. we're on a modules page
            let hash = url.hash;
            if (hash) {
                let checkNum = hash.match(/cc-collection-(\d+)/);
                if (checkNum) {
                    const collectionNum = parseInt(checkNum[1]);
                    if (collectionNum >= 0 &&
                        collectionNum < this.collections["COLLECTIONS_ORDER"].length) {
                        return this.collections["COLLECTIONS_ORDER"][collectionNum];
                    }
                }
            }
            return null;
        }
        /**
         * @method addCanvasModuleData
         * @param canvasData - array of objects containing module data from Canvas
         * @param editMode - boolean
         * @description Perform numerous steps to bring the Canvas and Collections
         * information about modules into alignment
         * - add some canvas data to the collections
         * - if modules exist in Canvas, but not Collections, add them
         * - if module name (and...?) has changed in Canvas, update Collections
         * - for students, set all Collections modules to published to ensure
         *   Collections represents them correctly
         * - remove modules from collection if the Canvas no canvas module with that id
         */
        addCanvasModuleData(canvasModules, editMode) {
            let collectionsModules = this["collections"]["MODULES"];
            // setting published this way will work in editMode
            const fieldsToUpdate = ["published", "name"];
            // loop through the canvas data
            for (let i = 0; i < canvasModules.length; i++) {
                // add the canvasModule to collections if it doesn't exist
                const moduleId = canvasModules[i]["id"];
                if (!collectionsModules.hasOwnProperty(moduleId)) {
                    collectionsModules[moduleId] = this.addNewModule(canvasModules[i]);
                }
                //for (let j = 0; j < fieldsToAdd.length; j++) {
                fieldsToUpdate.forEach((field) => {
                    if (canvasModules[i].hasOwnProperty(field)) {
                        if (collectionsModules.hasOwnProperty(moduleId)) {
                            collectionsModules[moduleId][field] = canvasModules[i][field];
                        }
                    }
                });
            }
            // Loop through all the collections modules checking against canvas module id
            // - if in !editMode set canvas published to true if canvas module exists
            // - otherwise if canvas module doesn't exist, remove that entry from collections
            const canvasModuleIds = canvasModules.map((module) => module.id);
            let changeMade = false;
            for (const moduleId in collectionsModules) {
                if (!editMode) {
                    if (canvasModuleIds.includes(parseInt(moduleId))) {
                        collectionsModules[moduleId].published = true;
                    }
                }
                else {
                    if (!canvasModuleIds.includes(parseInt(moduleId))) {
                        delete collectionsModules[moduleId];
                        changeMade = true;
                    }
                }
            }
            if (changeMade) {
                this.configStore["needToSaveCollections"] = true;
            }
        }
        addNewModule(canvasModule) {
            return {
                name: canvasModule.name,
                id: canvasModule.id,
                published: canvasModule.published,
                description: "",
                collection: "",
                label: "",
                autonum: false,
                actualNum: "",
                configVisible: false,
                num: "",
                metadata: {},
                date: {
                    label: "",
                    day: "",
                    week: "",
                    time: "",
                    to: {
                        day: "",
                        week: "",
                        time: "",
                    },
                },
                dateHide: {
                    day: false,
                    week: false,
                    time: false,
                    month: false,
                    date: false,
                },
                banner: "image",
                image: "",
                imageSize: "",
                includePage: "",
                includePageAfter: false,
                outputPage: "",
                iframe: "",
                bannerColour: "#ffffff",
                engage: true,
                engageText: "Engage",
                fyi: false,
                fyiText: "",
            };
        }
        /**
         * @function initialiseCollectionsConfig
         * @description Called during initialisation when it's found that there is no
         * existing Collections configuration page. At this stage, we may not have the
         * Canvas module information yet. That will be handled with in CanvasCollections
         * - initialise collections details to emulate as if an empty page was loaded
         * - async save the new config page with that information
         */
        initialiseCollectionsConfig() {
            // get the default collections config
            this.collections = DEFAULT_CONFIGURATION_TEMPLATE;
            // by default, the new config page is not published
            this.ccPublished = false;
            // not needed this is done in saveConfigPage
            //const configStr = JSON.stringify(config);
            // create the new config page
            //this.saveCollections(this.collections, true, true, this.completeInitialiseConfigPage.bind(this));
        }
    }
    const DEFAULT_CONFIGURATION_TEMPLATE = {
        VISIBILITY: "teachers",
        DEFAULT_ACTIVE_COLLECTION: "",
        COLLECTIONS: {},
        COLLECTIONS_ORDER: [],
        MODULES: {},
    };
    /**
     * Templates used in the above
     * - CONFIGURATION_PAGE_HTML_TEMPLATE - used to save collections configuration page
     */
    const CONFIGURATION_PAGE_HTML_TEMPLATE = `
<div class="cc-config-explanation">
<div style="float:left;padding:0.5em">
  <img src="https://repository-images.githubusercontent.com/444951314/42343d35-e259-45ae-b74e-b9957222211f"
      alt="canvas-collections logo" width="123" height="92" />
</div>
<div style="padding:0.5em">
  <h3>Canvas Collections Configuration page</h3>
  <p>This page is used to configure <a href="https://djplaner.github.io/canvas-collections/">Canvas Collections</a>.  
  Avoid direct modification to this page, instead use the Canvas Collections configuration interface.  </p>
  {{VISIBLE_TEXT}}
 </div>
 </div>
 <p style="clear:both"></p>
<div class="cc_json" style="display:none">
 {{CONFIG}}
 </div>
<div class="cc-card-images" id="cc-course-{{COURSE_ID}}" style="display:none">
 {{COURSE_IMAGES}}
</div>
`;
    /*const DEFAULT_CONFIGURATION_TEMPLATE = {
        "STATUS": "off",
        "DEFAULT_ACTIVE_COLLECTION": "",
        "COLLECTIONS": {
        },
        "COLLECTIONS_ORDER": [],
        "MODULES": {
        }
    }; */
    /**
     * @function calculateActualNum
     * @description Once we have collections and canvas details calculate the
     * attribute 'actualNum' for each module.
     */
    function calculateActualNum(canvasModules, collectionsModules) {
        let numCalculator = {};
        // loop through each module in the array canvasDetails['courseModules']
        // and set the attribute 'actualNum' to the number of modules in the
        // collection that precede it
        //for (let moduleKey in canvasDetails.courseModules ){
        //canvasDetails.courseModules.forEach((module : {}) => {
        canvasModules.forEach((module) => {
            const moduleId = module["id"];
            // get the collections data about this module
            //const collectionsModule = $collectionsStore["MODULES"][moduleId];
            const collectionsModule = collectionsModules[moduleId];
            if (collectionsModule) {
                if (!collectionsModule.autonum) {
                    // if autoNum is not on, set actualNum to the value of num
                    if (collectionsModule.hasOwnProperty("num")) {
                        collectionsModule.actualNum = collectionsModule.num;
                    }
                }
                else {
                    // autoNum is on
                    if (collectionsModule.hasOwnProperty("label") &&
                        collectionsModule.label !== "") {
                        // there is a valid label that isn't empty
                        const collectionName = collectionsModule.collection;
                        const label = collectionsModule.label;
                        // initialise
                        if (!numCalculator.hasOwnProperty(collectionName)) {
                            numCalculator[collectionName] = {};
                        }
                        if (!numCalculator[collectionName].hasOwnProperty(label)) {
                            numCalculator[collectionName][label] = 0;
                        }
                        numCalculator[collectionName][label] = ++numCalculator[collectionName][label];
                        collectionsModule.actualNum = numCalculator[collectionName][label];
                    }
                }
            }
        });
    }

    let t$4 = {};

    const exec = (command, value = null) => {
      document.execCommand(command, false, value);
    };

    const getTagsRecursive = (element, tags) => {
      tags = tags || (element && element.tagName ? [element.tagName] : []);

      if (element && element.parentNode) {
        element = element.parentNode;
      } else {
        return tags;
      }

      const tag = element.tagName;
      if (element.style && element.getAttribute) {
        [element.style.textAlign || element.getAttribute('align'), element.style.color || tag === 'FONT' && 'forecolor', element.style.backgroundColor && 'backcolor']
          .filter((item) => item)
          .forEach((item) => tags.push(item));
      }

      if (tag === 'DIV') {
        return tags;
      }

      tags.push(tag);

      return getTagsRecursive(element, tags).filter((_tag) => _tag != null);
    };

    const saveRange = (editor) => {
      const documentSelection = document.getSelection();

      t$4.range = null;

      if (documentSelection.rangeCount) {
        let savedRange = t$4.range = documentSelection.getRangeAt(0);
        let range = document.createRange();
        let rangeStart;
        range.selectNodeContents(editor);
        range.setEnd(savedRange.startContainer, savedRange.startOffset);
        rangeStart = (range + '').length;
        t$4.metaRange = {
          start: rangeStart,
          end: rangeStart + (savedRange + '').length
        };
      }
    };
    const restoreRange = (editor) => {
      let metaRange = t$4.metaRange;
      let savedRange = t$4.range;
      let documentSelection = document.getSelection();
      let range;

      if (!savedRange) {
        return;
      }

      if (metaRange && metaRange.start !== metaRange.end) { // Algorithm from http://jsfiddle.net/WeWy7/3/
        let charIndex = 0,
            nodeStack = [editor],
            node,
            foundStart = false,
            stop = false;

        range = document.createRange();

        while (!stop && (node = nodeStack.pop())) {
          if (node.nodeType === 3) {
            let nextCharIndex = charIndex + node.length;
            if (!foundStart && metaRange.start >= charIndex && metaRange.start <= nextCharIndex) {
              range.setStart(node, metaRange.start - charIndex);
              foundStart = true;
            }
            if (foundStart && metaRange.end >= charIndex && metaRange.end <= nextCharIndex) {
              range.setEnd(node, metaRange.end - charIndex);
              stop = true;
            }
            charIndex = nextCharIndex;
          } else {
            let cn = node.childNodes;
            let i = cn.length;

            while (i > 0) {
              i -= 1;
              nodeStack.push(cn[i]);
            }
          }
        }
      }

      documentSelection.removeAllRanges();
      documentSelection.addRange(range || savedRange);
    };

    const cleanHtml = (input) => {
      const html = input.match(/<!--StartFragment-->(.*?)<!--EndFragment-->/);
      let output = html && html[1] || input;
      output = output
        .replace(/\r?\n|\r/g, ' ')
        .replace(/<!--(.*?)-->/g, '')
        .replace(new RegExp('<(/)*(meta|link|span|\\?xml:|st1:|o:|font|w:sdt)(.*?)>', 'gi'), '')
        .replace(/<!\[if !supportLists\]>(.*?)<!\[endif\]>/gi, '')
        .replace(/style="[^"]*"/gi, '')
        .replace(/style='[^']*'/gi, '')
        .replace(/&nbsp;/gi, ' ')
        .replace(/>(\s+)</g, '><')
        .replace(/class="[^"]*"/gi, '')
        .replace(/class='[^']*'/gi, '')
        .replace(/<[^/].*?>/g, i => i.split(/[ >]/g)[0] + '>')
        .trim();

        output = removeBadTags(output);
        return output;
    };

    const unwrap = (wrapper) => {
    	const docFrag = document.createDocumentFragment();
    	while (wrapper.firstChild) {
    		const child = wrapper.removeChild(wrapper.firstChild);
    		docFrag.appendChild(child);
    	}

    	// replace wrapper with document fragment
    	wrapper.parentNode.replaceChild(docFrag, wrapper);
    };

    const removeBlockTagsRecursive = (elements, tagsToRemove) => {
      Array.from(elements).forEach((item) => {
        if (tagsToRemove.some((tag) => tag === item.tagName.toLowerCase())) {
          if (item.children.length) {
            removeBlockTagsRecursive(item.children, tagsToRemove);
          }
          unwrap(item);
        }
      });
    };

    const getActionBtns = (actions) => {
      return Object.keys(actions).map((action) => actions[action]);
    };

    const getNewActionObj = (actions, userActions = []) => {
        if (userActions && userActions.length) {
          const newActions = {};
          userActions.forEach((action) => {
            if (typeof action === 'string') {
              newActions[action] = Object.assign({}, actions[action]);
            } else if (actions[action.name]) {
              newActions[action.name] = Object.assign(actions[action.name], action);
            } else {
              newActions[action.name] = Object.assign({}, action);
            }
          });

          return newActions;
        } else {
          return actions;
        }
    };

    const removeBadTags = (html) => {
      ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'].forEach((badTag) => {
        html = html.replace(new RegExp(`<${badTag}.*?${badTag}(.*?)>`, 'gi'), '');
      });

      return html;
    };

    const isEditorClick = (target, editorWrapper) => {
      if (target === editorWrapper) {
        return true;
      }
      if (target.parentElement) {
        return isEditorClick(target.parentElement, editorWrapper);
      }
      return false;
    };

    const linkSvg =
    	'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M31.1 48.9l-6.7 6.7c-.8.8-1.6.9-2.1.9s-1.4-.1-2.1-.9L15 50.4c-1.1-1.1-1.1-3.1 0-4.2l6.1-6.1.2-.2 6.5-6.5c-1.2-.6-2.5-.9-3.8-.9-2.3 0-4.6.9-6.3 2.6L11 41.8c-3.5 3.5-3.5 9.2 0 12.7l5.2 5.2c1.7 1.7 4 2.6 6.3 2.6s4.6-.9 6.3-2.6l6.7-6.7c2.5-2.6 3.1-6.7 1.5-10l-5.9 5.9zM38.7 22.5l6.7-6.7c.8-.8 1.6-.9 2.1-.9s1.4.1 2.1.9l5.2 5.2c1.1 1.1 1.1 3.1 0 4.2l-6.1 6.1-.2.2L42 38c1.2.6 2.5.9 3.8.9 2.3 0 4.6-.9 6.3-2.6l6.7-6.7c3.5-3.5 3.5-9.2 0-12.7l-5.2-5.2c-1.7-1.7-4-2.6-6.3-2.6s-4.6.9-6.3 2.6l-6.7 6.7c-2.7 2.7-3.3 6.9-1.7 10.2l6.1-6.1c0 .1 0 .1 0 0z"></path><path d="M44.2 30.5c.2-.2.4-.6.4-.9 0-.3-.1-.6-.4-.9l-2.3-2.3c-.3-.2-.6-.4-.9-.4-.3 0-.6.1-.9.4L25.9 40.6c-.2.2-.4.6-.4.9 0 .3.1.6.4.9l2.3 2.3c.2.2.6.4.9.4.3 0 .6-.1.9-.4l14.2-14.2zM49.9 55.4h-8.5v-5h8.5v-8.9h5.2v8.9h8.5v5h-8.5v8.9h-5.2v-8.9z"></path></svg>';
    const unlinkSvg =
    	'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M30.9 49.1l-6.7 6.7c-.8.8-1.6.9-2.1.9s-1.4-.1-2.1-.9l-5.2-5.2c-1.1-1.1-1.1-3.1 0-4.2l6.1-6.1.2-.2 6.5-6.5c-1.2-.6-2.5-.9-3.8-.9-2.3 0-4.6.9-6.3 2.6L10.8 42c-3.5 3.5-3.5 9.2 0 12.7l5.2 5.2c1.7 1.7 4 2.6 6.3 2.6s4.6-.9 6.3-2.6l6.7-6.7C38 50.5 38.6 46.3 37 43l-6.1 6.1zM38.5 22.7l6.7-6.7c.8-.8 1.6-.9 2.1-.9s1.4.1 2.1.9l5.2 5.2c1.1 1.1 1.1 3.1 0 4.2l-6.1 6.1-.2.2-6.5 6.5c1.2.6 2.5.9 3.8.9 2.3 0 4.6-.9 6.3-2.6l6.7-6.7c3.5-3.5 3.5-9.2 0-12.7l-5.2-5.2c-1.7-1.7-4-2.6-6.3-2.6s-4.6.9-6.3 2.6l-6.7 6.7c-2.7 2.7-3.3 6.9-1.7 10.2l6.1-6.1z"></path><path d="M44.1 30.7c.2-.2.4-.6.4-.9 0-.3-.1-.6-.4-.9l-2.3-2.3c-.2-.2-.6-.4-.9-.4-.3 0-.6.1-.9.4L25.8 40.8c-.2.2-.4.6-.4.9 0 .3.1.6.4.9l2.3 2.3c.2.2.6.4.9.4.3 0 .6-.1.9-.4l14.2-14.2zM41.3 55.8v-5h22.2v5H41.3z"></path></svg>';

    var defaultActions = {
    	viewHtml: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path fill="none" stroke="currentColor" stroke-width="8" stroke-miterlimit="10" d="M26.9 17.9L9 36.2 26.9 54M45 54l17.9-18.3L45 17.9"></path></svg>',
    		title: "View HTML",
    		result: function() {
    			let refs = get_store_value(this.references);
    			let actionObj = get_store_value(this.state).actionObj;
    			let helper = get_store_value(this.helper);

    			helper.showEditor = !helper.showEditor;
    			refs.editor.style.display = helper.showEditor ? "block" : "none";
    			refs.raw.style.display = helper.showEditor ? "none" : "block";
    			if (helper.showEditor) {
    				refs.editor.innerHTML = refs.raw.value;
    			} else {
    				refs.raw.value = refs.editor.innerHTML;
    			}
    			setTimeout(() => {
    				Object.keys(actionObj).forEach(
    					action => (actionObj[action].disabled = !helper.showEditor)
    				);
    				actionObj.viewHtml.disabled = false;
    				actionObj.viewHtml.active = !helper.showEditor;

    				this.state.update(state => {
    					state.actionBtns = getActionBtns(actionObj);
    					state.actionObj = actionObj;
    					return state;
    				});
    			});
    		}
    	},
    	undo: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M61.2 51.2c0-5.1-2.1-9.7-5.4-13.1-3.3-3.3-8-5.4-13.1-5.4H26.1v-12L10.8 36l15.3 15.3V39.1h16.7c3.3 0 6.4 1.3 8.5 3.5 2.2 2.2 3.5 5.2 3.5 8.5h6.4z"></path></svg>',
    		title: "Undo",
    		result: () => exec("undo")
    	},
    	redo: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M10.8 51.2c0-5.1 2.1-9.7 5.4-13.1 3.3-3.3 8-5.4 13.1-5.4H46v-12L61.3 36 45.9 51.3V39.1H29.3c-3.3 0-6.4 1.3-8.5 3.5-2.2 2.2-3.5 5.2-3.5 8.5h-6.5z"></path></svg>',
    		title: "Redo",
    		result: () => exec("redo")
    	},
    	b: {
    		icon: "<b>B</b>",
    		title: "Bold",
    		result: () => exec("bold")
    	},
    	i: {
    		icon: "<i>I</i>",
    		title: "Italic",
    		result: () => exec("italic")
    	},
    	u: {
    		icon: "<u>U</u>",
    		title: "Underline",
    		result: () => exec("underline")
    	},
    	strike: {
    		icon: "<strike>S</strike>",
    		title: "Strike-through",
    		result: () => exec("strikeThrough")
    	},
    	sup: {
    		icon: "A<sup>2</sup>",
    		title: "Superscript",
    		result: () => exec("superscript")
    	},
    	sub: {
    		icon: "A<sub>2</sub>",
    		title: "Subscript",
    		result: () => exec("subscript")
    	},
    	h1: {
    		icon: "<b>H<sub>1</sub></b>",
    		title: "Heading 1",
    		result: () => exec("formatBlock", "<H1>")
    	},
    	h2: {
    		icon: "<b>H<sub>2</sub></b>",
    		title: "Heading 2",
    		result: () => exec("formatBlock", "<H2>")
    	},
    	p: {
    		icon: "&#182;",
    		title: "Paragraph",
    		result: () => exec("formatBlock", "<P>")
    	},
    	blockquote: {
    		icon: "&#8220; &#8221;",
    		title: "Quote",
    		result: () => exec("formatBlock", "<BLOCKQUOTE>")
    	},
    	ol: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M27 14h36v8H27zM27 50h36v8H27zM27 32h36v8H27zM11.8 15.8V22h1.8v-7.8h-1.5l-2.1 1 .3 1.3zM12.1 38.5l.7-.6c1.1-1 2.1-2.1 2.1-3.4 0-1.4-1-2.4-2.7-2.4-1.1 0-2 .4-2.6.8l.5 1.3c.4-.3 1-.6 1.7-.6.9 0 1.3.5 1.3 1.1 0 .9-.9 1.8-2.6 3.3l-1 .9V40H15v-1.5h-2.9zM13.3 53.9c1-.4 1.4-1 1.4-1.8 0-1.1-.9-1.9-2.6-1.9-1 0-1.9.3-2.4.6l.4 1.3c.3-.2 1-.5 1.6-.5.8 0 1.2.3 1.2.8 0 .7-.8.9-1.4.9h-.7v1.3h.7c.8 0 1.6.3 1.6 1.1 0 .6-.5 1-1.4 1-.7 0-1.5-.3-1.8-.5l-.4 1.4c.5.3 1.3.6 2.3.6 2 0 3.2-1 3.2-2.4 0-1.1-.8-1.8-1.7-1.9z"></path></svg>',
    		title: "Ordered List",
    		result: () => exec("insertOrderedList")
    	},
    	ul: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M27 14h36v8H27zM27 50h36v8H27zM9 50h9v8H9zM9 32h9v8H9zM9 14h9v8H9zM27 32h36v8H27z"></path></svg>',
    		title: "Unordered List",
    		result: () => exec("insertUnorderedList")
    	},
    	hr: {
    		icon: "&#8213;",
    		title: "Horizontal Line",
    		result: () => exec("insertHorizontalRule")
    	},
    	left: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM9 32h36v8H9z"></path></svg>',
    		title: "Justify left",
    		result: () => exec("justifyLeft")
    	},
    	right: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM27 32h36v8H27z"></path></svg>',
    		title: "Justify right",
    		result: () => exec("justifyRight")
    	},
    	center: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM18 32h36v8H18z"></path></svg>',
    		title: "Justify center",
    		result: () => exec("justifyCenter")
    	},
    	justify: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM9 32h54v8H9z"></path></svg>',
    		title: "Justify full",
    		result: () => exec("justifyFull")
    	},
    	a: {
    		icon: linkSvg,
    		title: "Insert link",
    		result: function() {
    			const actionObj = get_store_value(this.state).actionObj;
    			const refs = get_store_value(this.references);

    			if (actionObj.a.active) {
    				const selection = window.getSelection();
    				const range = document.createRange();
    				range.selectNodeContents(document.getSelection().focusNode);
    				selection.removeAllRanges();
    				selection.addRange(range);
    				exec("unlink");
    				actionObj.a.title = "Insert link";
    				actionObj.a.icon = linkSvg;
    				this.state.update(state => {
    					state.actionBtn = getActionBtns(actionObj);
    					state.actionObj = actionObj;
    					return state;
    				});
    			} else {
    				saveRange(refs.editor);
    				refs.modal.$set({
    					show: true,
    					event: "linkUrl",
    					title: "Insert link",
    					label: "Url"
    				});
    				if (!get_store_value(this.helper).link) {
    					this.helper.update(state => {
    						state.link = true;
    						return state;
    					});
    					refs.modal.$on("linkUrl", event => {
    						restoreRange(refs.editor);
    						exec("createLink", event.detail);
    						actionObj.a.title = "Unlink";
    						actionObj.a.icon = unlinkSvg;

    						this.state.update(state => {
    							state.actionBtn = getActionBtns(actionObj);
    							state.actionObj = actionObj;
    							return state;
    						});
    					});
    				}
    			}
    		}
    	},
    	image: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M64 17v38H8V17h56m8-8H0v54h72V9z"></path><path d="M17.5 22C15 22 13 24 13 26.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5zM16 50h27L29.5 32zM36 36.2l8.9-8.5L60.2 50H45.9S35.6 35.9 36 36.2z"></path></svg>',
    		title: "Image",
    		result: function() {
    			const refs = get_store_value(this.references);
    			saveRange(refs.editor);
    			refs.modal.$set({
    				show: true,
    				event: "imageUrl",
    				title: "Insert image",
    				label: "Url"
    			});
    			if (!get_store_value(this.helper).image) {
    				this.helper.update(state => {
    					state.image = true;
    					return state;
    				});
    				refs.modal.$on("imageUrl", event => {
    					restoreRange(refs.editor);
    					exec("insertImage", event.detail);
    				});
    			}
    		}
    	},
    	forecolor: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M32 15h7.8L56 57.1h-7.9l-4-11.1H27.4l-4 11.1h-7.6L32 15zm-2.5 25.4h12.9L36 22.3h-.2l-6.3 18.1z"></path></svg>',
    		title: "Text color",
    		colorPicker: true,
    		result: function() {
    			showColorPicker.call(this, "foreColor");
    		}
    	},
    	backcolor: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M36.5 22.3l-6.3 18.1H43l-6.3-18.1z"></path><path d="M9 8.9v54.2h54.1V8.9H9zm39.9 48.2L45 46H28.2l-3.9 11.1h-7.6L32.8 15h7.8l16.2 42.1h-7.9z"></path></svg>',
    		title: "Background color",
    		colorPicker: true,
    		result: function() {
    			showColorPicker.call(this, "backColor");
    		}
    	},
    	removeFormat: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M58.2 54.6L52 48.5l3.6-3.6 6.1 6.1 6.4-6.4 3.8 3.8-6.4 6.4 6.1 6.1-3.6 3.6-6.1-6.1-6.4 6.4-3.7-3.8 6.4-6.4zM21.7 52.1H50V57H21.7zM18.8 15.2h34.1v6.4H39.5v24.2h-7.4V21.5H18.8v-6.3z"></path></svg>',
    		title: "Remove format",
    		result: function() {
    			const refs = get_store_value(this.references);
    			const selection = window.getSelection();
    			if (!selection.toString().length) {
    				removeBlockTagsRecursive(
    					refs.editor.children,
    					this.removeFormatTags
    				);
    				const range = document.createRange();
    				range.selectNodeContents(refs.editor);
    				selection.removeAllRanges();
    				selection.addRange(range);
    			}
    			exec("removeFormat");
    			selection.removeAllRanges();
    		}
    	}
    };

    const showColorPicker = function(cmd) {
    	const refs = get_store_value(this.references);
    	saveRange(refs.editor);
    	refs.colorPicker.$set({show: true, event: cmd});
    	if (!get_store_value(this.helper)[cmd]) {
    		this.helper.update(state => {
    			state[cmd] = true;
    			return state;
    		});
    		refs.colorPicker.$on(cmd, event => {
    			let item = event.detail;
    			if (item.modal) {
    				refs.modal.$set({
    					show: true,
    					event: `${cmd}Changed`,
    					title: "Text color",
    					label:
    						cmd === "foreColor" ? "Text color" : "Background color"
    				});
    				const command = cmd;
    				if (!get_store_value(this.helper)[`${command}Modal`]) {
    					get_store_value(this.helper)[`${command}Modal`] = true;
    					refs.modal.$on(`${command}Changed`, event => {
    						let color = event.detail;
    						restoreRange(refs.editor);
    						exec(command, color);
    					});
    				}
    			} else {
    				restoreRange(refs.editor);
    				exec(cmd, item.color);
    			}
    		});
    	}
    };

    /* node_modules\cl-editor\src\helpers\EditorModal.svelte generated by Svelte v3.55.0 */
    const file$o = "node_modules\\cl-editor\\src\\helpers\\EditorModal.svelte";

    // (2:0) {#if show}
    function create_if_block$h(ctx) {
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let span0;
    	let t1;
    	let t2;
    	let form;
    	let label_1;
    	let input;
    	let t3;
    	let span2;
    	let span1;
    	let t4;
    	let t5;
    	let t6;
    	let button0;
    	let t8;
    	let button1;
    	let mounted;
    	let dispose;
    	let if_block = /*error*/ ctx[2] && create_if_block_1$f(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			t1 = text(/*title*/ ctx[3]);
    			t2 = space();
    			form = element("form");
    			label_1 = element("label");
    			input = element("input");
    			t3 = space();
    			span2 = element("span");
    			span1 = element("span");
    			t4 = text(/*label*/ ctx[4]);
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			button0 = element("button");
    			button0.textContent = "Confirm";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Cancel";
    			attr_dev(div0, "class", "cl-editor-overlay svelte-1eyz2ny");
    			add_location(div0, file$o, 2, 2, 64);
    			attr_dev(span0, "class", "modal-title svelte-1eyz2ny");
    			add_location(span0, file$o, 5, 6, 188);
    			attr_dev(input, "name", "text");
    			attr_dev(input, "class", "svelte-1eyz2ny");
    			add_location(input, file$o, 8, 10, 360);
    			attr_dev(span1, "class", "svelte-1eyz2ny");
    			add_location(span1, file$o, 10, 12, 507);
    			attr_dev(span2, "class", "input-info svelte-1eyz2ny");
    			add_location(span2, file$o, 9, 10, 469);
    			attr_dev(label_1, "class", "modal-label svelte-1eyz2ny");
    			toggle_class(label_1, "input-error", /*error*/ ctx[2]);
    			add_location(label_1, file$o, 7, 8, 296);
    			attr_dev(button0, "class", "modal-button modal-submit svelte-1eyz2ny");
    			attr_dev(button0, "type", "submit");
    			add_location(button0, file$o, 16, 8, 665);
    			attr_dev(button1, "class", "modal-button modal-reset svelte-1eyz2ny");
    			attr_dev(button1, "type", "reset");
    			add_location(button1, file$o, 17, 8, 746);
    			add_location(form, file$o, 6, 6, 235);
    			attr_dev(div1, "class", "modal-box svelte-1eyz2ny");
    			add_location(div1, file$o, 4, 4, 158);
    			attr_dev(div2, "class", "cl-editor-modal svelte-1eyz2ny");
    			add_location(div2, file$o, 3, 2, 124);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t1);
    			append_dev(div1, t2);
    			append_dev(div1, form);
    			append_dev(form, label_1);
    			append_dev(label_1, input);
    			/*input_binding*/ ctx[11](input);
    			set_input_value(input, /*text*/ ctx[1]);
    			append_dev(label_1, t3);
    			append_dev(label_1, span2);
    			append_dev(span2, span1);
    			append_dev(span1, t4);
    			append_dev(span2, t5);
    			if (if_block) if_block.m(span2, null);
    			append_dev(form, t6);
    			append_dev(form, button0);
    			append_dev(form, t8);
    			append_dev(form, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*cancel*/ ctx[8], false, false, false),
    					listen_dev(input, "keyup", /*hideError*/ ctx[9], false, false, false),
    					action_destroyer(/*inputType*/ ctx[6].call(null, input)),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[12]),
    					listen_dev(button1, "click", /*cancel*/ ctx[8], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[13]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 8) set_data_dev(t1, /*title*/ ctx[3]);

    			if (dirty & /*text*/ 2 && input.value !== /*text*/ ctx[1]) {
    				set_input_value(input, /*text*/ ctx[1]);
    			}

    			if (dirty & /*label*/ 16) set_data_dev(t4, /*label*/ ctx[4]);

    			if (/*error*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$f(ctx);
    					if_block.c();
    					if_block.m(span2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*error*/ 4) {
    				toggle_class(label_1, "input-error", /*error*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			/*input_binding*/ ctx[11](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(2:0) {#if show}",
    		ctx
    	});

    	return block;
    }

    // (12:12) {#if error}
    function create_if_block_1$f(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Required";
    			attr_dev(span, "class", "msg-error svelte-1eyz2ny");
    			add_location(span, file$o, 12, 12, 564);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(12:12) {#if error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let if_block_anchor;
    	let if_block = /*show*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*show*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorModal', slots, []);
    	let dispatcher = new createEventDispatcher();
    	let { show = false } = $$props;
    	let { text = '' } = $$props;
    	let { event = '' } = $$props;
    	let { title = '' } = $$props;
    	let { label = '' } = $$props;
    	let { error = false } = $$props;
    	let refs = {};

    	const inputType = e => {
    		e.type = event.includes('Color') ? 'color' : 'text';
    	};

    	function confirm() {
    		if (text) {
    			dispatcher(event, text);
    			cancel();
    		} else {
    			$$invalidate(2, error = true);
    			refs.text.focus();
    		}
    	}

    	function cancel() {
    		$$invalidate(0, show = false);
    		$$invalidate(1, text = '');
    		$$invalidate(2, error = false);
    	}

    	function hideError() {
    		$$invalidate(2, error = false);
    	}

    	const writable_props = ['show', 'text', 'event', 'title', 'label', 'error'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorModal> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			refs.text = $$value;
    			$$invalidate(5, refs);
    		});
    	}

    	function input_input_handler() {
    		text = this.value;
    		$$invalidate(1, text);
    	}

    	const submit_handler = event => confirm();

    	$$self.$$set = $$props => {
    		if ('show' in $$props) $$invalidate(0, show = $$props.show);
    		if ('text' in $$props) $$invalidate(1, text = $$props.text);
    		if ('event' in $$props) $$invalidate(10, event = $$props.event);
    		if ('title' in $$props) $$invalidate(3, title = $$props.title);
    		if ('label' in $$props) $$invalidate(4, label = $$props.label);
    		if ('error' in $$props) $$invalidate(2, error = $$props.error);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatcher,
    		show,
    		text,
    		event,
    		title,
    		label,
    		error,
    		refs,
    		inputType,
    		confirm,
    		cancel,
    		hideError
    	});

    	$$self.$inject_state = $$props => {
    		if ('dispatcher' in $$props) dispatcher = $$props.dispatcher;
    		if ('show' in $$props) $$invalidate(0, show = $$props.show);
    		if ('text' in $$props) $$invalidate(1, text = $$props.text);
    		if ('event' in $$props) $$invalidate(10, event = $$props.event);
    		if ('title' in $$props) $$invalidate(3, title = $$props.title);
    		if ('label' in $$props) $$invalidate(4, label = $$props.label);
    		if ('error' in $$props) $$invalidate(2, error = $$props.error);
    		if ('refs' in $$props) $$invalidate(5, refs = $$props.refs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*show, refs*/ 33) {
    			{
    				if (show) {
    					setTimeout(() => {
    						refs.text.focus();
    					});
    				}
    			}
    		}
    	};

    	return [
    		show,
    		text,
    		error,
    		title,
    		label,
    		refs,
    		inputType,
    		confirm,
    		cancel,
    		hideError,
    		event,
    		input_binding,
    		input_input_handler,
    		submit_handler
    	];
    }

    class EditorModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			show: 0,
    			text: 1,
    			event: 10,
    			title: 3,
    			label: 4,
    			error: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorModal",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get show() {
    		return this.$$.ctx[0];
    	}

    	set show(show) {
    		this.$$set({ show });
    		flush();
    	}

    	get text() {
    		return this.$$.ctx[1];
    	}

    	set text(text) {
    		this.$$set({ text });
    		flush();
    	}

    	get event() {
    		return this.$$.ctx[10];
    	}

    	set event(event) {
    		this.$$set({ event });
    		flush();
    	}

    	get title() {
    		return this.$$.ctx[3];
    	}

    	set title(title) {
    		this.$$set({ title });
    		flush();
    	}

    	get label() {
    		return this.$$.ctx[4];
    	}

    	set label(label) {
    		this.$$set({ label });
    		flush();
    	}

    	get error() {
    		return this.$$.ctx[2];
    	}

    	set error(error) {
    		this.$$set({ error });
    		flush();
    	}
    }

    /* node_modules\cl-editor\src\helpers\EditorColorPicker.svelte generated by Svelte v3.55.0 */
    const file$n = "node_modules\\cl-editor\\src\\helpers\\EditorColorPicker.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (4:4) {#each btns as btn}
    function create_each_block$e(ctx) {
    	let button;
    	let t_value = (/*btn*/ ctx[8].text || '') + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*btn*/ ctx[8], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "color-picker-btn svelte-mkzk4s");
    			set_style(button, "background-color", /*btn*/ ctx[8].color);
    			add_location(button, file$n, 4, 4, 176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*btns*/ 2 && t_value !== (t_value = (/*btn*/ ctx[8].text || '') + "")) set_data_dev(t, t_value);

    			if (dirty & /*btns*/ 2) {
    				set_style(button, "background-color", /*btn*/ ctx[8].color);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(4:4) {#each btns as btn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let mounted;
    	let dispose;
    	let each_value = /*btns*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "color-picker-overlay svelte-mkzk4s");
    			add_location(div0, file$n, 1, 2, 51);
    			attr_dev(div1, "class", "color-picker-wrapper svelte-mkzk4s");
    			add_location(div1, file$n, 2, 2, 113);
    			set_style(div2, "display", /*show*/ ctx[0] ? 'block' : 'none');
    			add_location(div2, file$n, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*close*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*btns, selectColor*/ 10) {
    				each_value = /*btns*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*show*/ 1) {
    				set_style(div2, "display", /*show*/ ctx[0] ? 'block' : 'none');
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditorColorPicker', slots, []);
    	const dispatcher = new createEventDispatcher();
    	let { show = false } = $$props;
    	let { btns = [] } = $$props;
    	let { event = '' } = $$props;
    	let { colors = [] } = $$props;

    	function close() {
    		$$invalidate(0, show = false);
    	}

    	function selectColor(btn) {
    		dispatcher(event, btn);
    		close();
    	}

    	const writable_props = ['show', 'btns', 'event', 'colors'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorColorPicker> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (btn, event) => selectColor(btn);

    	$$self.$$set = $$props => {
    		if ('show' in $$props) $$invalidate(0, show = $$props.show);
    		if ('btns' in $$props) $$invalidate(1, btns = $$props.btns);
    		if ('event' in $$props) $$invalidate(4, event = $$props.event);
    		if ('colors' in $$props) $$invalidate(5, colors = $$props.colors);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatcher,
    		show,
    		btns,
    		event,
    		colors,
    		close,
    		selectColor
    	});

    	$$self.$inject_state = $$props => {
    		if ('show' in $$props) $$invalidate(0, show = $$props.show);
    		if ('btns' in $$props) $$invalidate(1, btns = $$props.btns);
    		if ('event' in $$props) $$invalidate(4, event = $$props.event);
    		if ('colors' in $$props) $$invalidate(5, colors = $$props.colors);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*colors*/ 32) {
    			$$invalidate(1, btns = colors.map(color => ({ color })).concat([{ text: '#', modal: true }]));
    		}
    	};

    	return [show, btns, close, selectColor, event, colors, click_handler];
    }

    class EditorColorPicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { show: 0, btns: 1, event: 4, colors: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorColorPicker",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get show() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get btns() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set btns(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get event() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set event(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colors() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const state = (function(name) {
      let state = {
        actionBtns: [],
        actionObj: {}
      };

      const { subscribe, set, update } = writable(state);

      return {
        name,
        set,
        update,
        subscribe
      }
    });

    const createStateStore = state;

    /* node_modules\cl-editor\src\Editor.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1$6 } = globals;
    const file$m = "node_modules\\cl-editor\\src\\Editor.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    // (8:4) {#each $state.actionBtns as action}
    function create_each_block$d(ctx) {
    	let button;
    	let html_tag;
    	let raw_value = /*action*/ ctx[38].icon + "";
    	let t;
    	let button_class_value;
    	let button_title_value;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[24](/*action*/ ctx[38], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			html_tag = new HtmlTag(false);
    			t = space();
    			html_tag.a = t;
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", button_class_value = "cl-button " + (/*action*/ ctx[38].active ? 'active' : '') + " svelte-mfg49m");
    			attr_dev(button, "title", button_title_value = /*action*/ ctx[38].title);
    			button.disabled = button_disabled_value = /*action*/ ctx[38].disabled;
    			add_location(button, file$m, 8, 6, 302);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			html_tag.m(raw_value, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*$state*/ 16 && raw_value !== (raw_value = /*action*/ ctx[38].icon + "")) html_tag.p(raw_value);

    			if (dirty[0] & /*$state*/ 16 && button_class_value !== (button_class_value = "cl-button " + (/*action*/ ctx[38].active ? 'active' : '') + " svelte-mfg49m")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty[0] & /*$state*/ 16 && button_title_value !== (button_title_value = /*action*/ ctx[38].title)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty[0] & /*$state*/ 16 && button_disabled_value !== (button_disabled_value = /*action*/ ctx[38].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(8:4) {#each $state.actionBtns as action}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let textarea;
    	let t2;
    	let editormodal;
    	let t3;
    	let editorcolorpicker;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$state*/ ctx[4].actionBtns;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	let editormodal_props = {};
    	editormodal = new EditorModal({ props: editormodal_props, $$inline: true });
    	/*editormodal_binding*/ ctx[31](editormodal);
    	let editorcolorpicker_props = { colors: /*colors*/ ctx[2] };

    	editorcolorpicker = new EditorColorPicker({
    			props: editorcolorpicker_props,
    			$$inline: true
    		});

    	/*editorcolorpicker_binding*/ ctx[32](editorcolorpicker);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			create_component(editormodal.$$.fragment);
    			t3 = space();
    			create_component(editorcolorpicker.$$.fragment);
    			attr_dev(div0, "class", "cl-actionbar svelte-mfg49m");
    			add_location(div0, file$m, 6, 2, 229);
    			attr_dev(div1, "id", /*contentId*/ ctx[1]);
    			attr_dev(div1, "class", "cl-content svelte-mfg49m");
    			set_style(div1, "height", /*height*/ ctx[0]);
    			attr_dev(div1, "contenteditable", "true");
    			add_location(div1, file$m, 17, 2, 568);
    			attr_dev(textarea, "class", "cl-textarea svelte-mfg49m");
    			set_style(textarea, "max-height", /*height*/ ctx[0]);
    			set_style(textarea, "min-height", /*height*/ ctx[0]);
    			add_location(textarea, file$m, 28, 2, 911);
    			attr_dev(div2, "class", "cl svelte-mfg49m");
    			add_location(div2, file$m, 5, 0, 172);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			/*div1_binding*/ ctx[25](div1);
    			append_dev(div2, t1);
    			append_dev(div2, textarea);
    			/*textarea_binding*/ ctx[30](textarea);
    			append_dev(div2, t2);
    			mount_component(editormodal, div2, null);
    			append_dev(div2, t3);
    			mount_component(editorcolorpicker, div2, null);
    			/*div2_binding*/ ctx[33](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*click_handler*/ ctx[23], false, false, false),
    					listen_dev(div1, "input", /*input_handler*/ ctx[26], false, false, false),
    					listen_dev(div1, "mouseup", /*mouseup_handler*/ ctx[27], false, false, false),
    					listen_dev(div1, "keyup", /*keyup_handler*/ ctx[28], false, false, false),
    					listen_dev(div1, "paste", /*paste_handler*/ ctx[29], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$state, _btnClicked*/ 272) {
    				each_value = /*$state*/ ctx[4].actionBtns;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty[0] & /*contentId*/ 2) {
    				attr_dev(div1, "id", /*contentId*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(div1, "height", /*height*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(textarea, "max-height", /*height*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(textarea, "min-height", /*height*/ ctx[0]);
    			}

    			const editormodal_changes = {};
    			editormodal.$set(editormodal_changes);
    			const editorcolorpicker_changes = {};
    			if (dirty[0] & /*colors*/ 4) editorcolorpicker_changes.colors = /*colors*/ ctx[2];
    			editorcolorpicker.$set(editorcolorpicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editormodal.$$.fragment, local);
    			transition_in(editorcolorpicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editormodal.$$.fragment, local);
    			transition_out(editorcolorpicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			/*div1_binding*/ ctx[25](null);
    			/*textarea_binding*/ ctx[30](null);
    			/*editormodal_binding*/ ctx[31](null);
    			destroy_component(editormodal);
    			/*editorcolorpicker_binding*/ ctx[32](null);
    			destroy_component(editorcolorpicker);
    			/*div2_binding*/ ctx[33](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const editors = [];

    function instance$p($$self, $$props, $$invalidate) {
    	let $references;
    	let $helper;
    	let $state;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Editor', slots, []);
    	let dispatcher = new createEventDispatcher();
    	let { actions = [] } = $$props;
    	let { height = '300px' } = $$props;
    	let { html = '' } = $$props;
    	let { contentId = '' } = $$props;

    	let { colors = [
    		'#ffffff',
    		'#000000',
    		'#eeece1',
    		'#1f497d',
    		'#4f81bd',
    		'#c0504d',
    		'#9bbb59',
    		'#8064a2',
    		'#4bacc6',
    		'#f79646',
    		'#ffff00',
    		'#f2f2f2',
    		'#7f7f7f',
    		'#ddd9c3',
    		'#c6d9f0',
    		'#dbe5f1',
    		'#f2dcdb',
    		'#ebf1dd',
    		'#e5e0ec',
    		'#dbeef3',
    		'#fdeada',
    		'#fff2ca',
    		'#d8d8d8',
    		'#595959',
    		'#c4bd97',
    		'#8db3e2',
    		'#b8cce4',
    		'#e5b9b7',
    		'#d7e3bc',
    		'#ccc1d9',
    		'#b7dde8',
    		'#fbd5b5',
    		'#ffe694',
    		'#bfbfbf',
    		'#3f3f3f',
    		'#938953',
    		'#548dd4',
    		'#95b3d7',
    		'#d99694',
    		'#c3d69b',
    		'#b2a2c7',
    		'#b7dde8',
    		'#fac08f',
    		'#f2c314',
    		'#a5a5a5',
    		'#262626',
    		'#494429',
    		'#17365d',
    		'#366092',
    		'#953734',
    		'#76923c',
    		'#5f497a',
    		'#92cddc',
    		'#e36c09',
    		'#c09100',
    		'#7f7f7f',
    		'#0c0c0c',
    		'#1d1b10',
    		'#0f243e',
    		'#244061',
    		'#632423',
    		'#4f6128',
    		'#3f3151',
    		'#31859b',
    		'#974806',
    		'#7f6000'
    	] } = $$props;

    	let { removeFormatTags = ['h1', 'h2', 'blockquote'] } = $$props;

    	let helper = writable({
    		foreColor: false,
    		backColor: false,
    		foreColorModal: false,
    		backColorModal: false,
    		image: false,
    		link: false,
    		showEditor: true,
    		blurActive: false
    	});

    	validate_store(helper, 'helper');
    	component_subscribe($$self, helper, value => $$invalidate(34, $helper = value));
    	editors.push({});
    	let contextKey = "editor_" + editors.length;
    	let state = createStateStore(contextKey);
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(4, $state = value));
    	let references = writable({});
    	validate_store(references, 'references');
    	component_subscribe($$self, references, value => $$invalidate(3, $references = value));
    	set_store_value(state, $state.actionObj = getNewActionObj(defaultActions, actions), $state);

    	let context = {
    		exec: exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange: saveRange$1,
    		restoreRange: restoreRange$1,
    		helper,
    		references,
    		state,
    		removeFormatTags
    	};

    	setContext(contextKey, context);

    	onMount(() => {
    		set_store_value(state, $state.actionBtns = getActionBtns($state.actionObj), $state);
    		setHtml(html);
    	});

    	function _btnClicked(action) {
    		$references.editor.focus();
    		saveRange$1($references.editor);
    		restoreRange$1($references.editor);
    		action.result.call(context);
    		_handleButtonStatus();
    	}

    	function _handleButtonStatus(clearBtns) {
    		const tags = clearBtns
    		? []
    		: getTagsRecursive(document.getSelection().focusNode);

    		Object.keys($state.actionObj).forEach(action => set_store_value(state, $state.actionObj[action].active = false, $state));
    		tags.forEach(tag => ($state.actionObj[tag.toLowerCase()] || {}).active = true);
    		set_store_value(state, $state.actionBtns = getActionBtns($state.actionObj), $state);
    		state.set($state);
    	}

    	function _onPaste(event) {
    		event.preventDefault();

    		exec$1('insertHTML', event.clipboardData.getData('text/html')
    		? cleanHtml(event.clipboardData.getData('text/html'))
    		: event.clipboardData.getData('text'));
    	}

    	function _onChange(event) {
    		dispatcher('change', event);
    	}

    	function _documentClick(event) {
    		if (!isEditorClick(event.target, $references.editorWrapper) && $helper.blurActive) {
    			dispatcher('blur', event);
    		}

    		set_store_value(helper, $helper.blurActive = true, $helper);
    	}

    	function exec$1(cmd, value) {
    		exec(cmd, value);
    	}

    	function getHtml(sanitize) {
    		return sanitize
    		? removeBadTags($references.editor.innerHTML)
    		: $references.editor.innerHTML;
    	}

    	function getText() {
    		return $references.editor.innerText;
    	}

    	function setHtml(html, sanitize) {
    		const htmlData = sanitize ? removeBadTags(html) : html || '';
    		set_store_value(references, $references.editor.innerHTML = htmlData, $references);
    		set_store_value(references, $references.raw.value = htmlData, $references);
    	}

    	function saveRange$1() {
    		saveRange($references.editor);
    	}

    	function restoreRange$1() {
    		restoreRange($references.editor);
    	}

    	const refs = $references;
    	const writable_props = ['actions', 'height', 'html', 'contentId', 'colors', 'removeFormatTags'];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Editor> was created with unknown prop '${key}'`);
    	});

    	const click_handler = event => _documentClick(event);
    	const click_handler_1 = (action, event) => _btnClicked(action);

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.editor = $$value;
    			references.set($references);
    		});
    	}

    	const input_handler = event => _onChange(event.target.innerHTML);
    	const mouseup_handler = () => _handleButtonStatus();
    	const keyup_handler = () => _handleButtonStatus();
    	const paste_handler = event => _onPaste(event);

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.raw = $$value;
    			references.set($references);
    		});
    	}

    	function editormodal_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.modal = $$value;
    			references.set($references);
    		});
    	}

    	function editorcolorpicker_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.colorPicker = $$value;
    			references.set($references);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.editorWrapper = $$value;
    			references.set($references);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('actions' in $$props) $$invalidate(13, actions = $$props.actions);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('html' in $$props) $$invalidate(14, html = $$props.html);
    		if ('contentId' in $$props) $$invalidate(1, contentId = $$props.contentId);
    		if ('colors' in $$props) $$invalidate(2, colors = $$props.colors);
    		if ('removeFormatTags' in $$props) $$invalidate(15, removeFormatTags = $$props.removeFormatTags);
    	};

    	$$self.$capture_state = () => ({
    		editors,
    		getTagsRecursive,
    		_saveRange: saveRange,
    		_restoreRange: restoreRange,
    		_exec: exec,
    		cleanHtml,
    		getActionBtns,
    		getNewActionObj,
    		removeBadTags,
    		isEditorClick,
    		defaultActions,
    		EditorModal,
    		EditorColorPicker,
    		onMount,
    		createEventDispatcher,
    		setContext,
    		getContext,
    		createStateStore,
    		writable,
    		dispatcher,
    		actions,
    		height,
    		html,
    		contentId,
    		colors,
    		removeFormatTags,
    		helper,
    		contextKey,
    		state,
    		references,
    		context,
    		_btnClicked,
    		_handleButtonStatus,
    		_onPaste,
    		_onChange,
    		_documentClick,
    		exec: exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange: saveRange$1,
    		restoreRange: restoreRange$1,
    		refs,
    		$references,
    		$helper,
    		$state
    	});

    	$$self.$inject_state = $$props => {
    		if ('dispatcher' in $$props) dispatcher = $$props.dispatcher;
    		if ('actions' in $$props) $$invalidate(13, actions = $$props.actions);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('html' in $$props) $$invalidate(14, html = $$props.html);
    		if ('contentId' in $$props) $$invalidate(1, contentId = $$props.contentId);
    		if ('colors' in $$props) $$invalidate(2, colors = $$props.colors);
    		if ('removeFormatTags' in $$props) $$invalidate(15, removeFormatTags = $$props.removeFormatTags);
    		if ('helper' in $$props) $$invalidate(5, helper = $$props.helper);
    		if ('contextKey' in $$props) contextKey = $$props.contextKey;
    		if ('state' in $$props) $$invalidate(6, state = $$props.state);
    		if ('references' in $$props) $$invalidate(7, references = $$props.references);
    		if ('context' in $$props) context = $$props.context;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		height,
    		contentId,
    		colors,
    		$references,
    		$state,
    		helper,
    		state,
    		references,
    		_btnClicked,
    		_handleButtonStatus,
    		_onPaste,
    		_onChange,
    		_documentClick,
    		actions,
    		html,
    		removeFormatTags,
    		exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange$1,
    		restoreRange$1,
    		refs,
    		click_handler,
    		click_handler_1,
    		div1_binding,
    		input_handler,
    		mouseup_handler,
    		keyup_handler,
    		paste_handler,
    		textarea_binding,
    		editormodal_binding,
    		editorcolorpicker_binding,
    		div2_binding
    	];
    }

    class Editor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$p,
    			create_fragment$p,
    			safe_not_equal,
    			{
    				actions: 13,
    				height: 0,
    				html: 14,
    				contentId: 1,
    				colors: 2,
    				removeFormatTags: 15,
    				exec: 16,
    				getHtml: 17,
    				getText: 18,
    				setHtml: 19,
    				saveRange: 20,
    				restoreRange: 21,
    				refs: 22
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Editor",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get actions() {
    		return this.$$.ctx[13];
    	}

    	set actions(actions) {
    		this.$$set({ actions });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[0];
    	}

    	set height(height) {
    		this.$$set({ height });
    		flush();
    	}

    	get html() {
    		return this.$$.ctx[14];
    	}

    	set html(html) {
    		this.$$set({ html });
    		flush();
    	}

    	get contentId() {
    		return this.$$.ctx[1];
    	}

    	set contentId(contentId) {
    		this.$$set({ contentId });
    		flush();
    	}

    	get colors() {
    		return this.$$.ctx[2];
    	}

    	set colors(colors) {
    		this.$$set({ colors });
    		flush();
    	}

    	get removeFormatTags() {
    		return this.$$.ctx[15];
    	}

    	set removeFormatTags(removeFormatTags) {
    		this.$$set({ removeFormatTags });
    		flush();
    	}

    	get exec() {
    		return this.$$.ctx[16];
    	}

    	set exec(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'exec'");
    	}

    	get getHtml() {
    		return this.$$.ctx[17];
    	}

    	set getHtml(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'getHtml'");
    	}

    	get getText() {
    		return this.$$.ctx[18];
    	}

    	set getText(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'getText'");
    	}

    	get setHtml() {
    		return this.$$.ctx[19];
    	}

    	set setHtml(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'setHtml'");
    	}

    	get saveRange() {
    		return this.$$.ctx[20];
    	}

    	set saveRange(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'saveRange'");
    	}

    	get restoreRange() {
    		return this.$$.ctx[21];
    	}

    	set restoreRange(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'restoreRange'");
    	}

    	get refs() {
    		return this.$$.ctx[22];
    	}

    	set refs(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'refs'");
    	}
    }

    /* src\components\Configuration\ModuleGeneralConfiguration.svelte generated by Svelte v3.55.0 */
    const file$l = "src\\components\\Configuration\\ModuleGeneralConfiguration.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    // (117:10) {#each $collectionsStore["COLLECTIONS_ORDER"] as collectionName}
    function create_each_block$c(ctx) {
    	let option;
    	let t_value = /*collectionName*/ ctx[34] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*collectionName*/ ctx[34];
    			option.value = option.__value;
    			add_location(option, file$l, 117, 12, 5171);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$collectionsStore*/ 4 && t_value !== (t_value = /*collectionName*/ ctx[34] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$collectionsStore*/ 4 && option_value_value !== (option_value_value = /*collectionName*/ ctx[34])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(117:10) {#each $collectionsStore[\\\"COLLECTIONS_ORDER\\\"] as collectionName}",
    		ctx
    	});

    	return block;
    }

    // (160:8) {:else}
    function create_else_block_2$2(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyiText");
    			set_style(input, "width", "10rem");
    			input.disabled = true;
    			attr_dev(input, "class", "svelte-1au0op9");
    			add_location(input, file$l, 160, 10, 6698);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyiText);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[15]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, $collectionsStore*/ 5 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyiText")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyiText) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyiText);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(160:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (150:8) {#if $collectionsStore["MODULES"][moduleId].fyi}
    function create_if_block_2$b(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyiText");
    			set_style(input, "width", "10rem");
    			attr_dev(input, "class", "svelte-1au0op9");
    			add_location(input, file$l, 150, 10, 6276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyiText);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[12]),
    					listen_dev(input, "click", /*click_handler*/ ctx[13], false, false, false),
    					listen_dev(input, "keydown", stop_propagation(/*keydown_handler_3*/ ctx[14]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, $collectionsStore*/ 5 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyiText")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyiText) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyiText);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(150:8) {#if $collectionsStore[\\\"MODULES\\\"][moduleId].fyi}",
    		ctx
    	});

    	return block;
    }

    // (234:8) {:else}
    function create_else_block_1$4(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-num");
    			set_style(input, "width", "3rem");
    			add_location(input, file$l, 234, 10, 9398);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].actualNum);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_3*/ ctx[22]),
    					listen_dev(input, "click", /*click_handler_3*/ ctx[23], false, false, false),
    					listen_dev(input, "keydown", stop_propagation(/*keydown_handler_6*/ ctx[24]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, $collectionsStore*/ 5 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-num")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].actualNum) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].actualNum);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(234:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (223:8) {#if $collectionsStore["MODULES"][moduleId].autonum}
    function create_if_block_1$e(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-num");
    			set_style(input, "width", "3rem");
    			input.disabled = true;
    			add_location(input, file$l, 223, 10, 8957);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].actualNum);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_2*/ ctx[19]),
    					listen_dev(input, "click", /*click_handler_2*/ ctx[20], false, false, false),
    					listen_dev(input, "keydown", stop_propagation(/*keydown_handler_5*/ ctx[21]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, $collectionsStore*/ 5 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-num")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].actualNum) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].actualNum);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(223:8) {#if $collectionsStore[\\\"MODULES\\\"][moduleId].autonum}",
    		ctx
    	});

    	return block;
    }

    // (288:8) {:else}
    function create_else_block$a(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "cc-module-config-engageText svelte-1au0op9");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engageText");
    			set_style(input, "width", "10rem");
    			add_location(input, file$l, 288, 10, 11296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engageText);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_5*/ ctx[29]),
    					listen_dev(input, "click", /*click_handler_5*/ ctx[30], false, false, false),
    					listen_dev(input, "keydown", stop_propagation(/*keydown_handler_8*/ ctx[31]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, $collectionsStore*/ 5 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engageText")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engageText) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engageText);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(288:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (280:8) {#if !$collectionsStore["MODULES"][moduleId].engage}
    function create_if_block$g(ctx) {
    	let input;
    	let input_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engageText");
    			set_style(input, "width", "10rem");
    			input.disabled = true;
    			attr_dev(input, "class", "svelte-1au0op9");
    			add_location(input, file$l, 280, 10, 11033);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engageText);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_4*/ ctx[28]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*moduleId, $collectionsStore*/ 5 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engageText")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engageText) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engageText);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(280:8) {#if !$collectionsStore[\\\"MODULES\\\"][moduleId].engage}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div6;
    	let div2;
    	let div1;
    	let span0;
    	let label0;
    	let t0;
    	let label0_for_value;
    	let t1;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[6].configCollection.tooltip + "";
    	let t2;
    	let a0;
    	let i0;
    	let t3;
    	let span1;
    	let select;
    	let option;
    	let select_id_value;
    	let select_value_value;
    	let t5;
    	let div5;
    	let div4;
    	let span3;
    	let label1;
    	let t6;
    	let label1_for_value;
    	let t7;
    	let sl_tooltip1;
    	let div3;
    	let raw1_value = /*HELP*/ ctx[6].configFYI.tooltip + "";
    	let t8;
    	let a1;
    	let i1;
    	let t9;
    	let span2;
    	let input0;
    	let input0_id_value;
    	let t10;
    	let span4;
    	let t11;
    	let div13;
    	let div9;
    	let div8;
    	let span5;
    	let label2;
    	let t12;
    	let label2_for_value;
    	let t13;
    	let sl_tooltip2;
    	let div7;
    	let raw2_value = /*HELP*/ ctx[6].configLabel.tooltip + "";
    	let t14;
    	let a2;
    	let i2;
    	let t15;
    	let span6;
    	let input1;
    	let input1_id_value;
    	let t16;
    	let div12;
    	let div11;
    	let span8;
    	let label3;
    	let t17;
    	let label3_for_value;
    	let t18;
    	let sl_tooltip3;
    	let div10;
    	let raw3_value = /*HELP*/ ctx[6].configAutoNum.tooltip + "";
    	let t19;
    	let a3;
    	let i3;
    	let t20;
    	let span7;
    	let t21;
    	let input2;
    	let input2_checked_value;
    	let input2_id_value;
    	let t22;
    	let span9;
    	let t23;
    	let div18;
    	let div16;
    	let div15;
    	let span11;
    	let label4;
    	let t24;
    	let label4_for_value;
    	let t25;
    	let sl_tooltip4;
    	let div14;
    	let raw4_value = /*HELP*/ ctx[6].configEngage.tooltip + "";
    	let t26;
    	let a4;
    	let i4;
    	let t27;
    	let span10;
    	let input3;
    	let input3_id_value;
    	let t28;
    	let span12;
    	let t29;
    	let div17;
    	let t30;
    	let div20;
    	let label5;
    	let t31;
    	let label5_for_value;
    	let t32;
    	let sl_tooltip5;
    	let div19;
    	let raw5_value = /*HELP*/ ctx[6].configDescription.tooltip + "";
    	let t33;
    	let a5;
    	let i5;
    	let t34;
    	let editor;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyi) return create_if_block_2$b;
    		return create_else_block_2$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].autonum) return create_if_block_1$e;
    		return create_else_block_1$4;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (!/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engage) return create_if_block$g;
    		return create_else_block$a;
    	}

    	let current_block_type_2 = select_block_type_2(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	editor = new Editor({
    			props: {
    				html: /*html*/ ctx[3],
    				contentId: "cc-module-config-" + /*moduleId*/ ctx[0] + "-description-editor"
    			},
    			$$inline: true
    		});

    	editor.$on("change", /*change_handler_1*/ ctx[32]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			label0 = element("label");
    			t0 = text("Collection");
    			t1 = space();
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t2 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t3 = space();
    			span1 = element("span");
    			select = element("select");
    			option = element("option");
    			option.textContent = "Unallocated";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t5 = space();
    			div5 = element("div");
    			div4 = element("div");
    			span3 = element("span");
    			label1 = element("label");
    			t6 = text("FYI");
    			t7 = space();
    			sl_tooltip1 = element("sl-tooltip");
    			div3 = element("div");
    			t8 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t9 = space();
    			span2 = element("span");
    			input0 = element("input");
    			t10 = space();
    			span4 = element("span");
    			if_block0.c();
    			t11 = space();
    			div13 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			span5 = element("span");
    			label2 = element("label");
    			t12 = text("Label");
    			t13 = space();
    			sl_tooltip2 = element("sl-tooltip");
    			div7 = element("div");
    			t14 = space();
    			a2 = element("a");
    			i2 = element("i");
    			t15 = space();
    			span6 = element("span");
    			input1 = element("input");
    			t16 = space();
    			div12 = element("div");
    			div11 = element("div");
    			span8 = element("span");
    			label3 = element("label");
    			t17 = text("Number");
    			t18 = space();
    			sl_tooltip3 = element("sl-tooltip");
    			div10 = element("div");
    			t19 = space();
    			a3 = element("a");
    			i3 = element("i");
    			t20 = space();
    			span7 = element("span");
    			t21 = text("auto:\r\n          ");
    			input2 = element("input");
    			t22 = space();
    			span9 = element("span");
    			if_block1.c();
    			t23 = space();
    			div18 = element("div");
    			div16 = element("div");
    			div15 = element("div");
    			span11 = element("span");
    			label4 = element("label");
    			t24 = text("Engage");
    			t25 = space();
    			sl_tooltip4 = element("sl-tooltip");
    			div14 = element("div");
    			t26 = space();
    			a4 = element("a");
    			i4 = element("i");
    			t27 = space();
    			span10 = element("span");
    			input3 = element("input");
    			t28 = space();
    			span12 = element("span");
    			if_block2.c();
    			t29 = space();
    			div17 = element("div");
    			t30 = space();
    			div20 = element("div");
    			label5 = element("label");
    			t31 = text("Description");
    			t32 = space();
    			sl_tooltip5 = element("sl-tooltip");
    			div19 = element("div");
    			t33 = space();
    			a5 = element("a");
    			i5 = element("i");
    			t34 = space();
    			create_component(editor.$$.fragment);
    			attr_dev(label0, "for", label0_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-collection");
    			add_location(label0, file$l, 95, 8, 4286);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$l, 97, 10, 4390);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$l, 105, 12, 4686);
    			attr_dev(a0, "id", "cc-about-basic-module-collection");
    			attr_dev(a0, "href", /*HELP*/ ctx[6].configCollection.url);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "class", "cc-module-link");
    			add_location(a0, file$l, 98, 10, 4465);
    			set_custom_element_data(sl_tooltip0, "class", "svelte-1au0op9");
    			add_location(sl_tooltip0, file$l, 96, 8, 4366);
    			attr_dev(span0, "class", "cc-module-label svelte-1au0op9");
    			add_location(span0, file$l, 94, 6, 4246);
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$l, 115, 10, 5044);
    			attr_dev(select, "id", select_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-collection");
    			attr_dev(select, "class", "svelte-1au0op9");
    			add_location(select, file$l, 110, 8, 4830);
    			attr_dev(span1, "class", "cc-module-input svelte-1au0op9");
    			add_location(span1, file$l, 109, 6, 4790);
    			attr_dev(div1, "class", "cc-module-form svelte-1au0op9");
    			add_location(div1, file$l, 93, 4, 4210);
    			attr_dev(div2, "class", "cc-module-col svelte-1au0op9");
    			add_location(div2, file$l, 92, 2, 4177);
    			attr_dev(label1, "for", label1_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyi");
    			add_location(label1, file$l, 126, 8, 5415);
    			attr_dev(div3, "slot", "content");
    			add_location(div3, file$l, 128, 10, 5505);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$l, 135, 12, 5736);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			attr_dev(a1, "href", /*HELP*/ ctx[6].configFYI.url);
    			attr_dev(a1, "class", "cc-module-link");
    			add_location(a1, file$l, 129, 10, 5573);
    			set_custom_element_data(sl_tooltip1, "class", "svelte-1au0op9");
    			add_location(sl_tooltip1, file$l, 127, 8, 5481);
    			attr_dev(input0, "type", "checkbox");
    			attr_dev(input0, "id", input0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyi");
    			set_style(input0, "position", "relative");
    			set_style(input0, "top", "-0.25rem");
    			add_location(input0, file$l, 139, 10, 5871);
    			attr_dev(span2, "class", "cc-config-autonum svelte-1au0op9");
    			add_location(span2, file$l, 138, 8, 5827);
    			attr_dev(span3, "class", "cc-module-label svelte-1au0op9");
    			add_location(span3, file$l, 125, 6, 5375);
    			attr_dev(span4, "class", "cc-module-input svelte-1au0op9");
    			add_location(span4, file$l, 148, 6, 6176);
    			attr_dev(div4, "class", "cc-module-form svelte-1au0op9");
    			add_location(div4, file$l, 124, 4, 5339);
    			attr_dev(div5, "class", "cc-module-col svelte-1au0op9");
    			add_location(div5, file$l, 123, 2, 5306);
    			attr_dev(div6, "class", "cc-module-row svelte-1au0op9");
    			add_location(div6, file$l, 91, 0, 4146);
    			attr_dev(label2, "for", label2_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-label");
    			add_location(label2, file$l, 177, 8, 7131);
    			attr_dev(div7, "slot", "content");
    			add_location(div7, file$l, 179, 10, 7253);
    			attr_dev(i2, "class", "icon-question cc-module-icon");
    			add_location(i2, file$l, 181, 12, 7401);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", /*HELP*/ ctx[6].configLabel.url);
    			attr_dev(a2, "rel", "noreferrer");
    			add_location(a2, file$l, 180, 10, 7323);
    			set_custom_element_data(sl_tooltip2, "id", "cc-about-module-label");
    			set_custom_element_data(sl_tooltip2, "class", "svelte-1au0op9");
    			add_location(sl_tooltip2, file$l, 178, 8, 7202);
    			attr_dev(span5, "class", "cc-module-label svelte-1au0op9");
    			add_location(span5, file$l, 176, 6, 7091);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "id", input1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-label");
    			set_style(input1, "width", "10rem");
    			add_location(input1, file$l, 186, 8, 7550);
    			attr_dev(span6, "class", "cc-module-form-input");
    			add_location(span6, file$l, 185, 6, 7505);
    			attr_dev(div8, "class", "cc-module-form svelte-1au0op9");
    			add_location(div8, file$l, 175, 4, 7055);
    			attr_dev(div9, "class", "cc-module-col svelte-1au0op9");
    			add_location(div9, file$l, 174, 2, 7022);
    			attr_dev(label3, "for", label3_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-num");
    			add_location(label3, file$l, 202, 8, 8088);
    			attr_dev(div10, "slot", "content");
    			add_location(div10, file$l, 204, 10, 8181);
    			attr_dev(i3, "class", "icon-question cc-module-icon");
    			add_location(i3, file$l, 206, 12, 8333);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "href", /*HELP*/ ctx[6].configAutoNum.url);
    			attr_dev(a3, "rel", "noreferrer");
    			add_location(a3, file$l, 205, 10, 8253);
    			set_custom_element_data(sl_tooltip3, "class", "svelte-1au0op9");
    			add_location(sl_tooltip3, file$l, 203, 8, 8157);
    			attr_dev(input2, "type", "checkbox");
    			input2.checked = input2_checked_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].autonum;
    			attr_dev(input2, "id", input2_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-autonum");
    			set_style(input2, "position", "relative");
    			set_style(input2, "top", "-0.25rem");
    			add_location(input2, file$l, 211, 10, 8485);
    			attr_dev(span7, "class", "cc-config-autonum svelte-1au0op9");
    			add_location(span7, file$l, 209, 8, 8424);
    			attr_dev(span8, "class", "cc-module-label svelte-1au0op9");
    			add_location(span8, file$l, 201, 6, 8048);
    			attr_dev(span9, "class", "cc-module-form-input");
    			add_location(span9, file$l, 221, 6, 8848);
    			attr_dev(div11, "class", "cc-module-form svelte-1au0op9");
    			add_location(div11, file$l, 200, 4, 8012);
    			attr_dev(div12, "class", "cc-module-col svelte-1au0op9");
    			add_location(div12, file$l, 199, 2, 7979);
    			attr_dev(div13, "class", "cc-module-row svelte-1au0op9");
    			add_location(div13, file$l, 173, 0, 6991);
    			attr_dev(label4, "for", label4_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engage");
    			add_location(label4, file$l, 253, 8, 9992);
    			attr_dev(div14, "slot", "content");
    			add_location(div14, file$l, 255, 10, 10088);
    			attr_dev(i4, "class", "icon-question cc-module-icon");
    			add_location(i4, file$l, 263, 12, 10327);
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "rel", "noreferrer");
    			attr_dev(a4, "href", /*HELP*/ ctx[6].configEngage.url);
    			attr_dev(a4, "class", "cc-module-link");
    			add_location(a4, file$l, 257, 10, 10161);
    			set_custom_element_data(sl_tooltip4, "class", "svelte-1au0op9");
    			add_location(sl_tooltip4, file$l, 254, 8, 10064);
    			attr_dev(input3, "type", "checkbox");
    			attr_dev(input3, "id", input3_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engage");
    			set_style(input3, "position", "relative");
    			set_style(input3, "top", "-0.25rem");
    			add_location(input3, file$l, 267, 10, 10462);
    			attr_dev(span10, "class", "cc-config-autonum svelte-1au0op9");
    			add_location(span10, file$l, 266, 8, 10418);
    			attr_dev(span11, "class", "cc-module-label svelte-1au0op9");
    			add_location(span11, file$l, 252, 6, 9952);
    			attr_dev(span12, "class", "cc-module-input svelte-1au0op9");
    			add_location(span12, file$l, 278, 6, 10929);
    			attr_dev(div15, "class", "cc-module-form svelte-1au0op9");
    			add_location(div15, file$l, 251, 4, 9916);
    			attr_dev(div16, "class", "cc-module-col svelte-1au0op9");
    			add_location(div16, file$l, 250, 2, 9883);
    			attr_dev(div17, "class", "cc-module-col svelte-1au0op9");
    			add_location(div17, file$l, 302, 2, 11800);
    			attr_dev(div18, "class", "cc-module-row svelte-1au0op9");
    			add_location(div18, file$l, 249, 0, 9852);
    			attr_dev(label5, "for", label5_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-description");
    			add_location(label5, file$l, 306, 2, 11887);
    			attr_dev(div19, "slot", "content");
    			add_location(div19, file$l, 308, 4, 11981);
    			attr_dev(i5, "class", "icon-question cc-module-icon");
    			add_location(i5, file$l, 316, 6, 12226);
    			attr_dev(a5, "id", "cc-about-module-description");
    			attr_dev(a5, "href", /*HELP*/ ctx[6].configDescription.url);
    			attr_dev(a5, "target", "_blank");
    			attr_dev(a5, "rel", "noreferrer");
    			attr_dev(a5, "class", "cc-module-link");
    			add_location(a5, file$l, 309, 4, 12051);
    			set_custom_element_data(sl_tooltip5, "class", "svelte-1au0op9");
    			add_location(sl_tooltip5, file$l, 307, 2, 11963);
    			attr_dev(div20, "class", "cc-module-config-description svelte-1au0op9");
    			add_location(div20, file$l, 305, 0, 11841);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div2);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(span0, label0);
    			append_dev(label0, t0);
    			append_dev(span0, t1);
    			append_dev(span0, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t2);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			append_dev(div1, t3);
    			append_dev(div1, span1);
    			append_dev(span1, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].collection);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, span3);
    			append_dev(span3, label1);
    			append_dev(label1, t6);
    			append_dev(span3, t7);
    			append_dev(span3, sl_tooltip1);
    			append_dev(sl_tooltip1, div3);
    			div3.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t8);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(span3, t9);
    			append_dev(span3, span2);
    			append_dev(span2, input0);
    			input0.checked = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyi;
    			append_dev(div4, t10);
    			append_dev(div4, span4);
    			if_block0.m(span4, null);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div9);
    			append_dev(div9, div8);
    			append_dev(div8, span5);
    			append_dev(span5, label2);
    			append_dev(label2, t12);
    			append_dev(span5, t13);
    			append_dev(span5, sl_tooltip2);
    			append_dev(sl_tooltip2, div7);
    			div7.innerHTML = raw2_value;
    			append_dev(sl_tooltip2, t14);
    			append_dev(sl_tooltip2, a2);
    			append_dev(a2, i2);
    			append_dev(div8, t15);
    			append_dev(div8, span6);
    			append_dev(span6, input1);
    			set_input_value(input1, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].label);
    			append_dev(div13, t16);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, span8);
    			append_dev(span8, label3);
    			append_dev(label3, t17);
    			append_dev(span8, t18);
    			append_dev(span8, sl_tooltip3);
    			append_dev(sl_tooltip3, div10);
    			div10.innerHTML = raw3_value;
    			append_dev(sl_tooltip3, t19);
    			append_dev(sl_tooltip3, a3);
    			append_dev(a3, i3);
    			append_dev(span8, t20);
    			append_dev(span8, span7);
    			append_dev(span7, t21);
    			append_dev(span7, input2);
    			append_dev(div11, t22);
    			append_dev(div11, span9);
    			if_block1.m(span9, null);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, div18, anchor);
    			append_dev(div18, div16);
    			append_dev(div16, div15);
    			append_dev(div15, span11);
    			append_dev(span11, label4);
    			append_dev(label4, t24);
    			append_dev(span11, t25);
    			append_dev(span11, sl_tooltip4);
    			append_dev(sl_tooltip4, div14);
    			div14.innerHTML = raw4_value;
    			append_dev(sl_tooltip4, t26);
    			append_dev(sl_tooltip4, a4);
    			append_dev(a4, i4);
    			append_dev(span11, t27);
    			append_dev(span11, span10);
    			append_dev(span10, input3);
    			input3.checked = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engage;
    			append_dev(div15, t28);
    			append_dev(div15, span12);
    			if_block2.m(span12, null);
    			append_dev(div18, t29);
    			append_dev(div18, div17);
    			insert_dev(target, t30, anchor);
    			insert_dev(target, div20, anchor);
    			append_dev(div20, label5);
    			append_dev(label5, t31);
    			append_dev(div20, t32);
    			append_dev(div20, sl_tooltip5);
    			append_dev(sl_tooltip5, div19);
    			div19.innerHTML = raw5_value;
    			append_dev(sl_tooltip5, t33);
    			append_dev(sl_tooltip5, a5);
    			append_dev(a5, i5);
    			insert_dev(target, t34, anchor);
    			mount_component(editor, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*change_handler*/ ctx[10], false, false, false),
    					listen_dev(input0, "keydown", stop_propagation(/*keydown_handler*/ ctx[9]), false, false, true),
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[11]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[16]),
    					listen_dev(input1, "click", /*click_handler_1*/ ctx[17], false, false, false),
    					listen_dev(input1, "keydown", stop_propagation(/*keydown_handler_4*/ ctx[18]), false, false, true),
    					listen_dev(input2, "change", stop_propagation(/*switchAutoNum*/ ctx[4]), false, false, true),
    					listen_dev(input2, "keydown", stop_propagation(/*keydown_handler_1*/ ctx[8]), false, false, true),
    					listen_dev(input3, "keydown", stop_propagation(/*keydown_handler_2*/ ctx[7]), false, false, true),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[25]),
    					listen_dev(input3, "click", /*click_handler_4*/ ctx[26], false, false, false),
    					listen_dev(input3, "keydown", /*keydown_handler_7*/ ctx[27], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && label0_for_value !== (label0_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-collection")) {
    				attr_dev(label0, "for", label0_for_value);
    			}

    			if (dirty[0] & /*$collectionsStore*/ 4) {
    				each_value = /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && select_id_value !== (select_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-collection")) {
    				attr_dev(select, "id", select_id_value);
    			}

    			if (!current || dirty[0] & /*$collectionsStore, moduleId*/ 5 && select_value_value !== (select_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].collection)) {
    				select_option(select, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].collection);
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && label1_for_value !== (label1_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyi")) {
    				attr_dev(label1, "for", label1_for_value);
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && input0_id_value !== (input0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-fyi")) {
    				attr_dev(input0, "id", input0_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5) {
    				input0.checked = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].fyi;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span4, null);
    				}
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && label2_for_value !== (label2_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-label")) {
    				attr_dev(label2, "for", label2_for_value);
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && input1_id_value !== (input1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-label")) {
    				attr_dev(input1, "id", input1_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5 && input1.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].label) {
    				set_input_value(input1, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].label);
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && label3_for_value !== (label3_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-num")) {
    				attr_dev(label3, "for", label3_for_value);
    			}

    			if (!current || dirty[0] & /*$collectionsStore, moduleId*/ 5 && input2_checked_value !== (input2_checked_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].autonum)) {
    				prop_dev(input2, "checked", input2_checked_value);
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && input2_id_value !== (input2_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-autonum")) {
    				attr_dev(input2, "id", input2_id_value);
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(span9, null);
    				}
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && label4_for_value !== (label4_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engage")) {
    				attr_dev(label4, "for", label4_for_value);
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && input3_id_value !== (input3_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-engage")) {
    				attr_dev(input3, "id", input3_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, moduleId*/ 5) {
    				input3.checked = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].engage;
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(span12, null);
    				}
    			}

    			if (!current || dirty[0] & /*moduleId, $collectionsStore*/ 5 && label5_for_value !== (label5_for_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-description")) {
    				attr_dev(label5, "for", label5_for_value);
    			}

    			const editor_changes = {};
    			if (dirty[0] & /*moduleId*/ 1) editor_changes.contentId = "cc-module-config-" + /*moduleId*/ ctx[0] + "-description-editor";
    			editor.$set(editor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_each(each_blocks, detaching);
    			if_block0.d();
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div13);
    			if_block1.d();
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(div18);
    			if_block2.d();
    			if (detaching) detach_dev(t30);
    			if (detaching) detach_dev(div20);
    			if (detaching) detach_dev(t34);
    			destroy_component(editor, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	let $modulesStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(1, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	validate_store(modulesStore, 'modulesStore');
    	component_subscribe($$self, modulesStore, $$value => $$invalidate(33, $modulesStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModuleGeneralConfiguration', slots, []);
    	let { moduleId } = $$props;
    	let html = $collectionsStore["MODULES"][moduleId].description;

    	onMount(() => {
    		const editorId = `cc-module-config-${moduleId}-description-editor`;
    		let editorElem = document.getElementById(editorId);

    		if (editorElem) {
    			editorElem.onkeydown = e => {
    				e.stopPropagation();
    			};

    			// stop propagation on the HTML view editor (the text areas)
    			// TODO this attempt to pass along doesn't work
    			// Canvas sentry.io causes problem
    			// TODO fix this more #180
    			let textareaElem = editorElem.nextElementSibling;

    			if (textareaElem) {
    				textareaElem.onkeydown = e => {
    					e.stopPropagation();
    				};
    			}
    		}
    	});

    	/**
     * @function switchAutoNum
     * @description called when the autonum is toggled on/off needs to
     * In theory, the value has already been changed
     * - call calculateActualNum
     * - set needToSaveCollections to true
     */
    	function switchAutoNum() {
    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].autonum = !$collectionsStore["MODULES"][moduleId].autonum, $collectionsStore);
    		calculateActualNum($modulesStore, $collectionsStore["MODULES"]);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	/**
     * @function changeCollectionAllocation
     * @param {Event} e
     * @description called when the collection allocation is changed
     * - modify the modules collection based on the value of the select
     * - call calculateActualNum
     * - set needToSaveCollections to true
     */
    	function changeCollectionAllocation(e) {
    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].collection = e.target.value, $collectionsStore);
    		calculateActualNum($modulesStore, $collectionsStore["MODULES"]);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	const HELP = {
    		configCollection: {
    			tooltip: `To which of the available collections does this module belong?`,
    			url: "https://djplaner.github.io/canvas-collections/getting-started/configure/modules/#module-properties"
    		},
    		configFYI: {
    			tooltip: `<p>Represent the module as a "for your information" (fyi) object. Only display collection related information.
		Display no information about the corresponding module. Always display the object, even when the module is unpublished.</p>
		<p>Optionally, provide some text to add to the representation.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#fyi-objects"
    		},
    		configDescription: {
    			tooltip: `Describe why, what or how the module relates to the students' learning`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#description"
    		},
    		configEngage: {
    			tooltip: `For cards representations, specify <ol> <li> if there will be an "engage" button; and, </li> <li> what the button text will be. </li> </ol>`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#enage-button"
    		},
    		configLabel: {
    			tooltip: `Describe the type of object the module represents (e.g. lecture, theme etc.)`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#enage-button"
    		},
    		configAutoNum: {
    			tooltip: `If and how a label specific number will be calculated for the module 
		(e.g. <em>Lecture 1</em> or <em>Workshop 5</em>)<p>Auto number or specify a value.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#labels-and-numbers"
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<ModuleGeneralConfiguration> was created without expected prop 'moduleId'");
    		}
    	});

    	const writable_props = ['moduleId'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModuleGeneralConfiguration> was created with unknown prop '${key}'`);
    	});

    	function keydown_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const change_handler = e => changeCollectionAllocation(e);

    	function input0_change_handler() {
    		$collectionsStore["MODULES"][moduleId].fyi = this.checked;
    		collectionsStore.set($collectionsStore);
    	}

    	function input_input_handler() {
    		$collectionsStore["MODULES"][moduleId].fyiText = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	const click_handler = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_3 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input_input_handler_1() {
    		$collectionsStore["MODULES"][moduleId].fyiText = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	function input1_input_handler() {
    		$collectionsStore["MODULES"][moduleId].label = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	const click_handler_1 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_4 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input_input_handler_2() {
    		$collectionsStore["MODULES"][moduleId].actualNum = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	const click_handler_2 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_5 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input_input_handler_3() {
    		$collectionsStore["MODULES"][moduleId].actualNum = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	const click_handler_3 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_6 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input3_change_handler() {
    		$collectionsStore["MODULES"][moduleId].engage = this.checked;
    		collectionsStore.set($collectionsStore);
    	}

    	const click_handler_4 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_7 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input_input_handler_4() {
    		$collectionsStore["MODULES"][moduleId].engageText = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	function input_input_handler_5() {
    		$collectionsStore["MODULES"][moduleId].engageText = this.value;
    		collectionsStore.set($collectionsStore);
    	}

    	const click_handler_5 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_8 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	const change_handler_1 = evt => {
    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].description = evt.detail, $collectionsStore);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	};

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    	};

    	$$self.$capture_state = () => ({
    		modulesStore,
    		collectionsStore,
    		configStore,
    		calculateActualNum,
    		onMount,
    		Editor,
    		moduleId,
    		html,
    		switchAutoNum,
    		changeCollectionAllocation,
    		HELP,
    		$configStore,
    		$collectionsStore,
    		$modulesStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    		if ('html' in $$props) $$invalidate(3, html = $$props.html);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		moduleId,
    		$configStore,
    		$collectionsStore,
    		html,
    		switchAutoNum,
    		changeCollectionAllocation,
    		HELP,
    		keydown_handler_2,
    		keydown_handler_1,
    		keydown_handler,
    		change_handler,
    		input0_change_handler,
    		input_input_handler,
    		click_handler,
    		keydown_handler_3,
    		input_input_handler_1,
    		input1_input_handler,
    		click_handler_1,
    		keydown_handler_4,
    		input_input_handler_2,
    		click_handler_2,
    		keydown_handler_5,
    		input_input_handler_3,
    		click_handler_3,
    		keydown_handler_6,
    		input3_change_handler,
    		click_handler_4,
    		keydown_handler_7,
    		input_input_handler_4,
    		input_input_handler_5,
    		click_handler_5,
    		keydown_handler_8,
    		change_handler_1
    	];
    }

    class ModuleGeneralConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { moduleId: 0 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModuleGeneralConfiguration",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<ModuleGeneralConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<ModuleGeneralConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @file ui.ts
     * @description UI helper functions
     */
    /**
     * @function toastAlert
     * @param {string} message - HTML to be displayed in the toast
     * @param {string} status - primary, success, neutral, warning, danger
     * @description Quick implementation of the shoelace style toast alert notification
     * https://shoelace.style/components/alert
     */
    function toastAlert(message, status = "primary", duration = null) {
        const iconMapping = {
            primary: "info-circle",
            success: "check2-circle",
            neutral: "gear",
            warning: "exclamation-triangle",
            danger: "exclamation-octagon",
        };
        // create a shoelace style sl-alert element
        const alert = document.createElement("sl-alert");
        // set variant duration closable attributes
        alert.setAttribute("variant", status);
        //alert.setAttribute("duration", "5000");
        alert.setAttribute("closable", "true");
        if (duration) {
            alert.setAttribute("duration", duration);
        }
        alert.innerHTML = `
    <sl-icon slot="icon" name="${iconMapping[status]}"></sl-icon>
    ${message}
    `;
        alert.toast();
    }
    /**
     * @function ccConfirm
     * @param message
     * @description Controller to implement a confirm dialog using shoelace style
     * copied from https://jsfiddle.net/claviska/s3vdafmw/7/
     */
    const ccConfirm = (message) => {
        return new Promise((resolve, reject) => {
            const div = document.createElement("div");
            div.innerHTML = `
      <sl-dialog label="Confirm">
        ${message}
        <sl-button slot="footer">Cancel</sl-button>
        <sl-button slot="footer" type="primary">OK</sl-button>
      </sl-dialog>    
    `;
            const dialog = div.querySelector("sl-dialog");
            const cancel = div.querySelector("sl-button");
            const ok = cancel.nextElementSibling;
            document.body.appendChild(dialog);
            customElements.whenDefined("sl-dialog").then(() => {
                dialog.show();
                ok.addEventListener("click", () => {
                    resolve(true);
                    dialog.hide();
                });
                cancel.addEventListener("click", () => {
                    resolve(false);
                    dialog.hide();
                });
                dialog.addEventListener("sl-hide", () => {
                    resolve(false);
                });
            });
        });
    };

    /* src\components\Configuration\ModuleBannerConfiguration.svelte generated by Svelte v3.55.0 */
    const file$k = "src\\components\\Configuration\\ModuleBannerConfiguration.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (190:10) {#each imageScaleOptions as imageScaleOption}
    function create_each_block$b(ctx) {
    	let option;
    	let t_value = /*imageScaleOption*/ ctx[15] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*imageScaleOption*/ ctx[15];
    			option.value = option.__value;
    			add_location(option, file$k, 190, 12, 7556);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(190:10) {#each imageScaleOptions as imageScaleOption}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[7].moduleBanner.tooltip + "";
    	let t0;
    	let a0;
    	let i0;
    	let t1;
    	let strong;
    	let t3;
    	let sl_tab_group;
    	let sl_tab0;
    	let t4;
    	let sl_tab0_active_value;
    	let sl_tab0_panel_value;
    	let t5;
    	let sl_tab1;
    	let t6;
    	let sl_tab1_active_value;
    	let sl_tab1_panel_value;
    	let t7;
    	let sl_tab2;
    	let t8;
    	let sl_tab2_active_value;
    	let sl_tab2_panel_value;
    	let t9;
    	let sl_tab_panel0;
    	let div2;
    	let span0;
    	let label0;
    	let t10;
    	let label0_for_value;
    	let t11;
    	let sl_tooltip1;
    	let div1;
    	let raw1_value = /*HELP*/ ctx[7].moduleImageScale.tooltip + "";
    	let t12;
    	let a1;
    	let i1;
    	let t13;
    	let span1;
    	let select;
    	let select_id_value;
    	let t14;
    	let div4;
    	let span2;
    	let label1;
    	let t15;
    	let label1_for_value;
    	let t16;
    	let sl_tooltip2;
    	let div3;
    	let raw2_value = /*HELP*/ ctx[7].moduleImageUrl.tooltip + "";
    	let t17;
    	let a2;
    	let i2;
    	let t18;
    	let span3;
    	let input;
    	let input_id_value;
    	let sl_tab_panel0_name_value;
    	let t19;
    	let sl_tab_panel1;
    	let div6;
    	let label2;
    	let t20;
    	let label2_for_value;
    	let t21;
    	let sl_tooltip3;
    	let div5;
    	let raw3_value = /*HELP*/ ctx[7].moduleIframe.tooltip + "";
    	let t22;
    	let a3;
    	let i3;
    	let t23;
    	let textarea;
    	let textarea_id_value;
    	let textarea_value_value;
    	let sl_tab_panel1_name_value;
    	let t24;
    	let sl_tab_panel2;
    	let div8;
    	let label3;
    	let t25;
    	let label3_for_value;
    	let t26;
    	let sl_tooltip4;
    	let div7;
    	let raw4_value = /*HELP*/ ctx[7].moduleColour.tooltip + "";
    	let t27;
    	let a4;
    	let i4;
    	let t28;
    	let sl_color_picker;
    	let sl_color_picker_id_value;
    	let sl_color_picker_value_value;
    	let sl_tab_panel2_name_value;
    	let mounted;
    	let dispose;
    	let each_value = /*imageScaleOptions*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t0 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t1 = space();
    			strong = element("strong");
    			strong.textContent = "Banner";
    			t3 = space();
    			sl_tab_group = element("sl-tab-group");
    			sl_tab0 = element("sl-tab");
    			t4 = text("Image");
    			t5 = space();
    			sl_tab1 = element("sl-tab");
    			t6 = text("Iframe");
    			t7 = space();
    			sl_tab2 = element("sl-tab");
    			t8 = text("Colour");
    			t9 = space();
    			sl_tab_panel0 = element("sl-tab-panel");
    			div2 = element("div");
    			span0 = element("span");
    			label0 = element("label");
    			t10 = text("Image scale");
    			t11 = space();
    			sl_tooltip1 = element("sl-tooltip");
    			div1 = element("div");
    			t12 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t13 = space();
    			span1 = element("span");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t14 = space();
    			div4 = element("div");
    			span2 = element("span");
    			label1 = element("label");
    			t15 = text("Image URL");
    			t16 = space();
    			sl_tooltip2 = element("sl-tooltip");
    			div3 = element("div");
    			t17 = space();
    			a2 = element("a");
    			i2 = element("i");
    			t18 = space();
    			span3 = element("span");
    			input = element("input");
    			t19 = space();
    			sl_tab_panel1 = element("sl-tab-panel");
    			div6 = element("div");
    			label2 = element("label");
    			t20 = text("iframe:");
    			t21 = space();
    			sl_tooltip3 = element("sl-tooltip");
    			div5 = element("div");
    			t22 = space();
    			a3 = element("a");
    			i3 = element("i");
    			t23 = space();
    			textarea = element("textarea");
    			t24 = space();
    			sl_tab_panel2 = element("sl-tab-panel");
    			div8 = element("div");
    			label3 = element("label");
    			t25 = text("Colour:");
    			t26 = space();
    			sl_tooltip4 = element("sl-tooltip");
    			div7 = element("div");
    			t27 = space();
    			a4 = element("a");
    			i4 = element("i");
    			t28 = space();
    			sl_color_picker = element("sl-color-picker");
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$k, 142, 2, 5831);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$k, 144, 4, 5966);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", /*HELP*/ ctx[7].moduleBanner.href);
    			attr_dev(a0, "rel", "noreferrer");
    			add_location(a0, file$k, 143, 2, 5894);
    			set_custom_element_data(sl_tooltip0, "id", "cc-about-module-banner");
    			set_custom_element_data(sl_tooltip0, "class", "svelte-15vu42i");
    			add_location(sl_tooltip0, file$k, 141, 0, 5787);
    			add_location(strong, file$k, 147, 0, 6033);
    			set_custom_element_data(sl_tab0, "class", "cc-banner-tab");
    			set_custom_element_data(sl_tab0, "name", "image");
    			set_custom_element_data(sl_tab0, "slot", "nav");
    			set_custom_element_data(sl_tab0, "active", sl_tab0_active_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].banner === "image");
    			set_custom_element_data(sl_tab0, "panel", sl_tab0_panel_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-image");
    			add_location(sl_tab0, file$k, 149, 2, 6122);
    			set_custom_element_data(sl_tab1, "class", "cc-banner-tab");
    			set_custom_element_data(sl_tab1, "name", "iframe");
    			set_custom_element_data(sl_tab1, "slot", "nav");
    			set_custom_element_data(sl_tab1, "active", sl_tab1_active_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].banner === "iframe");
    			set_custom_element_data(sl_tab1, "panel", sl_tab1_panel_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-iframe");
    			add_location(sl_tab1, file$k, 156, 2, 6332);
    			set_custom_element_data(sl_tab2, "class", "cc-banner-tab");
    			set_custom_element_data(sl_tab2, "name", "colour");
    			set_custom_element_data(sl_tab2, "slot", "nav");
    			set_custom_element_data(sl_tab2, "active", sl_tab2_active_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].banner === "colour");
    			set_custom_element_data(sl_tab2, "panel", sl_tab2_panel_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-colour");
    			add_location(sl_tab2, file$k, 163, 2, 6546);
    			attr_dev(label0, "for", label0_for_value = "cc-collection-representation-" + /*moduleId*/ ctx[0] + "-imageSize");
    			add_location(label0, file$k, 174, 8, 6899);
    			attr_dev(div1, "slot", "content");
    			add_location(div1, file$k, 178, 10, 7037);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$k, 180, 13, 7196);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", /*HELP*/ ctx[7].moduleImageScale.href);
    			attr_dev(a1, "rel", "noreferrer");
    			add_location(a1, file$k, 179, 10, 7112);
    			set_custom_element_data(sl_tooltip1, "class", "svelte-15vu42i");
    			add_location(sl_tooltip1, file$k, 177, 8, 7013);
    			attr_dev(span0, "class", "cc-module-label svelte-15vu42i");
    			add_location(span0, file$k, 173, 6, 6859);
    			attr_dev(select, "id", select_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-imageSize");
    			if (/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].imageSize === void 0) add_render_callback(() => /*select_change_handler*/ ctx[9].call(select));
    			add_location(select, file$k, 185, 8, 7340);
    			attr_dev(span1, "class", "cc-module-input svelte-15vu42i");
    			add_location(span1, file$k, 184, 6, 7300);
    			attr_dev(div2, "class", "cc-module-form svelte-15vu42i");
    			add_location(div2, file$k, 172, 4, 6823);
    			attr_dev(label1, "for", label1_for_value = "cc-module-config-collection-representation-" + /*moduleId*/ ctx[0] + "-image");
    			add_location(label1, file$k, 197, 8, 7763);
    			attr_dev(div3, "slot", "content");
    			add_location(div3, file$k, 203, 10, 7961);
    			attr_dev(i2, "class", "icon-question cc-module-icon");
    			add_location(i2, file$k, 205, 13, 8116);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", /*HELP*/ ctx[7].moduleImageUrl.href);
    			attr_dev(a2, "rel", "noreferrer");
    			add_location(a2, file$k, 204, 10, 8034);
    			set_custom_element_data(sl_tooltip2, "id", "cc-about-module-image-url");
    			set_custom_element_data(sl_tooltip2, "class", "svelte-15vu42i");
    			add_location(sl_tooltip2, file$k, 202, 8, 7906);
    			attr_dev(span2, "class", "cc-module-label svelte-15vu42i");
    			add_location(span2, file$k, 196, 6, 7723);
    			attr_dev(input, "class", "cc-module-config-input svelte-15vu42i");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-image");
    			add_location(input, file$k, 210, 8, 8260);
    			attr_dev(span3, "class", "cc-module-input svelte-15vu42i");
    			add_location(span3, file$k, 209, 6, 8220);
    			attr_dev(div4, "class", "cc-module-form svelte-15vu42i");
    			add_location(div4, file$k, 195, 4, 7687);
    			set_custom_element_data(sl_tab_panel0, "name", sl_tab_panel0_name_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-image");
    			add_location(sl_tab_panel0, file$k, 171, 2, 6762);
    			attr_dev(label2, "for", label2_for_value = "cc-collection-representation-" + /*moduleId*/ ctx[0] + "-iframe");
    			set_style(label2, "padding-top", "0.8rem");
    			add_location(label2, file$k, 225, 6, 8821);
    			attr_dev(div5, "slot", "content");
    			add_location(div5, file$k, 232, 8, 9026);
    			attr_dev(i3, "class", "icon-question cc-module-icon");
    			add_location(i3, file$k, 234, 11, 9173);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "href", /*HELP*/ ctx[7].moduleIframe.href);
    			attr_dev(a3, "rel", "noreferrer");
    			add_location(a3, file$k, 233, 8, 9095);
    			set_custom_element_data(sl_tooltip3, "id", "cc-about-module-iframe");
    			set_custom_element_data(sl_tooltip3, "class", "svelte-15vu42i");
    			add_location(sl_tooltip3, file$k, 231, 6, 8976);
    			attr_dev(textarea, "class", "cc-module-iframe svelte-15vu42i");
    			attr_dev(textarea, "cols", "60");
    			attr_dev(textarea, "rows", "10");
    			attr_dev(textarea, "id", textarea_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-iframe");
    			textarea.value = textarea_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].iframe;
    			add_location(textarea, file$k, 237, 6, 9258);
    			attr_dev(div6, "class", "cc-module-config-collection-representation");
    			add_location(div6, file$k, 224, 4, 8757);
    			set_custom_element_data(sl_tab_panel1, "name", sl_tab_panel1_name_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-iframe");
    			add_location(sl_tab_panel1, file$k, 223, 2, 8695);
    			attr_dev(label3, "for", label3_for_value = "cc-collection-representation-" + /*moduleId*/ ctx[0] + "-color");
    			set_style(label3, "padding-top", "0.8rem");
    			add_location(label3, file$k, 251, 6, 9696);
    			attr_dev(div7, "slot", "content");
    			add_location(div7, file$k, 258, 8, 9899);
    			attr_dev(i4, "class", "icon-question cc-module-icon");
    			add_location(i4, file$k, 260, 11, 10046);
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "href", /*HELP*/ ctx[7].moduleColour.href);
    			attr_dev(a4, "rel", "noreferrer");
    			add_location(a4, file$k, 259, 8, 9968);
    			set_custom_element_data(sl_tooltip4, "id", "cc-about-module-color");
    			set_custom_element_data(sl_tooltip4, "class", "svelte-15vu42i");
    			add_location(sl_tooltip4, file$k, 257, 6, 9850);
    			set_custom_element_data(sl_color_picker, "id", sl_color_picker_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-color");
    			set_custom_element_data(sl_color_picker, "value", sl_color_picker_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].bannerColour);
    			set_custom_element_data(sl_color_picker, "label", "Select a color");
    			add_location(sl_color_picker, file$k, 263, 6, 10131);
    			attr_dev(div8, "class", "cc-module-config-collection-representation");
    			add_location(div8, file$k, 250, 4, 9632);
    			set_custom_element_data(sl_tab_panel2, "name", sl_tab_panel2_name_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-colour");
    			add_location(sl_tab_panel2, file$k, 249, 2, 9570);
    			add_location(sl_tab_group, file$k, 148, 0, 6058);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tooltip0, anchor);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t0);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, strong, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, sl_tab_group, anchor);
    			append_dev(sl_tab_group, sl_tab0);
    			append_dev(sl_tab0, t4);
    			append_dev(sl_tab_group, t5);
    			append_dev(sl_tab_group, sl_tab1);
    			append_dev(sl_tab1, t6);
    			append_dev(sl_tab_group, t7);
    			append_dev(sl_tab_group, sl_tab2);
    			append_dev(sl_tab2, t8);
    			append_dev(sl_tab_group, t9);
    			append_dev(sl_tab_group, sl_tab_panel0);
    			append_dev(sl_tab_panel0, div2);
    			append_dev(div2, span0);
    			append_dev(span0, label0);
    			append_dev(label0, t10);
    			append_dev(span0, t11);
    			append_dev(span0, sl_tooltip1);
    			append_dev(sl_tooltip1, div1);
    			div1.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t12);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(div2, t13);
    			append_dev(div2, span1);
    			append_dev(span1, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].imageSize);
    			append_dev(sl_tab_panel0, t14);
    			append_dev(sl_tab_panel0, div4);
    			append_dev(div4, span2);
    			append_dev(span2, label1);
    			append_dev(label1, t15);
    			append_dev(span2, t16);
    			append_dev(span2, sl_tooltip2);
    			append_dev(sl_tooltip2, div3);
    			div3.innerHTML = raw2_value;
    			append_dev(sl_tooltip2, t17);
    			append_dev(sl_tooltip2, a2);
    			append_dev(a2, i2);
    			append_dev(div4, t18);
    			append_dev(div4, span3);
    			append_dev(span3, input);
    			set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].image);
    			append_dev(sl_tab_group, t19);
    			append_dev(sl_tab_group, sl_tab_panel1);
    			append_dev(sl_tab_panel1, div6);
    			append_dev(div6, label2);
    			append_dev(label2, t20);
    			append_dev(div6, t21);
    			append_dev(div6, sl_tooltip3);
    			append_dev(sl_tooltip3, div5);
    			div5.innerHTML = raw3_value;
    			append_dev(sl_tooltip3, t22);
    			append_dev(sl_tooltip3, a3);
    			append_dev(a3, i3);
    			append_dev(div6, t23);
    			append_dev(div6, textarea);
    			append_dev(sl_tab_group, t24);
    			append_dev(sl_tab_group, sl_tab_panel2);
    			append_dev(sl_tab_panel2, div8);
    			append_dev(div8, label3);
    			append_dev(label3, t25);
    			append_dev(div8, t26);
    			append_dev(div8, sl_tooltip4);
    			append_dev(sl_tooltip4, div7);
    			div7.innerHTML = raw4_value;
    			append_dev(sl_tooltip4, t27);
    			append_dev(sl_tooltip4, a4);
    			append_dev(a4, i4);
    			append_dev(div8, t28);
    			append_dev(div8, sl_color_picker);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[9]),
    					listen_dev(input, "click", /*click_handler*/ ctx[10], false, false, false),
    					listen_dev(input, "keydown", stop_propagation(/*keydown_handler_1*/ ctx[11]), false, false, true),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[12]),
    					listen_dev(textarea, "keydown", stop_propagation(/*keydown_handler*/ ctx[8]), false, false, true),
    					listen_dev(textarea, "focusout", /*updateIframe*/ ctx[6], false, false, false),
    					listen_dev(sl_color_picker, "sl-change", /*updateBannerColour*/ ctx[4], false, false, false),
    					listen_dev(sl_tab_group, "sl-tab-show", /*sl_tab_show_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13 && sl_tab0_active_value !== (sl_tab0_active_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].banner === "image")) {
    				set_custom_element_data(sl_tab0, "active", sl_tab0_active_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_tab0_panel_value !== (sl_tab0_panel_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-image")) {
    				set_custom_element_data(sl_tab0, "panel", sl_tab0_panel_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13 && sl_tab1_active_value !== (sl_tab1_active_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].banner === "iframe")) {
    				set_custom_element_data(sl_tab1, "active", sl_tab1_active_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_tab1_panel_value !== (sl_tab1_panel_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-iframe")) {
    				set_custom_element_data(sl_tab1, "panel", sl_tab1_panel_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13 && sl_tab2_active_value !== (sl_tab2_active_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].banner === "colour")) {
    				set_custom_element_data(sl_tab2, "active", sl_tab2_active_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_tab2_panel_value !== (sl_tab2_panel_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-colour")) {
    				set_custom_element_data(sl_tab2, "panel", sl_tab2_panel_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && label0_for_value !== (label0_for_value = "cc-collection-representation-" + /*moduleId*/ ctx[0] + "-imageSize")) {
    				attr_dev(label0, "for", label0_for_value);
    			}

    			if (dirty & /*imageScaleOptions*/ 8) {
    				each_value = /*imageScaleOptions*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && select_id_value !== (select_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-imageSize")) {
    				attr_dev(select, "id", select_id_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13) {
    				select_option(select, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].imageSize);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && label1_for_value !== (label1_for_value = "cc-module-config-collection-representation-" + /*moduleId*/ ctx[0] + "-image")) {
    				attr_dev(label1, "for", label1_for_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && input_id_value !== (input_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-image")) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13 && input.value !== /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].image) {
    				set_input_value(input, /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].image);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_tab_panel0_name_value !== (sl_tab_panel0_name_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-image")) {
    				set_custom_element_data(sl_tab_panel0, "name", sl_tab_panel0_name_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && label2_for_value !== (label2_for_value = "cc-collection-representation-" + /*moduleId*/ ctx[0] + "-iframe")) {
    				attr_dev(label2, "for", label2_for_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && textarea_id_value !== (textarea_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-iframe")) {
    				attr_dev(textarea, "id", textarea_id_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13 && textarea_value_value !== (textarea_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].iframe)) {
    				prop_dev(textarea, "value", textarea_value_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_tab_panel1_name_value !== (sl_tab_panel1_name_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-iframe")) {
    				set_custom_element_data(sl_tab_panel1, "name", sl_tab_panel1_name_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && label3_for_value !== (label3_for_value = "cc-collection-representation-" + /*moduleId*/ ctx[0] + "-color")) {
    				attr_dev(label3, "for", label3_for_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_color_picker_id_value !== (sl_color_picker_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-color")) {
    				set_custom_element_data(sl_color_picker, "id", sl_color_picker_id_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId, imageScaleOptions*/ 13 && sl_color_picker_value_value !== (sl_color_picker_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].bannerColour)) {
    				set_custom_element_data(sl_color_picker, "value", sl_color_picker_value_value);
    			}

    			if (dirty & /*moduleId, imageScaleOptions*/ 9 && sl_tab_panel2_name_value !== (sl_tab_panel2_name_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-colour")) {
    				set_custom_element_data(sl_tab_panel2, "name", sl_tab_panel2_name_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tooltip0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(strong);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(sl_tab_group);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function encodeHTML(html, json = true) {
    	let txt = document.createElement("textarea");
    	txt.innerHTML = html;
    	let value = txt.innerHTML;
    	return value;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(1, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModuleBannerConfiguration', slots, []);
    	let { moduleId } = $$props;
    	const imageScaleOptions = ["none", "contain", "cover", "fill", "scale-down", "auto"];

    	/**
     * @function updateBannerColour
     * @description Called when user changes shoelace colour picker
     * - get the value from the colour picker
     * - set the bannerColour attribute for the current module
     * - set the needToSave flag
     */
    	function updateBannerColour() {
    		const colourPicker = document.getElementById(`cc-module-config-${moduleId}-color`);
    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].bannerColour = colourPicker.value, $collectionsStore);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	/**
     * @function updateActiveBanner
     * @param {Event} e - the event object
     * @description Called when user changes the active banner tab
     * - get the name of the active tab (e.detail.name)
     * - modify the modules banner value to match the active tab
     * - set the needToSave flag
     */
    	function updateActiveBanner(e) {
    		const activeTab = e.detail.name;

    		// extract the name from activeTab
    		const name = activeTab.split("-").pop();

    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].banner = name, $collectionsStore);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	/**
     * @function updateIframe
     * @description Called when user changes the iframe value
     * - sanity check the html allowing iframe tags only
     * - if any change update the user and ask them to confirm
     * - if confirmed update the iframe attribute for the current module
     * - set the needToSaveCollections flag
     */
    	function updateIframe() {
    		const iframe = document.getElementById(`cc-module-config-${moduleId}-iframe`);

    		// sanity check the html allowing iframe tags only
    		const iframeValue = iframe.value;

    		let sanitisedValue = sanitize(iframeValue);

    		// remove anything from sanitisedValue that isn't <iframe>.*</iframe>
    		sanitisedValue = sanitisedValue.replace(/.*(<iframe.*<\/iframe>).*/, "$1");

    		if (iframeValue !== sanitisedValue) {
    			// convert iframeValue to xmp but wrap at 40 characters
    			let displayIframeValue = encodeHTML(iframeValue);

    			let displaySanitisedValue = encodeHTML(sanitisedValue);

    			ccConfirm(`The iframe value you provided appears to contain unnecessary, perhaps forbidden characters.  (NOTE: width and height will be removed to ensure the iframe is responsive.)

You provided
    <p style="font-family: monospace; font-size:small">${displayIframeValue}</p>
only the following is allowed
    <p style="font-family: monospace; font-size:small">${displaySanitisedValue}</p>
    
Do you wish to proceed?`).then(ok => {
    				if (ok) {
    					iframe.value = sanitisedValue;
    					set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].iframe = sanitisedValue, $collectionsStore);
    					set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    				}
    			});
    		} else {
    			set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].iframe = sanitisedValue, $collectionsStore);
    			set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    		}
    	} // if confirmed update the iframe attribute for the current module

    	/**
     * @function sanitize
     * @param {string} value - the value to be sanitised
     * @returns {string} - the sanitised value
     * @description Remove anything from the HTML that isn't <iframe>.*</iframe>
     */
    	function sanitize(value) {
    		let allowedTags = ["iframe"];

    		// sanitizeHtml.defaults.allowedTags;
    		let allowedAttributes = {};

    		//allowedTags = allowedTags.concat("iframe");
    		allowedAttributes = {
    			iframe: ["src", "frameborder", "allowfullscreen", "allow", "title"]
    		};

    		return sanitizeHtml_1(value, { allowedTags, allowedAttributes });
    	}

    	/**
     * Define the tooltip and help site links for this module
     */
    	const HELP = {
    		moduleBanner: {
    			tooltip: `<p>Choose one of three possible banner types (for Card representations) and configure it. Options are:</p> 
		<ol>
		  <li> <strong>Image</strong> - a banner image</li>
		  <li> <strong>Colour</strong> - a solid colour</li>
		  <li> <strong>Iframe</strong> - HTML embed code (e.g. YouTube video)</li>
		  </ol>`,
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#dates"
    		},
    		moduleImageScale: {
    			tooltip: "Specify how the image will be scaled to fit the available space.",
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#image-scale"
    		},
    		moduleImageUrl: {
    			tooltip: "Provide the URL for an image to associate with this module.",
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#image-url"
    		},
    		moduleIframe: {
    			tooltip: `<p>Provide an iframe (embed HTML) to place in a card's banner section.</p> <p>Notes:</p>
        <ol>
            <li> <em>height</em> and <em>width</em> will be removed to fit the available space</li>
            <li> any change will only take effect after you click outside the iframe box</li>
            </ol>
        `,
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#iframe"
    		},
    		moduleColour: {
    			tooltip: "<p>Choose a background colour for the card's banner section by clicking on the circle.",
    			href: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#iframe"
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<ModuleBannerConfiguration> was created without expected prop 'moduleId'");
    		}
    	});

    	const writable_props = ['moduleId'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModuleBannerConfiguration> was created with unknown prop '${key}'`);
    	});

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function select_change_handler() {
    		$collectionsStore["MODULES"][moduleId].imageSize = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(3, imageScaleOptions);
    	}

    	const click_handler = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler_1 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input_input_handler() {
    		$collectionsStore["MODULES"][moduleId].image = this.value;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(3, imageScaleOptions);
    	}

    	const sl_tab_show_handler = e => updateActiveBanner(e);

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		ccConfirm,
    		sanitizeHtml: sanitizeHtml_1,
    		moduleId,
    		imageScaleOptions,
    		updateBannerColour,
    		updateActiveBanner,
    		updateIframe,
    		encodeHTML,
    		sanitize,
    		HELP,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		moduleId,
    		$configStore,
    		$collectionsStore,
    		imageScaleOptions,
    		updateBannerColour,
    		updateActiveBanner,
    		updateIframe,
    		HELP,
    		keydown_handler,
    		select_change_handler,
    		click_handler,
    		keydown_handler_1,
    		input_input_handler,
    		sl_tab_show_handler
    	];
    }

    class ModuleBannerConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { moduleId: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModuleBannerConfiguration",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<ModuleBannerConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<ModuleBannerConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Configuration\ModuleMetaDataConfiguration.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1$5 } = globals;
    const file$j = "src\\components\\Configuration\\ModuleMetaDataConfiguration.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i][0];
    	child_ctx[23] = list[i][1];
    	return child_ctx;
    }

    // (256:6) {#each Object.entries($collectionsStore["MODULES"][moduleId].metadata) as [key, value]}
    function create_each_block$a(ctx) {
    	let tr;
    	let td0;
    	let input0;
    	let input0_id_value;
    	let input0_value_value;
    	let t0;
    	let td1;
    	let input1;
    	let input1_id_value;
    	let input1_value_value;
    	let t1;
    	let td2;
    	let i;
    	let i_id_value;
    	let t2;
    	let mounted;
    	let dispose;

    	function focusout_handler() {
    		return /*focusout_handler*/ ctx[15](/*key*/ ctx[22]);
    	}

    	function focusout_handler_1() {
    		return /*focusout_handler_1*/ ctx[16](/*key*/ ctx[22]);
    	}

    	function click_handler() {
    		return /*click_handler*/ ctx[17](/*key*/ ctx[22]);
    	}

    	function keydown_handler_4() {
    		return /*keydown_handler_4*/ ctx[18](/*key*/ ctx[22]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			input0 = element("input");
    			t0 = space();
    			td1 = element("td");
    			input1 = element("input");
    			t1 = space();
    			td2 = element("td");
    			i = element("i");
    			t2 = space();
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "id", input0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-" + /*key*/ ctx[22] + "-name");
    			input0.value = input0_value_value = /*key*/ ctx[22];
    			attr_dev(input0, "pattern", String.raw`[^<>"]`);
    			add_location(input0, file$j, 258, 12, 9893);
    			attr_dev(td0, "class", "svelte-yo85j4");
    			add_location(td0, file$j, 257, 10, 9875);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "id", input1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-" + /*key*/ ctx[22] + "-value");
    			input1.value = input1_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].metadata[/*key*/ ctx[22]];
    			add_location(input1, file$j, 268, 12, 10229);
    			attr_dev(td1, "class", "svelte-yo85j4");
    			add_location(td1, file$j, 267, 10, 10211);
    			attr_dev(i, "class", "icon-trash cc-delete-metadata svelte-yo85j4");
    			attr_dev(i, "id", i_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-" + /*key*/ ctx[22] + "-delete");
    			add_location(i, file$j, 277, 12, 10572);
    			attr_dev(td2, "class", "svelte-yo85j4");
    			add_location(td2, file$j, 276, 10, 10554);
    			add_location(tr, file$j, 256, 8, 9859);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, input0);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, input1);
    			append_dev(tr, t1);
    			append_dev(tr, td2);
    			append_dev(td2, i);
    			append_dev(tr, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keydown", stop_propagation(/*keydown_handler_2*/ ctx[10]), false, false, true),
    					listen_dev(input0, "focusout", focusout_handler, false, false, false),
    					listen_dev(input1, "focusout", focusout_handler_1, false, false, false),
    					listen_dev(input1, "keydown", stop_propagation(/*keydown_handler_3*/ ctx[9]), false, false, true),
    					listen_dev(i, "click", click_handler, false, false, false),
    					listen_dev(i, "keydown", keydown_handler_4, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*moduleId, $collectionsStore*/ 5 && input0_id_value !== (input0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-" + /*key*/ ctx[22] + "-name")) {
    				attr_dev(input0, "id", input0_id_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 5 && input0_value_value !== (input0_value_value = /*key*/ ctx[22]) && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*moduleId, $collectionsStore*/ 5 && input1_id_value !== (input1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-" + /*key*/ ctx[22] + "-value")) {
    				attr_dev(input1, "id", input1_id_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 5 && input1_value_value !== (input1_value_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].metadata[/*key*/ ctx[22]]) && input1.value !== input1_value_value) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (dirty & /*moduleId, $collectionsStore*/ 5 && i_id_value !== (i_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-" + /*key*/ ctx[22] + "-delete")) {
    				attr_dev(i, "id", i_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(256:6) {#each Object.entries($collectionsStore[\\\"MODULES\\\"][moduleId].metadata) as [key, value]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div2;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t0;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[8].name.tooltip + "";
    	let t1;
    	let i0;
    	let t2;
    	let th1;
    	let t3;
    	let sl_tooltip1;
    	let div1;
    	let raw1_value = /*HELP*/ ctx[8].value.tooltip + "";
    	let t4;
    	let i1;
    	let t5;
    	let th2;
    	let t7;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let input0_id_value;
    	let t8;
    	let td1;
    	let input1;
    	let input1_id_value;
    	let t9;
    	let td2;
    	let button;
    	let t10;
    	let button_id_value;
    	let t11;
    	let mounted;
    	let dispose;
    	let each_value = Object.entries(/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].metadata);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			t0 = text("Name\r\n          ");
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t1 = space();
    			i0 = element("i");
    			t2 = space();
    			th1 = element("th");
    			t3 = text("Value\r\n          ");
    			sl_tooltip1 = element("sl-tooltip");
    			div1 = element("div");
    			t4 = space();
    			i1 = element("i");
    			t5 = space();
    			th2 = element("th");
    			th2.textContent = "Action";
    			t7 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			input0 = element("input");
    			t8 = space();
    			td1 = element("td");
    			input1 = element("input");
    			t9 = space();
    			td2 = element("td");
    			button = element("button");
    			t10 = text("Add");
    			t11 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$j, 213, 12, 8543);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$j, 214, 12, 8608);
    			set_custom_element_data(sl_tooltip0, "class", "svelte-yo85j4");
    			add_location(sl_tooltip0, file$j, 212, 10, 8517);
    			attr_dev(th0, "class", "svelte-yo85j4");
    			add_location(th0, file$j, 210, 8, 8485);
    			attr_dev(div1, "slot", "content");
    			add_location(div1, file$j, 220, 12, 8759);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$j, 221, 12, 8825);
    			set_custom_element_data(sl_tooltip1, "class", "svelte-yo85j4");
    			add_location(sl_tooltip1, file$j, 219, 10, 8733);
    			attr_dev(th1, "class", "svelte-yo85j4");
    			add_location(th1, file$j, 217, 8, 8700);
    			attr_dev(th2, "class", "svelte-yo85j4");
    			add_location(th2, file$j, 224, 8, 8917);
    			add_location(tr0, file$j, 209, 6, 8471);
    			add_location(thead, file$j, 208, 4, 8456);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "id", input0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-add-name");
    			add_location(input0, file$j, 230, 11, 9010);
    			attr_dev(td0, "class", "svelte-yo85j4");
    			add_location(td0, file$j, 229, 8, 8994);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "id", input1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-add-value");
    			add_location(input1, file$j, 238, 11, 9260);
    			attr_dev(td1, "class", "svelte-yo85j4");
    			add_location(td1, file$j, 237, 8, 9244);
    			button.disabled = /*readyToAdd*/ ctx[1];
    			attr_dev(button, "id", button_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-add");
    			attr_dev(button, "class", "cc-module-config-metadata-add");
    			add_location(button, file$j, 246, 11, 9511);
    			attr_dev(td2, "class", "svelte-yo85j4");
    			add_location(td2, file$j, 245, 8, 9495);
    			add_location(tr1, file$j, 228, 6, 8980);
    			add_location(tbody, file$j, 227, 4, 8965);
    			add_location(table, file$j, 207, 2, 8443);
    			attr_dev(div2, "class", "cc-module-config-additional-metadata border border-trbl svelte-yo85j4");
    			add_location(div2, file$j, 206, 0, 8370);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, table);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(th0, t0);
    			append_dev(th0, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t1);
    			append_dev(sl_tooltip0, i0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(th1, t3);
    			append_dev(th1, sl_tooltip1);
    			append_dev(sl_tooltip1, div1);
    			div1.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t4);
    			append_dev(sl_tooltip1, i1);
    			append_dev(tr0, t5);
    			append_dev(tr0, th2);
    			append_dev(table, t7);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			append_dev(tr1, t8);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			append_dev(tr1, t9);
    			append_dev(tr1, td2);
    			append_dev(td2, button);
    			append_dev(button, t10);
    			append_dev(tbody, t11);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keydown", stop_propagation(/*keydown_handler*/ ctx[12]), false, false, true),
    					listen_dev(input0, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(input1, "keydown", stop_propagation(/*keydown_handler_1*/ ctx[11]), false, false, true),
    					listen_dev(input1, "keyup", /*keyup_handler_1*/ ctx[14], false, false, false),
    					listen_dev(button, "click", /*addMetaData*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*moduleId*/ 1 && input0_id_value !== (input0_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-add-name")) {
    				attr_dev(input0, "id", input0_id_value);
    			}

    			if (dirty & /*moduleId*/ 1 && input1_id_value !== (input1_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-add-value")) {
    				attr_dev(input1, "id", input1_id_value);
    			}

    			if (dirty & /*readyToAdd*/ 2) {
    				prop_dev(button, "disabled", /*readyToAdd*/ ctx[1]);
    			}

    			if (dirty & /*moduleId*/ 1 && button_id_value !== (button_id_value = "cc-module-config-" + /*moduleId*/ ctx[0] + "-metadata-add")) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*moduleId, Object, $collectionsStore, deleteMetaData, changeMetaDataValue, String, changeMetaDataName*/ 229) {
    				each_value = Object.entries(/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[0]].metadata);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(19, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModuleMetaDataConfiguration', slots, []);
    	let { moduleId } = $$props;
    	let readyToAdd = true;

    	/**
     * @function addMetaData
     * @description Add a new name/value pair to the metadata for the module, including
     * - ignore empty name and value
     * - check for duplicate name, don't add
     * TODO
     * - sanitize the name and value
     *
     */
    	function addMetaData(event) {
    		const name = document.getElementById(`cc-module-config-${moduleId}-metadata-add-name`);
    		const value = document.getElementById(`cc-module-config-${moduleId}-metadata-add-value`);

    		// Not required as the form action prevents either case
    		/*if (name.value === "" || value.value === "") {
          if (name.value==="") {
            toastAlert("<p>A new meta data item must have a <em>name</em> to be added.</p>",
            "danger")
          }
          if (value.value) {
            toastAlert("<p>The <em>value</em> for the new meta data item is empty</p>",
            "warning" )
          }
          return;
        } */
    		// do some sanitisation of the HTML https://github.com/apostrophecms/sanitize-html
    		// - value will be allowed HTML, including iframes
    		// - name is not allowed HTML
    		const sanitisedName = sanitize(name.value, false);

    		const sanitisedValue = sanitize(value.value);

    		// if the sanitised name is different to the original, warn the user
    		// also warn if the sanitised name is empty
    		if (sanitisedName !== name.value || sanitisedName === "") {
    			ccConfirm(`<p>The new metadata name <xmp>${name.value}</xmp> has been sanitised 
          (removing/replacing forbidden characters) to <xmp>${sanitisedName}</xmp> 
(If the sanitised name is empty, the metadata item will not be added.)</p>
 <p>Are you happy to use the sanitised name?</p>`).then(ok => {
    				if (!ok) {
    					return;
    				}

    				if (sanitisedName === "") {
    					return;
    				}

    				handleAddMetaData(name, value, sanitisedName, sanitisedValue);
    			});
    		} else {
    			handleAddMetaData(name, value, sanitisedName, sanitisedValue);
    		}
    	}

    	function handleAddMetaData(name, value, sanitisedName, sanitisedValue) {
    		// check for duplicate of existing name
    		if ($collectionsStore["MODULES"][moduleId].metadata.hasOwnProperty([name.value])) {
    			toastAlert(
    				`<p>There already exists a metadata entry with the name</p>
        <p style="margin-left: 1em">${name.value}</p>`,
    				"danger"
    			);

    			name.value = "";
    			return;
    		}

    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].metadata[sanitisedName] = sanitisedValue, $collectionsStore);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    		name.value = "";
    		value.value = "";

    		// set focus back to the name field
    		name.focus();
    	}

    	/**
     * @function sanitize
     * @param {string} value - the value to be sanitised
     * @param {boolean} allowHtml - whether to allow HTML or not
     * @returns {string} - the sanitised value
     * @description Allow HTML, including iframes but do other sanity checks
     */
    	function sanitize(value, allowHtml = true) {
    		let allowedTags = sanitizeHtml_1.defaults.allowedTags;
    		let allowedAttributes = {};
    		allowedTags = allowedTags.concat("iframe");

    		allowedAttributes = {
    			iframe: ["src", "width", "height", "frameborder", "allowfullscreen"]
    		};

    		if (!allowHtml) {
    			allowedTags = [];
    			allowedAttributes = {};
    		}

    		return sanitizeHtml_1(value, { allowedTags, allowedAttributes });
    	}

    	/**
     * @function readyToAdd
     * @description Check if the name and value fields have values and
     * are ready to add a new metadata entry
     */
    	function isReadyToAdd() {
    		const name = document.getElementById(`cc-module-config-${moduleId}-metadata-add-name`);
    		const value = document.getElementById(`cc-module-config-${moduleId}-metadata-add-value`);

    		if (name.value === "" || value.value === "") {
    			return true;
    		}

    		return false;
    	}

    	/**
     * @function deleteMetaData
     * @param {string} key - the name of the metadata entry to delete
     * @description Delete a metadata entry
     */
    	function deleteMetaData(key) {
    		// check if they really want to delete
    		const moduleName = $collectionsStore["MODULES"][moduleId].name;

    		ccConfirm(`<p>About to delete the metadata entry<br /> 
        <span style="margin:1em">${key}</span><br /> for the module <br />
    <span style="margin:1em">${moduleName}<span></p>
      <p>Proceed?</p>`).then(ok => {
    			if (ok) {
    				// create a complete new object to remove the key
    				// Necessary to ensure the reactive display of the list of metadata
    				// removes the correct entry (it doesn't if you just delete from the existing object)
    				let metadata = $collectionsStore["MODULES"][moduleId].metadata;

    				delete metadata[key];

    				// force the reactive update of the entire list of metadata
    				set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].metadata = metadata, $collectionsStore);

    				set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    			}
    		});
    	}

    	/**
     * @function changeMetaDataName
     * @param {String} originalName - the original name of the metadata entry
     * @description User has released a key to change the name field of a metadata entry
     * - make a copy of the metadata object
     * - add the new entry as a copy from the original entry
     * - delete the original entry
     * - reassign the original metadata object to the copy
     */
    	function changeMetaDataName(originalName) {
    		const name = document.getElementById(`cc-module-config-${moduleId}-metadata-${originalName}-name`);

    		// if no change in name, nothing to do
    		if (originalName === name.value) {
    			return;
    		}

    		// check for duplicate of existing name
    		if ($collectionsStore["MODULES"][moduleId].metadata.hasOwnProperty([name.value])) {
    			toastAlert(
    				`<p>There already exists a metadata entry with the name</p>
    <div style="margin-left: 1em">${name.value}</div>
    <p>Please choose a different name.</p>`,
    				"danger"
    			);

    			name.value = originalName;
    			return;
    		}

    		let metadata = $collectionsStore["MODULES"][moduleId].metadata;
    		metadata[name.value] = metadata[originalName];
    		delete metadata[originalName];
    		set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].metadata = metadata, $collectionsStore);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	/**
     * @function changeMetaDataValue
     * @param {String} name - the name of the metadata entry
     * @description User has modified the value for a metadata entry
     * - sanitise the value
     * - report any sanitisation change to the user
     * - modify the value
     * - set the needToSaveCollections flag
     */
    	function changeMetaDataValue(name) {
    		const value = document.getElementById(`cc-module-config-${moduleId}-metadata-${name}-value`);
    		const sanitisedValue = sanitize(value.value);

    		// if the sanitised value is different to the original, warn the user
    		if (sanitisedValue !== value.value) {
    			ccConfirm(`<p>The new metadata item value</p> 
    <div style="margin-left:1em"><xmp>${value.value}</xmp></div>
<p>has been sanitised to</p>
    <div style="margin-left:1em"><xmp>${sanitisedValue}</xmp></div>
    <p>Do you want to use the sanitised value?</p>`).then(ok => {
    				if (ok) {
    					set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].metadata[name] = sanitisedValue, $collectionsStore);
    					set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    				}
    			});
    		} else {
    			set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].metadata[name] = sanitisedValue, $collectionsStore);
    			set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    		}
    	}

    	//------------- HELP tooltips and urls
    	const HELP = {
    		name: {
    			tooltip: `<p>Each metadata value is given a name. Only certain characters can be used. No HTML tags allowed.<p>
			<p>Changes will only take effect when you move focus away from the name field.</p>`
    		},
    		value: {
    			tooltip: `<p>The value for the metadata element. HTML tags are allowed.</p>`
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<ModuleMetaDataConfiguration> was created without expected prop 'moduleId'");
    		}
    	});

    	const writable_props = ['moduleId'];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModuleMetaDataConfiguration> was created with unknown prop '${key}'`);
    	});

    	function keydown_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const keyup_handler = () => $$invalidate(1, readyToAdd = isReadyToAdd());
    	const keyup_handler_1 = () => $$invalidate(1, readyToAdd = isReadyToAdd());
    	const focusout_handler = key => changeMetaDataName(key);
    	const focusout_handler_1 = key => changeMetaDataValue(key);
    	const click_handler = key => deleteMetaData(key);
    	const keydown_handler_4 = key => deleteMetaData(key);

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    	};

    	$$self.$capture_state = () => ({
    		sanitizeHtml: sanitizeHtml_1,
    		collectionsStore,
    		configStore,
    		toastAlert,
    		ccConfirm,
    		moduleId,
    		readyToAdd,
    		addMetaData,
    		handleAddMetaData,
    		sanitize,
    		isReadyToAdd,
    		deleteMetaData,
    		changeMetaDataName,
    		changeMetaDataValue,
    		HELP,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(0, moduleId = $$props.moduleId);
    		if ('readyToAdd' in $$props) $$invalidate(1, readyToAdd = $$props.readyToAdd);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		moduleId,
    		readyToAdd,
    		$collectionsStore,
    		addMetaData,
    		isReadyToAdd,
    		deleteMetaData,
    		changeMetaDataName,
    		changeMetaDataValue,
    		HELP,
    		keydown_handler_3,
    		keydown_handler_2,
    		keydown_handler_1,
    		keydown_handler,
    		keyup_handler,
    		keyup_handler_1,
    		focusout_handler,
    		focusout_handler_1,
    		click_handler,
    		keydown_handler_4
    	];
    }

    class ModuleMetaDataConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { moduleId: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModuleMetaDataConfiguration",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<ModuleMetaDataConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<ModuleMetaDataConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\ModuleConfiguration.svelte generated by Svelte v3.55.0 */
    const file$i = "src\\components\\ModuleConfiguration.svelte";

    // (47:2) {#if !allocated}
    function create_if_block_1$d(ctx) {
    	let div;
    	let t;
    	let div_id_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("No collection allocated");
    			attr_dev(div, "class", "cc-module-no-collection svelte-1mjrzc0");
    			attr_dev(div, "id", div_id_value = "cc-module-config-no-collection-" + /*module*/ ctx[0]);
    			add_location(div, file$i, 47, 4, 2811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*module*/ 1 && div_id_value !== (div_id_value = "cc-module-config-no-collection-" + /*module*/ ctx[0])) {
    				attr_dev(div, "id", div_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(47:2) {#if !allocated}",
    		ctx
    	});

    	return block;
    }

    // (83:0) {#if $collectionsStore["MODULES"][module].configVisible}
    function create_if_block$f(ctx) {
    	let div5;
    	let sl_tab_group;
    	let sl_tab0;
    	let t0;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[4].generalTab.tooltip + "";
    	let t1;
    	let a0;
    	let i0;
    	let t2;
    	let sl_tab1;
    	let t3;
    	let sl_tooltip1;
    	let div1;
    	let raw1_value = /*HELP*/ ctx[4].moduleDates.tooltip + "";
    	let t4;
    	let a1;
    	let i1;
    	let t5;
    	let sl_tab2;
    	let t6;
    	let sl_tooltip2;
    	let div2;
    	let raw2_value = /*HELP*/ ctx[4].moduleBanner.tooltip + "";
    	let t7;
    	let a2;
    	let i2;
    	let t8;
    	let sl_tab3;
    	let div4;
    	let t9;
    	let sl_tooltip3;
    	let div3;
    	let raw3_value = /*HELP*/ ctx[4].moduleMetaData.tooltip + "";
    	let t10;
    	let a3;
    	let i3;
    	let t11;
    	let sl_tab_panel0;
    	let modulegeneralconfiguration;
    	let t12;
    	let sl_tab_panel1;
    	let moduledateconfiguration;
    	let t13;
    	let sl_tab_panel2;
    	let modulebannerconfiguration;
    	let t14;
    	let sl_tab_panel3;
    	let modulemetadataconfiguration;
    	let current;

    	modulegeneralconfiguration = new ModuleGeneralConfiguration({
    			props: { moduleId: /*module*/ ctx[0] },
    			$$inline: true
    		});

    	moduledateconfiguration = new ModuleDateConfiguration({
    			props: { moduleId: /*module*/ ctx[0] },
    			$$inline: true
    		});

    	modulebannerconfiguration = new ModuleBannerConfiguration({
    			props: { moduleId: /*module*/ ctx[0] },
    			$$inline: true
    		});

    	modulemetadataconfiguration = new ModuleMetaDataConfiguration({
    			props: { moduleId: /*module*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			sl_tab_group = element("sl-tab-group");
    			sl_tab0 = element("sl-tab");
    			t0 = text("General \r\n        ");
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t1 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t2 = space();
    			sl_tab1 = element("sl-tab");
    			t3 = text("Dates \r\n        ");
    			sl_tooltip1 = element("sl-tooltip");
    			div1 = element("div");
    			t4 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t5 = space();
    			sl_tab2 = element("sl-tab");
    			t6 = text("Banner \r\n        ");
    			sl_tooltip2 = element("sl-tooltip");
    			div2 = element("div");
    			t7 = space();
    			a2 = element("a");
    			i2 = element("i");
    			t8 = space();
    			sl_tab3 = element("sl-tab");
    			div4 = element("div");
    			t9 = text("Metadata\r\n          ");
    			sl_tooltip3 = element("sl-tooltip");
    			div3 = element("div");
    			t10 = space();
    			a3 = element("a");
    			i3 = element("i");
    			t11 = space();
    			sl_tab_panel0 = element("sl-tab-panel");
    			create_component(modulegeneralconfiguration.$$.fragment);
    			t12 = space();
    			sl_tab_panel1 = element("sl-tab-panel");
    			create_component(moduledateconfiguration.$$.fragment);
    			t13 = space();
    			sl_tab_panel2 = element("sl-tab-panel");
    			create_component(modulebannerconfiguration.$$.fragment);
    			t14 = space();
    			sl_tab_panel3 = element("sl-tab-panel");
    			create_component(modulemetadataconfiguration.$$.fragment);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$i, 88, 10, 3978);
    			attr_dev(i0, "class", "icon-question");
    			add_location(i0, file$i, 95, 12, 4211);
    			attr_dev(a0, "href", /*HELP*/ ctx[4].generalTab.url);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "class", "cc-module-link");
    			add_location(a0, file$i, 89, 10, 4047);
    			set_custom_element_data(sl_tooltip0, "hoist", "");
    			set_custom_element_data(sl_tooltip0, "class", "svelte-1mjrzc0");
    			add_location(sl_tooltip0, file$i, 87, 8, 3948);
    			set_custom_element_data(sl_tab0, "slot", "nav");
    			set_custom_element_data(sl_tab0, "panel", "general");
    			set_style(sl_tab0, "text-align", "right");
    			set_custom_element_data(sl_tab0, "class", "svelte-1mjrzc0");
    			add_location(sl_tab0, file$i, 85, 6, 3854);
    			attr_dev(div1, "slot", "content");
    			add_location(div1, file$i, 102, 10, 4416);
    			attr_dev(i1, "class", "icon-question");
    			add_location(i1, file$i, 109, 12, 4651);
    			attr_dev(a1, "href", /*HELP*/ ctx[4].moduleDates.url);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			attr_dev(a1, "class", "cc-module-link");
    			add_location(a1, file$i, 103, 10, 4486);
    			set_custom_element_data(sl_tooltip1, "class", "svelte-1mjrzc0");
    			add_location(sl_tooltip1, file$i, 101, 8, 4392);
    			set_custom_element_data(sl_tab1, "slot", "nav");
    			set_custom_element_data(sl_tab1, "panel", "dates");
    			set_style(sl_tab1, "text-align", "right");
    			set_custom_element_data(sl_tab1, "class", "svelte-1mjrzc0");
    			add_location(sl_tab1, file$i, 99, 6, 4302);
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$i, 116, 10, 4858);
    			attr_dev(i2, "class", "icon-question");
    			add_location(i2, file$i, 118, 13, 5008);
    			attr_dev(a2, "href", /*HELP*/ ctx[4].moduleBanner.url);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noreferrer");
    			add_location(a2, file$i, 117, 10, 4929);
    			set_custom_element_data(sl_tooltip2, "class", "svelte-1mjrzc0");
    			add_location(sl_tooltip2, file$i, 115, 8, 4834);
    			set_custom_element_data(sl_tab2, "slot", "nav");
    			set_custom_element_data(sl_tab2, "panel", "banner");
    			set_style(sl_tab2, "text-align", "right");
    			set_custom_element_data(sl_tab2, "class", "svelte-1mjrzc0");
    			add_location(sl_tab2, file$i, 113, 6, 4742);
    			attr_dev(div3, "slot", "content");
    			add_location(div3, file$i, 126, 12, 5239);
    			attr_dev(i3, "class", "icon-question");
    			add_location(i3, file$i, 128, 14, 5397);
    			attr_dev(a3, "href", /*HELP*/ ctx[4].moduleMetaData.url);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "rel", "noreferrer");
    			add_location(a3, file$i, 127, 12, 5314);
    			set_custom_element_data(sl_tooltip3, "class", "svelte-1mjrzc0");
    			add_location(sl_tooltip3, file$i, 125, 10, 5213);
    			add_location(div4, file$i, 123, 8, 5170);
    			set_custom_element_data(sl_tab3, "slot", "nav");
    			set_custom_element_data(sl_tab3, "panel", "metadata");
    			set_style(sl_tab3, "text-align", "right");
    			set_custom_element_data(sl_tab3, "class", "svelte-1mjrzc0");
    			add_location(sl_tab3, file$i, 122, 6, 5099);
    			set_custom_element_data(sl_tab_panel0, "name", "general");
    			add_location(sl_tab_panel0, file$i, 134, 6, 5510);
    			set_custom_element_data(sl_tab_panel1, "name", "dates");
    			add_location(sl_tab_panel1, file$i, 137, 6, 5628);
    			set_custom_element_data(sl_tab_panel2, "name", "banner");
    			add_location(sl_tab_panel2, file$i, 140, 6, 5741);
    			set_custom_element_data(sl_tab_panel3, "name", "metadata");
    			add_location(sl_tab_panel3, file$i, 143, 6, 5857);
    			set_custom_element_data(sl_tab_group, "placement", "start");
    			add_location(sl_tab_group, file$i, 84, 4, 3814);
    			attr_dev(div5, "class", "cc-module-config-tabs border border-trbl svelte-1mjrzc0");
    			add_location(div5, file$i, 83, 2, 3754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, sl_tab_group);
    			append_dev(sl_tab_group, sl_tab0);
    			append_dev(sl_tab0, t0);
    			append_dev(sl_tab0, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t1);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			append_dev(sl_tab_group, t2);
    			append_dev(sl_tab_group, sl_tab1);
    			append_dev(sl_tab1, t3);
    			append_dev(sl_tab1, sl_tooltip1);
    			append_dev(sl_tooltip1, div1);
    			div1.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t4);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(sl_tab_group, t5);
    			append_dev(sl_tab_group, sl_tab2);
    			append_dev(sl_tab2, t6);
    			append_dev(sl_tab2, sl_tooltip2);
    			append_dev(sl_tooltip2, div2);
    			div2.innerHTML = raw2_value;
    			append_dev(sl_tooltip2, t7);
    			append_dev(sl_tooltip2, a2);
    			append_dev(a2, i2);
    			append_dev(sl_tab_group, t8);
    			append_dev(sl_tab_group, sl_tab3);
    			append_dev(sl_tab3, div4);
    			append_dev(div4, t9);
    			append_dev(div4, sl_tooltip3);
    			append_dev(sl_tooltip3, div3);
    			div3.innerHTML = raw3_value;
    			append_dev(sl_tooltip3, t10);
    			append_dev(sl_tooltip3, a3);
    			append_dev(a3, i3);
    			append_dev(sl_tab_group, t11);
    			append_dev(sl_tab_group, sl_tab_panel0);
    			mount_component(modulegeneralconfiguration, sl_tab_panel0, null);
    			append_dev(sl_tab_group, t12);
    			append_dev(sl_tab_group, sl_tab_panel1);
    			mount_component(moduledateconfiguration, sl_tab_panel1, null);
    			append_dev(sl_tab_group, t13);
    			append_dev(sl_tab_group, sl_tab_panel2);
    			mount_component(modulebannerconfiguration, sl_tab_panel2, null);
    			append_dev(sl_tab_group, t14);
    			append_dev(sl_tab_group, sl_tab_panel3);
    			mount_component(modulemetadataconfiguration, sl_tab_panel3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modulegeneralconfiguration_changes = {};
    			if (dirty & /*module*/ 1) modulegeneralconfiguration_changes.moduleId = /*module*/ ctx[0];
    			modulegeneralconfiguration.$set(modulegeneralconfiguration_changes);
    			const moduledateconfiguration_changes = {};
    			if (dirty & /*module*/ 1) moduledateconfiguration_changes.moduleId = /*module*/ ctx[0];
    			moduledateconfiguration.$set(moduledateconfiguration_changes);
    			const modulebannerconfiguration_changes = {};
    			if (dirty & /*module*/ 1) modulebannerconfiguration_changes.moduleId = /*module*/ ctx[0];
    			modulebannerconfiguration.$set(modulebannerconfiguration_changes);
    			const modulemetadataconfiguration_changes = {};
    			if (dirty & /*module*/ 1) modulemetadataconfiguration_changes.moduleId = /*module*/ ctx[0];
    			modulemetadataconfiguration.$set(modulemetadataconfiguration_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modulegeneralconfiguration.$$.fragment, local);
    			transition_in(moduledateconfiguration.$$.fragment, local);
    			transition_in(modulebannerconfiguration.$$.fragment, local);
    			transition_in(modulemetadataconfiguration.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modulegeneralconfiguration.$$.fragment, local);
    			transition_out(moduledateconfiguration.$$.fragment, local);
    			transition_out(modulebannerconfiguration.$$.fragment, local);
    			transition_out(modulemetadataconfiguration.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(modulegeneralconfiguration);
    			destroy_component(moduledateconfiguration);
    			destroy_component(modulebannerconfiguration);
    			destroy_component(modulemetadataconfiguration);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(83:0) {#if $collectionsStore[\\\"MODULES\\\"][module].configVisible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div1;
    	let t0;
    	let span;
    	let i0;
    	let i0_id_value;
    	let i0_class_value;
    	let t1;
    	let em;
    	let raw_value = /*$collectionsStore*/ ctx[1]["MODULES"][/*module*/ ctx[0]].name + "";
    	let t2;
    	let sl_tooltip;
    	let div0;
    	let t4;
    	let a;
    	let i1;
    	let div1_id_value;
    	let t5;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*allocated*/ ctx[2] && create_if_block_1$d(ctx);
    	let if_block1 = /*$collectionsStore*/ ctx[1]["MODULES"][/*module*/ ctx[0]].configVisible && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			span = element("span");
    			i0 = element("i");
    			t1 = text("\r\n\r\n    Configure Collections for\r\n    ");
    			em = element("em");
    			t2 = space();
    			sl_tooltip = element("sl-tooltip");
    			div0 = element("div");
    			div0.textContent = `${/*HELP*/ ctx[4].moduleConfiguration.tooltip}`;
    			t4 = space();
    			a = element("a");
    			i1 = element("i");
    			t5 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(i0, "id", i0_id_value = "cc-module-config-" + /*module*/ ctx[0] + "-switch");

    			attr_dev(i0, "class", i0_class_value = /*$collectionsStore*/ ctx[1]["MODULES"][/*module*/ ctx[0]].configVisible
    			? "icon-mini-arrow-down"
    			: "icon-mini-arrow-right");

    			add_location(i0, file$i, 55, 4, 2981);
    			add_location(em, file$i, 65, 4, 3294);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$i, 67, 6, 3378);
    			attr_dev(i1, "class", "icon-question");
    			add_location(i1, file$i, 76, 8, 3613);
    			attr_dev(a, "href", /*HELP*/ ctx[4].moduleConfiguration.url);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "cc-module-link");
    			add_location(a, file$i, 70, 6, 3464);
    			set_custom_element_data(sl_tooltip, "class", "svelte-1mjrzc0");
    			add_location(sl_tooltip, file$i, 66, 4, 3358);
    			add_location(span, file$i, 54, 2, 2969);
    			attr_dev(div1, "class", "cc-module-config border border-trbl svelte-1mjrzc0");
    			attr_dev(div1, "id", div1_id_value = "cc-module-config-" + /*module*/ ctx[0]);
    			add_location(div1, file$i, 45, 0, 2705);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, span);
    			append_dev(span, i0);
    			append_dev(span, t1);
    			append_dev(span, em);
    			em.innerHTML = raw_value;
    			append_dev(span, t2);
    			append_dev(span, sl_tooltip);
    			append_dev(sl_tooltip, div0);
    			append_dev(sl_tooltip, t4);
    			append_dev(sl_tooltip, a);
    			append_dev(a, i1);
    			insert_dev(target, t5, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(i0, "click", /*toggleModuleConfigShow*/ ctx[3], false, false, false),
    					listen_dev(i0, "keydown", /*toggleModuleConfigShow*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*allocated*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$d(ctx);
    					if_block0.c();
    					if_block0.m(div1, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*module*/ 1 && i0_id_value !== (i0_id_value = "cc-module-config-" + /*module*/ ctx[0] + "-switch")) {
    				attr_dev(i0, "id", i0_id_value);
    			}

    			if (!current || dirty & /*$collectionsStore, module*/ 3 && i0_class_value !== (i0_class_value = /*$collectionsStore*/ ctx[1]["MODULES"][/*module*/ ctx[0]].configVisible
    			? "icon-mini-arrow-down"
    			: "icon-mini-arrow-right")) {
    				attr_dev(i0, "class", i0_class_value);
    			}

    			if ((!current || dirty & /*$collectionsStore, module*/ 3) && raw_value !== (raw_value = /*$collectionsStore*/ ctx[1]["MODULES"][/*module*/ ctx[0]].name + "")) em.innerHTML = raw_value;
    			if (!current || dirty & /*module*/ 1 && div1_id_value !== (div1_id_value = "cc-module-config-" + /*module*/ ctx[0])) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (/*$collectionsStore*/ ctx[1]["MODULES"][/*module*/ ctx[0]].configVisible) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$collectionsStore, module*/ 3) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$f(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t5);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let allocated;
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(5, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(1, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModuleConfiguration', slots, []);
    	let { module } = $$props;

    	function toggleModuleConfigShow() {
    		set_store_value(collectionsStore, $collectionsStore["MODULES"][module].configVisible = !$collectionsStore["MODULES"][module].configVisible, $collectionsStore);
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	const HELP = {
    		moduleConfiguration: {
    			tooltip: "Click the arrow to open/close the Collections interface to configure data about this module",
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/new/configure-modules/"
    		},
    		generalTab: {
    			tooltip: "Configure common collections settings: collections, description, label, engage button etc."
    		},
    		moduleDates: {
    			tooltip: `<p>Choose from the three supported "date types" and configure it. Options include:</p> <ol> <li> <strong>Single date</strong> - a specific date (and time) </li>
		  <li> <strong>Date range</strong> - a start and end date (and time) </li>
		  <li>  <strong>Coming soon</strong>  - (soon you'll be able to) specify a single date (and time) when the module will be available.</li>
		</ol>
		<p><em>Coming Soon</em> will be able to be used with one of the other options</em></p>
		`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#dates"
    		},
    		moduleBanner: {
    			tooltip: `<p>Choose one of three possible banner types (for Card representations) and configure it. Options are:</p> <ol> <li> <strong>Image</strong> - a banner image</li> <li> <strong>Colour</strong> - a solid colour</li> <li> <strong>Iframe</strong> - HTML embed code (e.g. YouTube video)</li> </ol>
		`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#dates"
    		},
    		moduleMetaData: {
    			tooltip: `Flexibly add, delete, and modify additional information about this module, which
		may be used by collections and representations - or for your own purposes.`,
    			url: "https://djplaner.github.io/canvas-collections/reference/objects/overview/#additional-metadata"
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (module === undefined && !('module' in $$props || $$self.$$.bound[$$self.$$.props['module']])) {
    			console.warn("<ModuleConfiguration> was created without expected prop 'module'");
    		}
    	});

    	const writable_props = ['module'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModuleConfiguration> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('module' in $$props) $$invalidate(0, module = $$props.module);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		ModuleDateConfiguration,
    		ModuleGeneralConfiguration,
    		ModuleBannerConfiguration,
    		ModuleMetaDataConfiguration,
    		removeModuleConfiguration,
    		module,
    		toggleModuleConfigShow,
    		HELP,
    		allocated,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('module' in $$props) $$invalidate(0, module = $$props.module);
    		if ('allocated' in $$props) $$invalidate(2, allocated = $$props.allocated);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$collectionsStore, module*/ 3) {
    			$$invalidate(2, allocated = $collectionsStore["MODULES"][module].collection !== null && $collectionsStore["MODULES"][module].collection !== "");
    		}
    	};

    	return [module, $collectionsStore, allocated, toggleModuleConfigShow, HELP];
    }

    class ModuleConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { module: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModuleConfiguration",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get module() {
    		throw new Error("<ModuleConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set module(value) {
    		throw new Error("<ModuleConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @function getCollectionCanvasModules
     * @param collection - Collection name
     * @returns {module[]} - Array of modules
     * @description - Returns an array of module belonging to a given collection
     */
    function getCollectionCanvasModules(collection) {
        let modules = [];
        // collection store is not the Canvas modules (collections modules)
        const cStore = get_store_value(collectionsStore);
        const figStore = get_store_value(configStore);
        const editMode = figStore["editMode"];
        const collectionsModules = cStore["MODULES"];
        const canvasModules = get_store_value(modulesStore);
        // track the module ids we add to the list
        let addedModuleIds = [];
        canvasModules.forEach((module) => {
            // for each canvas module
            const moduleId = module.id;
            if (collectionsModules[moduleId].collection === collection) {
                // if the module belongs to the selected collection
                // push the canvas module onto the array
                modules.push(module);
                addedModuleIds.push(moduleId);
            }
        });
        // Add in any FYI modules
        if (!editMode) {
            for (const moduleId in collectionsModules) {
                // find the fyi module's not already added above, in this collection
                if (collectionsModules[moduleId].collection === collection &&
                    !addedModuleIds.includes(moduleId) &&
                    collectionsModules[moduleId].fyi) {
                    // if the module belongs to the selected collection
                    // push the canvas module onto the array
                    modules.push(collectionsModules[moduleId]);
                }
            }
        }
        return modules;
    }
    /**
     * @function addUnallocatedModules
     * @param collectionName
     * @param editMode
     * @returns [] - Array of modules
     * @description Return an array of all the modules that do not have a collection
     * i.e. collection===null
     */
    function addUnallocatedModules(editMode) {
        let modules = [];
        const cStore = get_store_value(collectionsStore);
        const collectionsModules = cStore["MODULES"];
        for (const module in collectionsModules) {
            if (collectionsModules[module]["collection"] === null ||
                collectionsModules[module]["collection"] === "") {
                if (editMode || collectionsModules[module]["published"]) {
                    modules.push(collectionsModules[module]);
                }
            }
        }
        return modules;
    }
    /**
     * @function getRepresentationModules
     * @param String collectionName - name of "current" collection
     * @param boolean unallocated
     * @returns [] - Array of modules
     * @description Given a collection, get all the modules that a representation
     * will need to display that collection, may include
     * - all the modules in the collection
     * - all the modules without collections (if that switch is set)
     *
     */
    function getRepresentationModules(collectionName, 
    /* allModules: any[],
    editMode: boolean, */
    claytons, unallocated) {
        let modules = [];
        const config = get_store_value(configStore);
        const editMode = config["editMode"];
        // is the problem that we're starting with the Canvas modules
        modules = getCollectionCanvasModules(collectionName);
        // add unallocated modules if,
        if (editMode) {
            // student only if unallocated for this collection is true
            if (unallocated && !claytons) {
                modules = modules.concat(addUnallocatedModules(editMode));
            }
            //} else if ((claytons && unallocated) || !claytons) {
        }
        else {
            // for students, they should be able to see
            // - modules not allocated to this collection, if unallocated is true
            // - fyi modules, i.e. fyi is set
            if (unallocated) {
                modules = modules.concat(addUnallocatedModules(editMode));
            }
        }
        return modules;
    }
    /**
     * @function checkModuleMetaData
     * @param module : string
     * @param metaDataValue : string
     * @returns string - the value to display in the table for the metaDataValue
     * Will return
     * - the value of the metadataValue if it exists
     * - the string {metaDataValue} if it does not exist and we're in editMode
     * - an empty string if it does not exist and we're not in editMode
     */
    function checkModuleMetaData(module, metaDataValue, editMode, claytons = false) {
        if (module.hasOwnProperty("metadata") &&
            module["metadata"].hasOwnProperty(metaDataValue)) {
            return module["metadata"][metaDataValue];
        }
        if (editMode && !claytons) {
            return `{${metaDataValue}}`;
        }
        return "";
    }
    /**
     * @function generateModuleDate
     * @param module
     * @return string - the date to display in the table
     * Handle the conversion of a module's collection date (if any) into a
     * string to insert into the table
     */
    function generateModuleDate(module) {
        // TODO need generateCalendarDate properly
        if (!module.hasOwnProperty("date") || !isNotEmptyDate$1(module.date)) {
            return "";
        }
        let dateStr = module.date.label;
        if (!module.dateHide["day"]) {
            dateStr += ` ${module.date.day}`;
        }
        if (!module.dateHide["week"]) {
            dateStr += ` Week ${module.date.week}`;
        }
        if (!module.dateHide["calendarDate"]) {
            dateStr += ` (${module.date.date} ${module.date.month})`;
        }
        if (!module.dateHide["time"] && module.date.time !== "") {
            dateStr += ` ${module.date.time}`;
        }
        return dateStr;
    }
    function isNotEmptyDate$1(date) {
        return ((date.hasOwnProperty("week") && date["week"] !== "") ||
            (date.hasOwnProperty("month") && date["month"] !== "") ||
            (date.hasOwnProperty("date") && date["date"] !== "") ||
            (date.hasOwnProperty("day") && date["day"] !== "") ||
            (date.hasOwnProperty("time") && date["time"] !== ""));
    }
    /**
     * @function modifyCanvasModulesList
     * @param collection  - string for current collection
     * @param editMode - whether we're in editMode or not
     * @param showUnallocated - whether to show unallocated modules or not
     * @description Modify Canvas's display of modules in three possible ways
     * 1. Hide all modules with collection defined and not in collection
     * 2. Ensure all modules in collection are showing
     * 3. If editMode add ModuleConfiguration components to the module
     */
    function modifyCanvasModulesList(collection, showUnallocated) {
        const collections = get_store_value(collectionsStore);
        const allModules = collections["MODULES"];
        const config = get_store_value(configStore);
        const editMode = config["editMode"];
        const modules = getCollectionCanvasModules(collection);
        // create array moduleIds that contains the module.ids from modules
        const moduleIds = modules.map((module) => {
            return parseInt(module.id, 10);
        });
        // get all the moduleIds from modules not in moduleIds
        // - allModules is a list of modules ?? dict??
        // -
        const otherModuleIds = Object.keys(allModules).filter((moduleId) => {
            return !moduleIds.includes(parseInt(moduleId, 10));
        });
        // for other modules
        // - if collection is not null hide the module
        // - if null, create an unallocated ModuleConfiguration
        otherModuleIds.forEach((moduleId) => {
            const module = document.getElementById(`context_module_${moduleId}`);
            if (module) {
                if (allModules[moduleId].collection !== null &&
                    allModules[moduleId].collection !== "") {
                    // hide any Canvas module elements that have a collection defined but
                    // are not the current collection
                    module.style.display = "none";
                }
                else {
                    if (editMode) {
                        // in edit mode ensure that unallocated modules are visible and
                        // have a ModuleConfiguration component
                        module.style.display = "block";
                        addModuleConfiguration(parseInt(moduleId, 10));
                    }
                    else {
                        if (showUnallocated) {
                            // make sure that unallocated modules are visible
                            module.style.display = "block";
                        }
                        else {
                            module.style.display = "none";
                        }
                    }
                }
            }
        });
        // ensure all the moduleIds are displayed
        moduleIds.forEach((moduleId) => {
            // make sure that these are displayed
            if (editMode) {
                addModuleConfiguration(moduleId);
            }
            // make each current collection moduleId is visible
            const module = document.getElementById(`context_module_${moduleId}`);
            if (module) {
                if (allModules[moduleId].fyi && !editMode) {
                    // fyi modules should not have their content shown to students
                    module.style.display = "none";
                }
                else {
                    module.style.display = "block";
                }
            }
        });
    }
    /**
     * @function addModuleConfiguration
     * @param moduleId
     * @description add an appropriate ModuleConfiguration component to the
     * matching Canvas module element
     */
    function addModuleConfiguration(moduleId) {
        // get type of moduleId
        const module = document.getElementById(`context_module_${moduleId}`);
        if (module) {
            module.style.display = "block";
        }
        // in editMode add div#cc-module-config-<moduleId> after div#<moduleId>
        const insertDiv = document.getElementById(`${moduleId}`);
        if (insertDiv && !document.getElementById(`cc-module-config-${moduleId}`)) {
            const moduleConfig = document.createElement("div");
            moduleConfig.id = `cc-module-config-${moduleId}`;
            //moduleConfig.className = "cc-module-config";
            // insert the moduleConfig after insertDiv
            insertDiv.parentNode.insertBefore(moduleConfig, insertDiv.nextSibling);
            // create new ModuleConfiguration component within moduleConfig
            new ModuleConfiguration({
                target: moduleConfig,
                props: {
                    module: moduleId,
                },
            });
        }
    }
    /**
     * @function getModuleUrl
     * @param {Number} moduleId
     * @returns {String} - the url for a Canvas module's item
     */
    function getModuleUrl(moduleId) {
        let docUrl = new URL(document.URL);
        // remove anchor and params from docUrl
        docUrl.search = "";
        // set the hash to link to the module
        docUrl.hash = `module_${moduleId}`;
        return docUrl.toString();
    }
    /**
     * @function deLabelModuleName
     * @param module - module object
     * @return string Module name without label and number
     * @description Remove the label and number from the name
     */
    function deLabelModuleName(module) {
        //    const module = $collectionsStore["MODULES"][moduleId];
        const existingName = module.name;
        let prepend = "";
        if (module.label) {
            prepend = module.label;
        }
        let regex = new RegExp(`^${prepend}\\s*[:->]\\s*`);
        if (module.actualNum) {
            regex = new RegExp(`^${prepend}\\s*${module.actualNum}\\s*[:>-]\\s*`);
            prepend += ` ${module.actualNum}`;
            // remove first char from CARD_LABEL if it is a space
            if (prepend.charAt(0) === " ") {
                prepend = prepend.substring(1);
            }
        }
        prepend = `${prepend}: `;
        let newName = existingName;
        if (prepend !== ": ") {
            // if we've not empty label and number
            // modify existingName to remove prepend and any subsequent whitespace
            //	newName = existingName.replace(prepend, '').trim();
            newName = existingName.replace(regex, "").trim();
        }
        return newName;
    }

    /* src\components\Representations\GriffithCards\BannerIframe.svelte generated by Svelte v3.55.0 */
    const file$h = "src\\components\\Representations\\GriffithCards\\BannerIframe.svelte";

    // (31:0) {:else}
    function create_else_block$9(ctx) {
    	let div;
    	let if_block = /*$configStore*/ ctx[3]["editMode"] && create_if_block_3$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "cc-banner-colour svelte-5n5pyl");
    			add_location(div, file$h, 31, 2, 897);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$configStore*/ ctx[3]["editMode"]) {
    				if (if_block) ; else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(31:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (22:19) 
    function create_if_block_1$c(ctx) {
    	let div;
    	let if_block = /*$configStore*/ ctx[3]["editMode"] && create_if_block_2$a(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "claytons-banner-colour");
    			set_style(div, "width", "100%");
    			set_style(div, "height", "10rem");
    			set_style(div, "background-color", "#ffffff");
    			add_location(div, file$h, 22, 2, 671);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$configStore*/ ctx[3]["editMode"]) {
    				if (if_block) ; else {
    					if_block = create_if_block_2$a(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(22:19) ",
    		ctx
    	});

    	return block;
    }

    // (20:0) {#if isValidIframe($collectionsStore["MODULES"][moduleId].iframe)}
    function create_if_block$e(ctx) {
    	let html_tag;
    	let raw_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].iframe + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, moduleId*/ 6 && raw_value !== (raw_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].iframe + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(20:0) {#if isValidIframe($collectionsStore[\\\"MODULES\\\"][moduleId].iframe)}",
    		ctx
    	});

    	return block;
    }

    // (33:4) {#if $configStore["editMode"]}
    function create_if_block_3$7(ctx) {
    	let p;
    	let t0;
    	let em;
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("(");
    			em = element("em");
    			em.textContent = "No iframe specified";
    			t2 = text(")");
    			add_location(em, file$h, 33, 10, 975);
    			add_location(p, file$h, 33, 6, 971);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, em);
    			append_dev(p, t2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(33:4) {#if $configStore[\\\"editMode\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (27:4) {#if $configStore["editMode"]}
    function create_if_block_2$a(ctx) {
    	let p;
    	let t0;
    	let em;
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("(");
    			em = element("em");
    			em.textContent = "No iframe specified";
    			t2 = text(")");
    			add_location(em, file$h, 27, 10, 830);
    			add_location(p, file$h, 27, 6, 826);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, em);
    			append_dev(p, t2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(27:4) {#if $configStore[\\\"editMode\\\"]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*$collectionsStore, moduleId*/ 6) show_if = null;
    		if (show_if == null) show_if = !!/*isValidIframe*/ ctx[4](/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].iframe);
    		if (show_if) return create_if_block$e;
    		if (/*claytons*/ ctx[0]) return create_if_block_1$c;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	let $configStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(3, $configStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BannerIframe', slots, []);
    	let { moduleId } = $$props;
    	let { claytons } = $$props;

    	if (!claytons) {
    		claytons = false;
    	}

    	/**
     * @function isValidIframe
     * @param html
     * @returns boolean
     * @description Reactively checks if the iframe value is just
     * an iframe and an iframe alone
     */
    	function isValidIframe(html) {
    		const match = $collectionsStore["MODULES"][moduleId].iframe.match(/^<iframe.*src="(.*)".*>.*<\/iframe>$/);
    		return match;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<BannerIframe> was created without expected prop 'moduleId'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<BannerIframe> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['moduleId', 'claytons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BannerIframe> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(1, moduleId = $$props.moduleId);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		moduleId,
    		claytons,
    		isValidIframe,
    		$collectionsStore,
    		$configStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(1, moduleId = $$props.moduleId);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [claytons, moduleId, $collectionsStore, $configStore, isValidIframe];
    }

    class BannerIframe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { moduleId: 1, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BannerIframe",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<BannerIframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<BannerIframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error("<BannerIframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error("<BannerIframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Representations\GriffithCards\BannerColour.svelte generated by Svelte v3.55.0 */
    const file$g = "src\\components\\Representations\\GriffithCards\\BannerColour.svelte";

    // (17:0) {:else}
    function create_else_block$8(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("");
    			attr_dev(div, "class", "cc-banner-colour svelte-1545ek9");
    			set_style(div, "background-color", /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].bannerColour);
    			add_location(div, file$g, 17, 0, 374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, moduleId*/ 6) {
    				set_style(div, "background-color", /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].bannerColour);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(17:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (9:0) {#if claytons}
    function create_if_block$d(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("");
    			attr_dev(div, "class", "claytons-banner-colour");
    			set_style(div, "width", "100%");
    			set_style(div, "height", "10rem");
    			set_style(div, "background-color", /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].bannerColour);
    			add_location(div, file$g, 9, 0, 188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, moduleId*/ 6) {
    				set_style(div, "background-color", /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].bannerColour);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(9:0) {#if claytons}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*claytons*/ ctx[0]) return create_if_block$d;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BannerColour', slots, []);
    	let { moduleId } = $$props;
    	let { claytons } = $$props;

    	if (!claytons) {
    		claytons = false;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<BannerColour> was created without expected prop 'moduleId'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<BannerColour> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['moduleId', 'claytons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BannerColour> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(1, moduleId = $$props.moduleId);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		moduleId,
    		claytons,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(1, moduleId = $$props.moduleId);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [claytons, moduleId, $collectionsStore];
    }

    class BannerColour extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { moduleId: 1, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BannerColour",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<BannerColour>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<BannerColour>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error("<BannerColour>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error("<BannerColour>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Representations\GriffithCards\BannerImage.svelte generated by Svelte v3.55.0 */
    const file$f = "src\\components\\Representations\\GriffithCards\\BannerImage.svelte";

    // (49:0) {:else}
    function create_else_block$7(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "cc-card-image svelte-nejx1g");
    			if (!src_url_equal(img.src, img_src_value = "https://www.signfix.com.au/wp-content/uploads/2017/09/placeholder-600x400.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "data-moduleid", /*moduleId*/ ctx[1]);
    			attr_dev(img, "alt", img_alt_value = "Image representing '" + /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].name.replace(/(["'])/g, '\\$1') + "'");
    			add_location(img, file$f, 49, 2, 1474);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*moduleId*/ 2) {
    				attr_dev(img, "data-moduleid", /*moduleId*/ ctx[1]);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 6 && img_alt_value !== (img_alt_value = "Image representing '" + /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].name.replace(/(["'])/g, '\\$1') + "'")) {
    				attr_dev(img, "alt", img_alt_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(49:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:68) 
    function create_if_block_1$b(ctx) {
    	let img;
    	let img_class_value;
    	let img_src_value;
    	let img_data_moduleid_value;
    	let img_alt_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", img_class_value = "cc-card-image " + calculateImageSize(/*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].imageSize) + " svelte-nejx1g");
    			set_style(img, "height", "10rem");
    			set_style(img, "width", "100%");
    			if (!src_url_equal(img.src, img_src_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].image)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "data-moduleid", img_data_moduleid_value = "$" + /*moduleId*/ ctx[1]);
    			attr_dev(img, "alt", img_alt_value = "Image representing '" + /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].name.replace(/(["'])/g, '\\$1') + "\r\n\t'");
    			add_location(img, file$f, 36, 2, 1091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, moduleId*/ 6 && img_class_value !== (img_class_value = "cc-card-image " + calculateImageSize(/*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].imageSize) + " svelte-nejx1g")) {
    				attr_dev(img, "class", img_class_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 6 && !src_url_equal(img.src, img_src_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].image)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*moduleId*/ 2 && img_data_moduleid_value !== (img_data_moduleid_value = "$" + /*moduleId*/ ctx[1])) {
    				attr_dev(img, "data-moduleid", img_data_moduleid_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 6 && img_alt_value !== (img_alt_value = "Image representing '" + /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].name.replace(/(["'])/g, '\\$1') + "\r\n\t'")) {
    				attr_dev(img, "alt", img_alt_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(36:68) ",
    		ctx
    	});

    	return block;
    }

    // (24:0) {#if $collectionsStore["MODULES"][moduleId].image && claytons}
    function create_if_block$c(ctx) {
    	let img;
    	let img_class_value;
    	let img_src_value;
    	let img_data_moduleid_value;
    	let img_alt_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", img_class_value = "cc-card-image " + calculateImageSize(/*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].imageSize) + " svelte-nejx1g");
    			if (!src_url_equal(img.src, img_src_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].image)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "data-moduleid", img_data_moduleid_value = "$" + /*moduleId*/ ctx[1]);
    			attr_dev(img, "alt", img_alt_value = "Image representing '" + /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].name.replace(/(["'])/g, '\\$1') + "\r\n\t'");
    			add_location(img, file$f, 24, 2, 684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, moduleId*/ 6 && img_class_value !== (img_class_value = "cc-card-image " + calculateImageSize(/*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].imageSize) + " svelte-nejx1g")) {
    				attr_dev(img, "class", img_class_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 6 && !src_url_equal(img.src, img_src_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].image)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*moduleId*/ 2 && img_data_moduleid_value !== (img_data_moduleid_value = "$" + /*moduleId*/ ctx[1])) {
    				attr_dev(img, "data-moduleid", img_data_moduleid_value);
    			}

    			if (dirty & /*$collectionsStore, moduleId*/ 6 && img_alt_value !== (img_alt_value = "Image representing '" + /*$collectionsStore*/ ctx[2]['MODULES'][/*moduleId*/ ctx[1]].name.replace(/(["'])/g, '\\$1') + "\r\n\t'")) {
    				attr_dev(img, "alt", img_alt_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(24:0) {#if $collectionsStore[\\\"MODULES\\\"][moduleId].image && claytons}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].image && /*claytons*/ ctx[0]) return create_if_block$c;
    		if (/*$collectionsStore*/ ctx[2]["MODULES"][/*moduleId*/ ctx[1]].image && !/*claytons*/ ctx[0]) return create_if_block_1$b;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function calculateImageSize(size) {
    	let imageSize = "";
    	const allowedObjectFit = ["contain", "cover", "scale-down", "fill"];

    	if (size === "bg-contain") {
    		imageSize = "cc-object-fit-old-kludge";
    	} else if (allowedObjectFit.includes(size)) {
    		imageSize = `cc-object-fit-${size}`;
    	}

    	return imageSize;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BannerImage', slots, []);
    	let { moduleId } = $$props;
    	let { claytons } = $$props;

    	if (!claytons) {
    		claytons = false;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (moduleId === undefined && !('moduleId' in $$props || $$self.$$.bound[$$self.$$.props['moduleId']])) {
    			console.warn("<BannerImage> was created without expected prop 'moduleId'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<BannerImage> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['moduleId', 'claytons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BannerImage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('moduleId' in $$props) $$invalidate(1, moduleId = $$props.moduleId);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		moduleId,
    		claytons,
    		calculateImageSize,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('moduleId' in $$props) $$invalidate(1, moduleId = $$props.moduleId);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [claytons, moduleId, $collectionsStore];
    }

    class BannerImage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { moduleId: 1, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BannerImage",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get moduleId() {
    		throw new Error("<BannerImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moduleId(value) {
    		throw new Error("<BannerImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error("<BannerImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error("<BannerImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Representations\GriffithCards\DateWidget.svelte generated by Svelte v3.55.0 */

    const file$e = "src\\components\\Representations\\GriffithCards\\DateWidget.svelte";

    // (79:0) {#if date}
    function create_if_block$b(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*date*/ 1) show_if = null;
    		if (show_if == null) show_if = !!(/*date*/ ctx[0]["to"] && isNotEmptyDate(/*date*/ ctx[0]["to"]));
    		if (show_if) return create_if_block_1$a;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(79:0) {#if date}",
    		ctx
    	});

    	return block;
    }

    // (157:2) {:else}
    function create_else_block_1$3(ctx) {
    	let div;
    	let show_if = isNotEmptyDate(/*date*/ ctx[0]) && /*date*/ ctx[0]["label"];
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block0 = show_if && create_if_block_23(ctx);
    	let if_block1 = !/*dateHide*/ ctx[1]["week"] && /*date*/ ctx[0]["week"] && !/*dateHide*/ ctx[1]["week"] && create_if_block_22(ctx);
    	let if_block2 = !/*dateHide*/ ctx[1]["time"] && /*date*/ ctx[0]["time"] && create_if_block_21(ctx);
    	let if_block3 = !/*dateHide*/ ctx[1]["day"] && /*date*/ ctx[0]["day"] && create_if_block_20(ctx);
    	let if_block4 = !/*dateHide*/ ctx[1]["calendarDate"] && /*date*/ ctx[0]["month"] && create_if_block_19(ctx);
    	let if_block5 = !/*dateHide*/ ctx[1]["calendarDate"] && /*date*/ ctx[0]["date"] && create_if_block_18(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div, "class", "cc-card-date svelte-ymwt67");
    			add_location(div, file$e, 157, 4, 5361);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1) show_if = isNotEmptyDate(/*date*/ ctx[0]) && /*date*/ ctx[0]["label"];

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_23(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["week"] && /*date*/ ctx[0]["week"] && !/*dateHide*/ ctx[1]["week"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_22(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["time"] && /*date*/ ctx[0]["time"]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_21(ctx);
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["day"] && /*date*/ ctx[0]["day"]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_20(ctx);
    					if_block3.c();
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["calendarDate"] && /*date*/ ctx[0]["month"]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_19(ctx);
    					if_block4.c();
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["calendarDate"] && /*date*/ ctx[0]["date"]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_18(ctx);
    					if_block5.c();
    					if_block5.m(div, null);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(157:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:2) {#if date["to"] && isNotEmptyDate(date["to"])}
    function create_if_block_1$a(ctx) {
    	let div;
    	let show_if = isNotEmptyDate(/*date*/ ctx[0]) && /*date*/ ctx[0]["label"];
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block0 = show_if && create_if_block_17(ctx);
    	let if_block1 = (!/*dateHide*/ ctx[1]["week"] && /*date*/ ctx[0]["week"] && /*date*/ ctx[0]["week"] !== "" || /*date*/ ctx[0]["to"]["week"]) && create_if_block_14(ctx);
    	let if_block2 = (!/*dateHide*/ ctx[1]["time"] && /*date*/ ctx[0]["time"] || /*date*/ ctx[0]["to"]["time"]) && create_if_block_11$2(ctx);
    	let if_block3 = (/*date*/ ctx[0]["day"] || /*date*/ ctx[0]["to"]["day"]) && create_if_block_8$2(ctx);
    	let if_block4 = (/*date*/ ctx[0]["month"] || /*date*/ ctx[0]["to"]["month"]) && create_if_block_5$4(ctx);
    	let if_block5 = (/*date*/ ctx[0]["date"] || /*date*/ ctx[0]["to"]["date"]) && create_if_block_2$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div, "class", "cc-card-date svelte-ymwt67");
    			add_location(div, file$e, 80, 4, 2901);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1) show_if = isNotEmptyDate(/*date*/ ctx[0]) && /*date*/ ctx[0]["label"];

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_17(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["week"] && /*date*/ ctx[0]["week"] && /*date*/ ctx[0]["week"] !== "" || /*date*/ ctx[0]["to"]["week"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_14(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!/*dateHide*/ ctx[1]["time"] && /*date*/ ctx[0]["time"] || /*date*/ ctx[0]["to"]["time"]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_11$2(ctx);
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*date*/ ctx[0]["day"] || /*date*/ ctx[0]["to"]["day"]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_8$2(ctx);
    					if_block3.c();
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*date*/ ctx[0]["month"] || /*date*/ ctx[0]["to"]["month"]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_5$4(ctx);
    					if_block4.c();
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*date*/ ctx[0]["date"] || /*date*/ ctx[0]["to"]["date"]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_2$9(ctx);
    					if_block5.c();
    					if_block5.m(div, null);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(80:2) {#if date[\\\"to\\\"] && isNotEmptyDate(date[\\\"to\\\"])}",
    		ctx
    	});

    	return block;
    }

    // (159:6) {#if isNotEmptyDate(date) && date["label"]}
    function create_if_block_23(ctx) {
    	let div;
    	let t_value = /*date*/ ctx[0]["label"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cc-card-date-label svelte-ymwt67");
    			add_location(div, file$e, 159, 8, 5448);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["label"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23.name,
    		type: "if",
    		source: "(159:6) {#if isNotEmptyDate(date) && date[\\\"label\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (164:6) {#if !dateHide["week"] && date["week"] && !dateHide["week"]}
    function create_if_block_22(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*date*/ ctx[0]["week"] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Week ");
    			t1 = text(t1_value);
    			attr_dev(div, "class", "cc-card-date-week svelte-ymwt67");
    			add_location(div, file$e, 164, 8, 5614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t1_value !== (t1_value = /*date*/ ctx[0]["week"] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(164:6) {#if !dateHide[\\\"week\\\"] && date[\\\"week\\\"] && !dateHide[\\\"week\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (169:6) {#if !dateHide["time"] && date["time"]}
    function create_if_block_21(ctx) {
    	let div;
    	let t_value = /*date*/ ctx[0]["time"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cc-card-date-time svelte-ymwt67");
    			add_location(div, file$e, 169, 8, 5762);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["time"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(169:6) {#if !dateHide[\\\"time\\\"] && date[\\\"time\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (174:6) {#if !dateHide["day"] && date["day"]}
    function create_if_block_20(ctx) {
    	let div;
    	let t_value = /*date*/ ctx[0]["day"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cc-card-date-day svelte-ymwt67");
    			add_location(div, file$e, 174, 8, 5903);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["day"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(174:6) {#if !dateHide[\\\"day\\\"] && date[\\\"day\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (179:6) {#if !dateHide["calendarDate"] && date["month"]}
    function create_if_block_19(ctx) {
    	let div;
    	let t_value = /*date*/ ctx[0]["month"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cc-card-date-month svelte-ymwt67");
    			add_location(div, file$e, 179, 8, 6053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["month"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(179:6) {#if !dateHide[\\\"calendarDate\\\"] && date[\\\"month\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (184:6) {#if !dateHide["calendarDate"] && date["date"]}
    function create_if_block_18(ctx) {
    	let div;
    	let t_value = /*date*/ ctx[0]["date"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cc-card-date-date svelte-ymwt67");
    			add_location(div, file$e, 184, 8, 6206);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["date"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(184:6) {#if !dateHide[\\\"calendarDate\\\"] && date[\\\"date\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (82:6) {#if isNotEmptyDate(date) && date["label"]}
    function create_if_block_17(ctx) {
    	let div;
    	let t_value = /*date*/ ctx[0]["label"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cc-card-date-label svelte-ymwt67");
    			add_location(div, file$e, 82, 8, 2989);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["label"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(82:6) {#if isNotEmptyDate(date) && date[\\\"label\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (87:6) {#if !dateHide["week"] && date["week"] && date["week"]!=="" || date["to"]["week"]}
    function create_if_block_14(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*date*/ ctx[0]["week"] + "";
    	let t1;
    	let t2;

    	function select_block_type_1(ctx, dirty) {
    		if (/*date*/ ctx[0]["week"] && /*date*/ ctx[0]["to"]["week"] && /*date*/ ctx[0]["week"] !== /*date*/ ctx[0]["to"]["week"]) return create_if_block_16;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*date*/ ctx[0]["week"] && /*date*/ ctx[0]["to"]["week"] && /*date*/ ctx[0]["week"] !== /*date*/ ctx[0]["to"]["week"] && create_if_block_15(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "cc-card-date-week svelte-ymwt67");
    			add_location(div, file$e, 87, 8, 3177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			}

    			if (dirty & /*date*/ 1 && t1_value !== (t1_value = /*date*/ ctx[0]["week"] + "")) set_data_dev(t1, t1_value);

    			if (/*date*/ ctx[0]["week"] && /*date*/ ctx[0]["to"]["week"] && /*date*/ ctx[0]["week"] !== /*date*/ ctx[0]["to"]["week"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_15(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(87:6) {#if !dateHide[\\\"week\\\"] && date[\\\"week\\\"] && date[\\\"week\\\"]!==\\\"\\\" || date[\\\"to\\\"][\\\"week\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (91:10) {:else}
    function create_else_block$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Week");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(91:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (89:10) {#if date["week"] && date["to"]["week"] && date["week"] !== date["to"]["week"]}
    function create_if_block_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Weeks");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(89:10) {#if date[\\\"week\\\"] && date[\\\"to\\\"][\\\"week\\\"] && date[\\\"week\\\"] !== date[\\\"to\\\"][\\\"week\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (95:10) {#if date["week"] && date["to"]["week"] && date["week"] !== date["to"]["week"]}
    function create_if_block_15(ctx) {
    	let t0;
    	let t1_value = /*date*/ ctx[0]["to"]["week"] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("- ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t1_value !== (t1_value = /*date*/ ctx[0]["to"]["week"] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(95:10) {#if date[\\\"week\\\"] && date[\\\"to\\\"][\\\"week\\\"] && date[\\\"week\\\"] !== date[\\\"to\\\"][\\\"week\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (100:6) {#if !dateHide["time"] && date["time"] || date["to"]["time"]}
    function create_if_block_11$2(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let if_block0 = /*date*/ ctx[0]["time"] && create_if_block_13$1(ctx);
    	let if_block1 = /*date*/ ctx[0]["to"]["time"] && create_if_block_12$2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "cc-card-date-time-from svelte-ymwt67");
    			add_location(div0, file$e, 101, 10, 3698);
    			attr_dev(div1, "class", "cc-card-date-time-to svelte-ymwt67");
    			add_location(div1, file$e, 106, 10, 3845);
    			attr_dev(div2, "class", "cc-card-date-dual-time svelte-ymwt67");
    			add_location(div2, file$e, 100, 8, 3650);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*date*/ ctx[0]["time"]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_13$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*date*/ ctx[0]["to"]["time"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_12$2(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$2.name,
    		type: "if",
    		source: "(100:6) {#if !dateHide[\\\"time\\\"] && date[\\\"time\\\"] || date[\\\"to\\\"][\\\"time\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (103:12) {#if date["time"]}
    function create_if_block_13$1(ctx) {
    	let t_value = /*date*/ ctx[0]["time"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["time"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(103:12) {#if date[\\\"time\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (108:12) {#if date["to"]["time"]}
    function create_if_block_12$2(ctx) {
    	let t_value = /*date*/ ctx[0]["to"]["time"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["to"]["time"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$2.name,
    		type: "if",
    		source: "(108:12) {#if date[\\\"to\\\"][\\\"time\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (114:6) {#if date["day"] || date["to"]["day"]}
    function create_if_block_8$2(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let if_block0 = /*date*/ ctx[0]["day"] && create_if_block_10$2(ctx);
    	let if_block1 = /*date*/ ctx[0]["to"]["day"] && create_if_block_9$2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "cc-card-date-day-from svelte-ymwt67");
    			add_location(div0, file$e, 115, 10, 4122);
    			attr_dev(div1, "class", "cc-card-date-day-to svelte-ymwt67");
    			add_location(div1, file$e, 120, 10, 4282);
    			attr_dev(div2, "class", "cc-card-date-dual-day svelte-ymwt67");
    			add_location(div2, file$e, 114, 8, 4075);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*date*/ ctx[0]["day"]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_10$2(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*date*/ ctx[0]["to"]["day"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$2(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(114:6) {#if date[\\\"day\\\"] || date[\\\"to\\\"][\\\"day\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (117:12) {#if date["day"]}
    function create_if_block_10$2(ctx) {
    	let t_value = /*date*/ ctx[0]["day"].substring(0, 3) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["day"].substring(0, 3) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(117:12) {#if date[\\\"day\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (122:12) {#if date["to"]["day"]}
    function create_if_block_9$2(ctx) {
    	let t_value = /*date*/ ctx[0]["to"]["day"].substring(0, 3) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["to"]["day"].substring(0, 3) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(122:12) {#if date[\\\"to\\\"][\\\"day\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (128:6) {#if date["month"] || date["to"]["month"]}
    function create_if_block_5$4(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let if_block0 = /*date*/ ctx[0]["month"] && create_if_block_7$3(ctx);
    	let if_block1 = /*date*/ ctx[0]["to"]["month"] && create_if_block_6$4(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "cc-card-date-month-from svelte-ymwt67");
    			add_location(div0, file$e, 129, 10, 4578);
    			attr_dev(div1, "class", "cc-card-date-month-to svelte-ymwt67");
    			add_location(div1, file$e, 134, 10, 4728);
    			attr_dev(div2, "class", "cc-card-date-dual-month svelte-ymwt67");
    			add_location(div2, file$e, 128, 8, 4529);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*date*/ ctx[0]["month"]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7$3(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*date*/ ctx[0]["to"]["month"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6$4(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(128:6) {#if date[\\\"month\\\"] || date[\\\"to\\\"][\\\"month\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (131:12) {#if date["month"]}
    function create_if_block_7$3(ctx) {
    	let t_value = /*date*/ ctx[0]["month"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["month"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(131:12) {#if date[\\\"month\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (136:12) {#if date["to"]["month"]}
    function create_if_block_6$4(ctx) {
    	let t_value = /*date*/ ctx[0]["to"]["month"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["to"]["month"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(136:12) {#if date[\\\"to\\\"][\\\"month\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (142:6) {#if date["date"] || date["to"]["date"]}
    function create_if_block_2$9(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let if_block0 = /*date*/ ctx[0]["date"] && create_if_block_4$5(ctx);
    	let if_block1 = /*date*/ ctx[0]["to"]["date"] && create_if_block_3$6(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "cc-card-date-date-from svelte-ymwt67");
    			add_location(div0, file$e, 143, 10, 5011);
    			attr_dev(div1, "class", "cc-card-date-date-to svelte-ymwt67");
    			add_location(div1, file$e, 148, 10, 5158);
    			attr_dev(div2, "class", "cc-card-date-dual-date svelte-ymwt67");
    			add_location(div2, file$e, 142, 8, 4963);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*date*/ ctx[0]["date"]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*date*/ ctx[0]["to"]["date"]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$6(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(142:6) {#if date[\\\"date\\\"] || date[\\\"to\\\"][\\\"date\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (145:12) {#if date["date"]}
    function create_if_block_4$5(ctx) {
    	let t_value = /*date*/ ctx[0]["date"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["date"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(145:12) {#if date[\\\"date\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (150:12) {#if date["to"]["date"]}
    function create_if_block_3$6(ctx) {
    	let t_value = /*date*/ ctx[0]["to"]["date"] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 1 && t_value !== (t_value = /*date*/ ctx[0]["to"]["date"] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(150:12) {#if date[\\\"to\\\"][\\\"date\\\"]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let if_block_anchor;
    	let if_block = /*date*/ ctx[0] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*date*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isNotEmptyDate(date) {
    	return date.hasOwnProperty("week") && date["week"] !== "" || date.hasOwnProperty("month") && date["month"] !== "" || date.hasOwnProperty("date") && date["date"] !== "" || date.hasOwnProperty("day") && date["day"] !== "" || date.hasOwnProperty("time") && date["time"] !== "";
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DateWidget', slots, []);
    	let { date } = $$props;
    	let { dateHide } = $$props;
    	let { calendar } = $$props;

    	if (date) {
    		if (date["week"] || date["month"] && date["date"]) {
    			date = addCalendarDate(date);
    		}
    	}

    	/**
     * @function addCalendarDate
     * @param {Object} date - JSON date rep from collections
     * @returns {Object} date - date + Calendar matching course site
     * @description Original date from collections can include use of
     * University generic dates (e.g. Monday, Week 5). Translate those
     * generic dates into a specific date based on semester/period appropriate
     * for the current course site and the university calendar
     */
    	function addCalendarDate(date) {
    		date = modifyDate(date);

    		if (date.hasOwnProperty("to") && isNotEmptyDate(date["to"])) {
    			date["to"] = modifyDate(date["to"]);
    		}

    		return date;
    	}

    	/**
     * @function modifyDate
     * @param date
     * @returns {Object} date - date + Calendar matching course site
     * @description Do the actual work for addCalendarDate
     */
    	function modifyDate(date) {
    		// can only add calendar date if a university week is specified
    		if (date.hasOwnProperty("week") && date["week"] !== "") {
    			// if no day, add the first day of the wek
    			if (!date.hasOwnProperty("day") || date["day"] === "") {
    				date["day"] = calendar.getFirstDayOfWeek();
    			}

    			// we've got a week, so we can add the calendar date
    			const actualDate = calendar.getDate(date["week"], false, date["day"]);

    			const fields = ["date", "month", "year"];

    			for (let i = 0; i < fields.length; i++) {
    				if (actualDate.hasOwnProperty(fields[i])) {
    					date[fields[i]] = actualDate[fields[i]];
    				}
    			}
    		}

    		return date;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
    			console.warn("<DateWidget> was created without expected prop 'date'");
    		}

    		if (dateHide === undefined && !('dateHide' in $$props || $$self.$$.bound[$$self.$$.props['dateHide']])) {
    			console.warn("<DateWidget> was created without expected prop 'dateHide'");
    		}

    		if (calendar === undefined && !('calendar' in $$props || $$self.$$.bound[$$self.$$.props['calendar']])) {
    			console.warn("<DateWidget> was created without expected prop 'calendar'");
    		}
    	});

    	const writable_props = ['date', 'dateHide', 'calendar'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DateWidget> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('date' in $$props) $$invalidate(0, date = $$props.date);
    		if ('dateHide' in $$props) $$invalidate(1, dateHide = $$props.dateHide);
    		if ('calendar' in $$props) $$invalidate(2, calendar = $$props.calendar);
    	};

    	$$self.$capture_state = () => ({
    		date,
    		dateHide,
    		calendar,
    		addCalendarDate,
    		isNotEmptyDate,
    		modifyDate
    	});

    	$$self.$inject_state = $$props => {
    		if ('date' in $$props) $$invalidate(0, date = $$props.date);
    		if ('dateHide' in $$props) $$invalidate(1, dateHide = $$props.dateHide);
    		if ('calendar' in $$props) $$invalidate(2, calendar = $$props.calendar);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [date, dateHide, calendar];
    }

    class DateWidget extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { date: 0, dateHide: 1, calendar: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DateWidget",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get date() {
    		throw new Error("<DateWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set date(value) {
    		throw new Error("<DateWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dateHide() {
    		throw new Error("<DateWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dateHide(value) {
    		throw new Error("<DateWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get calendar() {
    		throw new Error("<DateWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set calendar(value) {
    		throw new Error("<DateWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Representations\GriffithCards.svelte generated by Svelte v3.55.0 */
    const file$d = "src\\components\\Representations\\GriffithCards.svelte";

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (217:0) {:else}
    function create_else_block_2$1(ctx) {
    	let div;
    	let current;
    	let each_value_1 = /*modules*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "cc-card-interface cc-representation svelte-3dolfn");
    			add_location(div, file$d, 217, 2, 9038);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*modules, $collectionsStore, cardClick, getModuleUrl, deLabelModuleName, $configStore, collection, isUnPublishedUnallocated, calendar, BANNER_TRANSLATION*/ 254) {
    				each_value_1 = /*modules*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(217:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (74:0) {#if claytons}
    function create_if_block$a(ctx) {
    	let div;
    	let current;
    	let each_value = /*modules*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(div, "flex-wrap", "wrap");
    			set_style(div, "display", "flex");
    			set_style(div, "margin-top", "0.5em");
    			add_location(div, file$d, 75, 2, 2644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*modules, getModuleUrl, $collectionsStore, deLabelModuleName, calendar, BANNER_TRANSLATION, claytons*/ 109) {
    				each_value = /*modules*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(74:0) {#if claytons}",
    		ctx
    	});

    	return block;
    }

    // (231:14) {#if !$collectionsStore["MODULES"][theModule.id].fyi}
    function create_if_block_13(ctx) {
    	let a;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("");
    			attr_dev(a, "class", "cc-card-link svelte-3dolfn");
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*theModule*/ ctx[8].id));
    			attr_dev(a, "style", "");
    			add_location(a, file$d, 231, 16, 9652);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*modules*/ 8 && a_href_value !== (a_href_value = getModuleUrl(/*theModule*/ ctx[8].id))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(231:14) {#if !$collectionsStore[\\\"MODULES\\\"][theModule.id].fyi}",
    		ctx
    	});

    	return block;
    }

    // (249:14) {#if $collectionsStore["MODULES"][theModule.id].fyi && $collectionsStore["MODULES"][theModule.id].fyiText !== ""}
    function create_if_block_11$1(ctx) {
    	let div;
    	let span;

    	function select_block_type_3(ctx, dirty) {
    		if (/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText) return create_if_block_12$1;
    		return create_else_block_3;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "cc-fyi-text");
    			add_location(span, file$d, 250, 18, 10466);
    			attr_dev(div, "class", "cc-card-fyi svelte-3dolfn");
    			add_location(div, file$d, 249, 16, 10421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(249:14) {#if $collectionsStore[\\\"MODULES\\\"][theModule.id].fyi && $collectionsStore[\\\"MODULES\\\"][theModule.id].fyiText !== \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    // (254:20) {:else}
    function create_else_block_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(254:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (252:20) {#if $collectionsStore["MODULES"][theModule.id].fyiText}
    function create_if_block_12$1(ctx) {
    	let html_tag;
    	let raw_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 12 && raw_value !== (raw_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(252:20) {#if $collectionsStore[\\\"MODULES\\\"][theModule.id].fyiText}",
    		ctx
    	});

    	return block;
    }

    // (260:14) {#if isUnPublishedUnallocated(theModule.id)}
    function create_if_block_8$1(ctx) {
    	let div;
    	let t;
    	let if_block0 = !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].published && create_if_block_10$1(ctx);
    	let if_block1 = /*$configStore*/ ctx[4]["editMode"] && /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].collection !== /*collection*/ ctx[1] && create_if_block_9$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "cc-card-published svelte-3dolfn");
    			add_location(div, file$d, 260, 16, 10888);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].published) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_10$1(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$configStore*/ ctx[4]["editMode"] && /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].collection !== /*collection*/ ctx[1]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_9$1(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(260:14) {#if isUnPublishedUnallocated(theModule.id)}",
    		ctx
    	});

    	return block;
    }

    // (262:18) {#if !$collectionsStore["MODULES"][theModule.id].published}
    function create_if_block_10$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Unpublished.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(262:18) {#if !$collectionsStore[\\\"MODULES\\\"][theModule.id].published}",
    		ctx
    	});

    	return block;
    }

    // (265:18) {#if $configStore["editMode"] && $collectionsStore["MODULES"][theModule.id].collection !== collection}
    function create_if_block_9$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No collection allocated.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(265:18) {#if $configStore[\\\"editMode\\\"] && $collectionsStore[\\\"MODULES\\\"][theModule.id].collection !== collection}",
    		ctx
    	});

    	return block;
    }

    // (295:14) {#if $collectionsStore["MODULES"][theModule.id].engage && !$collectionsStore["MODULES"][theModule.id].fyi}
    function create_if_block_7$2(ctx) {
    	let div1;
    	let div0;
    	let a;
    	let t0;
    	let a_href_value;
    	let t1;
    	let t2_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engageText + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			a = element("a");
    			t0 = text("");
    			t1 = space();
    			t2 = text(t2_value);
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*theModule*/ ctx[8].id));
    			attr_dev(a, "class", "gu-engage svelte-3dolfn");
    			add_location(a, file$d, 297, 20, 12644);
    			attr_dev(div0, "class", "cc-card-engage-button svelte-3dolfn");
    			add_location(div0, file$d, 296, 18, 12587);
    			attr_dev(div1, "class", "cc-card-engage svelte-3dolfn");
    			add_location(div1, file$d, 295, 16, 12539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			append_dev(a, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*modules*/ 8 && a_href_value !== (a_href_value = getModuleUrl(/*theModule*/ ctx[8].id))) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*$collectionsStore, modules*/ 12 && t2_value !== (t2_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engageText + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(295:14) {#if $collectionsStore[\\\"MODULES\\\"][theModule.id].engage && !$collectionsStore[\\\"MODULES\\\"][theModule.id].fyi}",
    		ctx
    	});

    	return block;
    }

    // (219:4) {#each modules as theModule}
    function create_each_block_1$3(ctx) {
    	let div9;
    	let div8;
    	let div7;
    	let div0;
    	let t0;
    	let switch_instance;
    	let t1;
    	let datewidget;
    	let t2;
    	let t3;
    	let show_if = /*isUnPublishedUnallocated*/ ctx[7](/*theModule*/ ctx[8].id);
    	let div0_data_moduleid_value;
    	let t4;
    	let div4;
    	let div3;
    	let div1;
    	let span;
    	let html_tag;
    	let raw0_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].label + "";
    	let t5;
    	let t6_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].actualNum + "";
    	let t6;
    	let t7;
    	let h3;
    	let raw1_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id]) + "";
    	let h3_data_moduleid_value;
    	let t8;
    	let div2;
    	let raw2_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].description + "";
    	let div3_class_value;
    	let t9;
    	let div6;
    	let t10;
    	let div5;
    	let div8_id_value;
    	let t11;
    	let div9_id_value;
    	let div9_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && create_if_block_13(ctx);
    	var switch_value = /*BANNER_TRANSLATION*/ ctx[6][/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].banner];

    	function switch_props(ctx) {
    		return {
    			props: { moduleId: /*theModule*/ ctx[8].id },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	datewidget = new DateWidget({
    			props: {
    				date: /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].date,
    				dateHide: /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].dateHide,
    				calendar: /*calendar*/ ctx[5]
    			},
    			$$inline: true
    		});

    	let if_block1 = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText !== "" && create_if_block_11$1(ctx);
    	let if_block2 = show_if && create_if_block_8$1(ctx);
    	let if_block3 = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engage && !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && create_if_block_7$2(ctx);

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t1 = space();
    			create_component(datewidget.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			span = element("span");
    			html_tag = new HtmlTag(false);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			h3 = element("h3");
    			t8 = space();
    			div2 = element("div");
    			t9 = space();
    			div6 = element("div");
    			if (if_block3) if_block3.c();
    			t10 = space();
    			div5 = element("div");
    			t11 = space();
    			attr_dev(div0, "class", "cc-card-banner-container svelte-3dolfn");
    			attr_dev(div0, "data-moduleid", div0_data_moduleid_value = /*theModule*/ ctx[8].id);
    			add_location(div0, file$d, 229, 12, 9498);
    			html_tag.a = t5;
    			attr_dev(span, "class", "cc-card-label svelte-3dolfn");
    			add_location(span, file$d, 278, 18, 11688);
    			attr_dev(h3, "class", "cc-card-title svelte-3dolfn");
    			attr_dev(h3, "data-moduleid", h3_data_moduleid_value = /*theModule*/ ctx[8].id);
    			add_location(h3, file$d, 282, 18, 11917);
    			attr_dev(div1, "class", "cc-card-label svelte-3dolfn");
    			add_location(div1, file$d, 277, 16, 11641);
    			attr_dev(div2, "class", "cc-card-description svelte-3dolfn");
    			add_location(div2, file$d, 288, 16, 12176);

    			attr_dev(div3, "class", div3_class_value = "" + (null_to_empty(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi
    			? "cc-card-content"
    			: "cc-unclickable-card-content") + " svelte-3dolfn"));

    			add_location(div3, file$d, 272, 14, 11440);
    			attr_dev(div4, "class", "cc-card-content-height svelte-3dolfn");
    			add_location(div4, file$d, 270, 12, 11329);
    			attr_dev(div5, "class", "cc-progress svelte-3dolfn");
    			add_location(div5, file$d, 304, 14, 12919);
    			attr_dev(div6, "class", "cc-card-footer svelte-3dolfn");
    			add_location(div6, file$d, 293, 12, 12371);
    			attr_dev(div7, "class", "cc-card-flex svelte-3dolfn");
    			add_location(div7, file$d, 228, 10, 9458);
    			attr_dev(div8, "id", div8_id_value = "cc_module_" + /*theModule*/ ctx[8].id);
    			attr_dev(div8, "class", "cc-card svelte-3dolfn");
    			add_location(div8, file$d, 227, 8, 9395);
    			attr_dev(div9, "id", div9_id_value = "cc_module_" + /*theModule*/ ctx[8].id);

    			attr_dev(div9, "class", div9_class_value = "" + (null_to_empty(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi
    			? "cc-unclickable-card"
    			: "cc-clickable-card") + " svelte-3dolfn"));

    			add_location(div9, file$d, 219, 6, 9129);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (switch_instance) mount_component(switch_instance, div0, null);
    			append_dev(div0, t1);
    			mount_component(datewidget, div0, null);
    			append_dev(div0, t2);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div7, t4);
    			append_dev(div7, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, span);
    			html_tag.m(raw0_value, span);
    			append_dev(span, t5);
    			append_dev(span, t6);
    			append_dev(div1, t7);
    			append_dev(div1, h3);
    			h3.innerHTML = raw1_value;
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			div2.innerHTML = raw2_value;
    			append_dev(div7, t9);
    			append_dev(div7, div6);
    			if (if_block3) if_block3.m(div6, null);
    			append_dev(div6, t10);
    			append_dev(div6, div5);
    			append_dev(div9, t11);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div9, "click", cardClick, { once: true }, false, false),
    					listen_dev(div9, "keydown", cardClick, { once: true }, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_13(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*modules*/ 8) switch_instance_changes.moduleId = /*theModule*/ ctx[8].id;

    			if (switch_value !== (switch_value = /*BANNER_TRANSLATION*/ ctx[6][/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].banner])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, t1);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			const datewidget_changes = {};
    			if (dirty & /*$collectionsStore, modules*/ 12) datewidget_changes.date = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].date;
    			if (dirty & /*$collectionsStore, modules*/ 12) datewidget_changes.dateHide = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].dateHide;
    			datewidget.$set(datewidget_changes);

    			if (/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText !== "") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_11$1(ctx);
    					if_block1.c();
    					if_block1.m(div0, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*modules*/ 8) show_if = /*isUnPublishedUnallocated*/ ctx[7](/*theModule*/ ctx[8].id);

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_8$1(ctx);
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!current || dirty & /*modules*/ 8 && div0_data_moduleid_value !== (div0_data_moduleid_value = /*theModule*/ ctx[8].id)) {
    				attr_dev(div0, "data-moduleid", div0_data_moduleid_value);
    			}

    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && raw0_value !== (raw0_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].label + "")) html_tag.p(raw0_value);
    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && t6_value !== (t6_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].actualNum + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && raw1_value !== (raw1_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id]) + "")) h3.innerHTML = raw1_value;
    			if (!current || dirty & /*modules*/ 8 && h3_data_moduleid_value !== (h3_data_moduleid_value = /*theModule*/ ctx[8].id)) {
    				attr_dev(h3, "data-moduleid", h3_data_moduleid_value);
    			}

    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && raw2_value !== (raw2_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].description + "")) div2.innerHTML = raw2_value;
    			if (!current || dirty & /*$collectionsStore, modules*/ 12 && div3_class_value !== (div3_class_value = "" + (null_to_empty(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi
    			? "cc-card-content"
    			: "cc-unclickable-card-content") + " svelte-3dolfn"))) {
    				attr_dev(div3, "class", div3_class_value);
    			}

    			if (/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engage && !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_7$2(ctx);
    					if_block3.c();
    					if_block3.m(div6, t10);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!current || dirty & /*modules*/ 8 && div8_id_value !== (div8_id_value = "cc_module_" + /*theModule*/ ctx[8].id)) {
    				attr_dev(div8, "id", div8_id_value);
    			}

    			if (!current || dirty & /*modules*/ 8 && div9_id_value !== (div9_id_value = "cc_module_" + /*theModule*/ ctx[8].id)) {
    				attr_dev(div9, "id", div9_id_value);
    			}

    			if (!current || dirty & /*$collectionsStore, modules*/ 12 && div9_class_value !== (div9_class_value = "" + (null_to_empty(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi
    			? "cc-unclickable-card"
    			: "cc-clickable-card") + " svelte-3dolfn"))) {
    				attr_dev(div9, "class", div9_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(datewidget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(datewidget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			if (if_block0) if_block0.d();
    			if (switch_instance) destroy_component(switch_instance);
    			destroy_component(datewidget);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(219:4) {#each modules as theModule}",
    		ctx
    	});

    	return block;
    }

    // (97:14) {#if !$collectionsStore["MODULES"][theModule.id].fyi}
    function create_if_block_6$3(ctx) {
    	let a;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("");
    			attr_dev(a, "class", "claytons-card-link");
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*theModule*/ ctx[8].id));
    			attr_dev(a, "style", "position:absolute;:width:100%;height:100%;top:0;left:0;z-index:1;text-decoration:none;");
    			add_location(a, file$d, 97, 16, 3590);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*modules*/ 8 && a_href_value !== (a_href_value = getModuleUrl(/*theModule*/ ctx[8].id))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(97:14) {#if !$collectionsStore[\\\"MODULES\\\"][theModule.id].fyi}",
    		ctx
    	});

    	return block;
    }

    // (119:14) {#if $collectionsStore["MODULES"][theModule.id].fyi && $collectionsStore["MODULES"][theModule.id].fyiText !== ""}
    function create_if_block_4$4(ctx) {
    	let div;
    	let span;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText) return create_if_block_5$3;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "claytons-fyi-text");
    			add_location(span, file$d, 123, 18, 4836);
    			attr_dev(div, "class", "claytons-card-fyi");
    			set_style(div, "position", "absolute");
    			set_style(div, "background", "rgba(0,0,0,0.75)");
    			set_style(div, "color", "white");
    			set_style(div, "width", "100%");
    			set_style(div, "padding", "0.25rem");
    			set_style(div, "font-size", "x-small");
    			set_style(div, "text-align", "center");
    			add_location(div, file$d, 119, 16, 4598);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(119:14) {#if $collectionsStore[\\\"MODULES\\\"][theModule.id].fyi && $collectionsStore[\\\"MODULES\\\"][theModule.id].fyiText !== \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    // (127:20) {:else}
    function create_else_block_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(127:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (125:20) {#if $collectionsStore["MODULES"][theModule.id].fyiText}
    function create_if_block_5$3(ctx) {
    	let html_tag;
    	let raw_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 12 && raw_value !== (raw_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(125:20) {#if $collectionsStore[\\\"MODULES\\\"][theModule.id].fyiText}",
    		ctx
    	});

    	return block;
    }

    // (138:14) {#if !$collectionsStore["MODULES"][theModule.id].fyi}
    function create_if_block_3$5(ctx) {
    	let a;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("");
    			attr_dev(a, "class", "claytons-card-link");
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*theModule*/ ctx[8].id));
    			attr_dev(a, "style", "position:absolute;:width:100%;height:100%;top:0;left:0;z-index:1;text-decoration:none;");
    			add_location(a, file$d, 138, 16, 5447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*modules*/ 8 && a_href_value !== (a_href_value = getModuleUrl(/*theModule*/ ctx[8].id))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(138:14) {#if !$collectionsStore[\\\"MODULES\\\"][theModule.id].fyi}",
    		ctx
    	});

    	return block;
    }

    // (174:20) {:else}
    function create_else_block$5(ctx) {
    	let html_tag;
    	let raw_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 12 && raw_value !== (raw_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(174:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (164:20) {#if !$collectionsStore["MODULES"][theModule.id].fyi}
    function create_if_block_2$8(ctx) {
    	let a;
    	let raw_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id]) + "";
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "class", "claytons-card-link");
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*theModule*/ ctx[8].id));
    			set_style(a, "text-decoration", "none");
    			add_location(a, file$d, 164, 22, 6831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			a.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 12 && raw_value !== (raw_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id]) + "")) a.innerHTML = raw_value;
    			if (dirty & /*modules*/ 8 && a_href_value !== (a_href_value = getModuleUrl(/*theModule*/ ctx[8].id))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(164:20) {#if !$collectionsStore[\\\"MODULES\\\"][theModule.id].fyi}",
    		ctx
    	});

    	return block;
    }

    // (193:14) {#if $collectionsStore["MODULES"][theModule.id].engage && !$collectionsStore["MODULES"][theModule.id].fyi}
    function create_if_block_1$9(ctx) {
    	let div1;
    	let div0;
    	let a;
    	let t_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engageText + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*theModule*/ ctx[8].id));
    			attr_dev(a, "class", "claytons-gu-engage");
    			set_style(a, "text-decoration", "none");
    			add_location(a, file$d, 200, 20, 8573);
    			attr_dev(div0, "class", "claytons-card-engage-button");
    			attr_dev(div0, "style", "float:right; position:relative; color:rgba(30,58,138,1); border-radius:0.25rem; padding 0.5rem 1rem 0.5rem 1rem; border:1px solid rgba(30,58,138,1);");
    			add_location(div0, file$d, 194, 18, 8091);
    			attr_dev(div1, "class", "claytons-card-engage");
    			set_style(div1, "padding-right", "1rem");
    			add_location(div1, file$d, 193, 16, 8008);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 12 && t_value !== (t_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engageText + "")) set_data_dev(t, t_value);

    			if (dirty & /*modules*/ 8 && a_href_value !== (a_href_value = getModuleUrl(/*theModule*/ ctx[8].id))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(193:14) {#if $collectionsStore[\\\"MODULES\\\"][theModule.id].engage && !$collectionsStore[\\\"MODULES\\\"][theModule.id].fyi}",
    		ctx
    	});

    	return block;
    }

    // (77:4) {#each modules as theModule}
    function create_each_block$9(ctx) {
    	let div8;
    	let div7;
    	let div6;
    	let div0;
    	let t0;
    	let switch_instance;
    	let t1;
    	let datewidget;
    	let t2;
    	let div0_data_moduleid_value;
    	let t3;
    	let div4;
    	let t4;
    	let div3;
    	let div1;
    	let span;
    	let html_tag;
    	let raw0_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].label + "";
    	let t5;
    	let t6_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].actualNum + "";
    	let t6;
    	let t7;
    	let h3;
    	let h3_data_moduleid_value;
    	let t8;
    	let div2;
    	let raw1_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].description + "";
    	let div3_class_value;
    	let t9;
    	let div5;
    	let div7_id_value;
    	let t10;
    	let div8_id_value;
    	let current;
    	let if_block0 = !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && create_if_block_6$3(ctx);
    	var switch_value = /*BANNER_TRANSLATION*/ ctx[6][/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].banner];

    	function switch_props(ctx) {
    		return {
    			props: {
    				moduleId: /*theModule*/ ctx[8].id,
    				claytons: /*claytons*/ ctx[0]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	datewidget = new DateWidget({
    			props: {
    				date: /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].date,
    				dateHide: /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].dateHide,
    				calendar: /*calendar*/ ctx[5]
    			},
    			$$inline: true
    		});

    	let if_block1 = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText !== "" && create_if_block_4$4(ctx);
    	let if_block2 = !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && create_if_block_3$5(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (!/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi) return create_if_block_2$8;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block3 = current_block_type(ctx);
    	let if_block4 = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engage && !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t1 = space();
    			create_component(datewidget.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div4 = element("div");
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div3 = element("div");
    			div1 = element("div");
    			span = element("span");
    			html_tag = new HtmlTag(false);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			h3 = element("h3");
    			if_block3.c();
    			t8 = space();
    			div2 = element("div");
    			t9 = space();
    			div5 = element("div");
    			if (if_block4) if_block4.c();
    			t10 = space();
    			attr_dev(div0, "class", "claytons-card-banner-container");
    			attr_dev(div0, "data-moduleid", div0_data_moduleid_value = /*theModule*/ ctx[8].id);
    			set_style(div0, "position", "relative");
    			add_location(div0, file$d, 91, 12, 3344);
    			html_tag.a = t5;
    			attr_dev(span, "class", "claytons-card-label");
    			set_style(span, "font-size", "0.9rem");
    			add_location(span, file$d, 154, 18, 6282);
    			attr_dev(h3, "class", "claytons-card-title");
    			attr_dev(h3, "data-moduleid", h3_data_moduleid_value = /*theModule*/ ctx[8].id);
    			set_style(h3, "font-size", "1rem");
    			set_style(h3, "font-weight", "strong");
    			add_location(h3, file$d, 158, 18, 6543);
    			attr_dev(div1, "class", "claytons-card-label");
    			set_style(div1, "font-size", "0.9rem");
    			add_location(div1, file$d, 153, 16, 6203);
    			attr_dev(div2, "class", "claytons-card-description");
    			set_style(div2, "font-size", "0.75rem");
    			add_location(div2, file$d, 180, 16, 7467);

    			attr_dev(div3, "class", div3_class_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi
    			? "claytons-card-content"
    			: "claytons-unclickable-card-content");

    			set_style(div3, "padding", "0.5rem");
    			set_style(div3, "flex", "1 1 0%");
    			set_style(div3, "display", "flex");
    			set_style(div3, "flex-direction", "column");
    			add_location(div3, file$d, 147, 14, 5901);
    			attr_dev(div4, "class", "claytons-card-content-height");
    			set_style(div4, "height", "12rem");
    			set_style(div4, "overflow", "auto");
    			set_style(div4, "position", "relative");
    			add_location(div4, file$d, 133, 12, 5220);
    			attr_dev(div5, "class", "claytons-card-footer");
    			set_style(div5, "height", "4rem");
    			set_style(div5, "position", "relative");
    			add_location(div5, file$d, 188, 12, 7751);
    			attr_dev(div6, "class", "claytons-card-flex");
    			set_style(div6, "overflow", "hidden");
    			set_style(div6, "flex-direction", "column");
    			set_style(div6, "flex", "1 1 0%");
    			set_style(div6, "display", "flex");
    			set_style(div6, "position", "relative");
    			set_style(div6, "border-style", "outset");
    			set_style(div6, "border-radius", "1em");
    			add_location(div6, file$d, 87, 10, 3129);
    			attr_dev(div7, "id", div7_id_value = "cc_module_" + /*theModule*/ ctx[8].id);
    			attr_dev(div7, "class", "claytons-card svelte-3dolfn");
    			set_style(div7, "background-color", "#fff");
    			set_style(div7, "border-radius", "1em");
    			add_location(div7, file$d, 82, 8, 2965);
    			attr_dev(div8, "id", div8_id_value = "cc_module_" + /*theModule*/ ctx[8].id);
    			set_style(div8, "padding", "0.75rem");
    			set_style(div8, "flex-direction", "column");
    			set_style(div8, "display", "flex");
    			set_style(div8, "width", "30%");
    			attr_dev(div8, "class", "svelte-3dolfn");
    			add_location(div8, file$d, 78, 6, 2821);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (switch_instance) mount_component(switch_instance, div0, null);
    			append_dev(div0, t1);
    			mount_component(datewidget, div0, null);
    			append_dev(div0, t2);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div6, t3);
    			append_dev(div6, div4);
    			if (if_block2) if_block2.m(div4, null);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, span);
    			html_tag.m(raw0_value, span);
    			append_dev(span, t5);
    			append_dev(span, t6);
    			append_dev(div1, t7);
    			append_dev(div1, h3);
    			if_block3.m(h3, null);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(div6, t9);
    			append_dev(div6, div5);
    			if (if_block4) if_block4.m(div5, null);
    			append_dev(div8, t10);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$3(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*modules*/ 8) switch_instance_changes.moduleId = /*theModule*/ ctx[8].id;
    			if (dirty & /*claytons*/ 1) switch_instance_changes.claytons = /*claytons*/ ctx[0];

    			if (switch_value !== (switch_value = /*BANNER_TRANSLATION*/ ctx[6][/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].banner])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, t1);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			const datewidget_changes = {};
    			if (dirty & /*$collectionsStore, modules*/ 12) datewidget_changes.date = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].date;
    			if (dirty & /*$collectionsStore, modules*/ 12) datewidget_changes.dateHide = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].dateHide;
    			datewidget.$set(datewidget_changes);

    			if (/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi && /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyiText !== "") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$4(ctx);
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*modules*/ 8 && div0_data_moduleid_value !== (div0_data_moduleid_value = /*theModule*/ ctx[8].id)) {
    				attr_dev(div0, "data-moduleid", div0_data_moduleid_value);
    			}

    			if (!/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3$5(ctx);
    					if_block2.c();
    					if_block2.m(div4, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && raw0_value !== (raw0_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].label + "")) html_tag.p(raw0_value);
    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && t6_value !== (t6_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].actualNum + "")) set_data_dev(t6, t6_value);

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block3) {
    				if_block3.p(ctx, dirty);
    			} else {
    				if_block3.d(1);
    				if_block3 = current_block_type(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(h3, null);
    				}
    			}

    			if (!current || dirty & /*modules*/ 8 && h3_data_moduleid_value !== (h3_data_moduleid_value = /*theModule*/ ctx[8].id)) {
    				attr_dev(h3, "data-moduleid", h3_data_moduleid_value);
    			}

    			if ((!current || dirty & /*$collectionsStore, modules*/ 12) && raw1_value !== (raw1_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].description + "")) div2.innerHTML = raw1_value;
    			if (!current || dirty & /*$collectionsStore, modules*/ 12 && div3_class_value !== (div3_class_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi
    			? "claytons-card-content"
    			: "claytons-unclickable-card-content")) {
    				attr_dev(div3, "class", div3_class_value);
    			}

    			if (/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].engage && !/*$collectionsStore*/ ctx[2]["MODULES"][/*theModule*/ ctx[8].id].fyi) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_1$9(ctx);
    					if_block4.c();
    					if_block4.m(div5, null);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (!current || dirty & /*modules*/ 8 && div7_id_value !== (div7_id_value = "cc_module_" + /*theModule*/ ctx[8].id)) {
    				attr_dev(div7, "id", div7_id_value);
    			}

    			if (!current || dirty & /*modules*/ 8 && div8_id_value !== (div8_id_value = "cc_module_" + /*theModule*/ ctx[8].id)) {
    				attr_dev(div8, "id", div8_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(datewidget.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(datewidget.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			if (if_block0) if_block0.d();
    			if (switch_instance) destroy_component(switch_instance);
    			destroy_component(datewidget);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if_block3.d();
    			if (if_block4) if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(77:4) {#each modules as theModule}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*claytons*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function cardClick(event) {
    	// can we find the parent div.cc-clickable-card
    	let card = event.target.closest("div.cc-clickable-card");

    	if (card) {
    		// find the a.cc-card-link within card and click it
    		let link = card.querySelector("a.cc-card-link");

    		if (link) {
    			link.click();
    		}
    	}
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	let $configStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(4, $configStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GriffithCards', slots, []);
    	let calendar = new UniversityDateCalendar();
    	let { collection } = $$props;
    	let { claytons } = $$props;

    	if (!claytons) {
    		claytons = false;
    	}

    	const BANNER_TRANSLATION = {
    		image: BannerImage,
    		colour: BannerColour,
    		iframe: BannerIframe
    	};

    	// calculate the moduleIds belonging to collection
    	let modules;

    	/**
     * @function isUnPublishedUnallocated
     * @param moduleId - of the current module
     * @returns true if the module is unpublished or unallocated & if that information
     * should be shown.  In particular, is used to figure out if to show a small
     * message on a card about unpublished/unallocated
     *
     * Conditions include
     * - only staff (editMode) should see unpublished/unallocated messages
     * - students (!editMode) should not see unpublished/unallocated messages
     */
    	function isUnPublishedUnallocated(moduleId) {
    		if (!$configStore["editMode"]) {
    			return false;
    		}

    		// is it unpublished
    		if (!$collectionsStore["MODULES"][moduleId].published) {
    			return true;
    		}

    		// is it unallocated
    		return $collectionsStore["MODULES"][moduleId].collection !== collection;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (collection === undefined && !('collection' in $$props || $$self.$$.bound[$$self.$$.props['collection']])) {
    			console.warn("<GriffithCards> was created without expected prop 'collection'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<GriffithCards> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['collection', 'claytons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GriffithCards> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('collection' in $$props) $$invalidate(1, collection = $$props.collection);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		modulesStore,
    		configStore,
    		getModuleUrl,
    		deLabelModuleName,
    		BannerIframe,
    		BannerColour,
    		BannerImage,
    		DateWidget,
    		getRepresentationModules,
    		UniversityDateCalendar,
    		calendar,
    		collection,
    		claytons,
    		BANNER_TRANSLATION,
    		modules,
    		cardClick,
    		isUnPublishedUnallocated,
    		$collectionsStore,
    		$configStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('calendar' in $$props) $$invalidate(5, calendar = $$props.calendar);
    		if ('collection' in $$props) $$invalidate(1, collection = $$props.collection);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    		if ('modules' in $$props) $$invalidate(3, modules = $$props.modules);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*collection, claytons, $collectionsStore*/ 7) {
    			{
    				$$invalidate(3, modules = getRepresentationModules(collection, claytons, $collectionsStore["COLLECTIONS"][collection]["unallocated"]));
    			}
    		}
    	};

    	return [
    		claytons,
    		collection,
    		$collectionsStore,
    		modules,
    		$configStore,
    		calendar,
    		BANNER_TRANSLATION,
    		isUnPublishedUnallocated
    	];
    }

    class GriffithCards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { collection: 1, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GriffithCards",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get collection() {
    		throw new Error("<GriffithCards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<GriffithCards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error("<GriffithCards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error("<GriffithCards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Representations\CollectionOnly.svelte generated by Svelte v3.55.0 */

    function create_fragment$f(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionOnly', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollectionOnly> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class CollectionOnly extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionOnly",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src\components\Representations\AssessmentTable.svelte generated by Svelte v3.55.0 */

    const file$c = "src\\components\\Representations\\AssessmentTable.svelte";

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (160:0) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let span0;
    	let t1;
    	let th1;
    	let span1;
    	let t3;
    	let t4;
    	let th2;
    	let span2;
    	let t6;
    	let t7;
    	let tbody;
    	let if_block0 = /*numWeighting*/ ctx[2] > 0 && !/*$configStore*/ ctx[6]["editMode"] && create_if_block_12(ctx);
    	let if_block1 = /*numLearningOutcomes*/ ctx[3] > 0 && !/*$configStore*/ ctx[6]["editMode"] && create_if_block_11(ctx);
    	let each_value_1 = /*modules*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			span0.textContent = "Title";
    			t1 = space();
    			th1 = element("th");
    			span1 = element("span");
    			span1.textContent = "Description";
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			th2 = element("th");
    			span2 = element("span");
    			span2.textContent = "Due Date";
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span0, "class", "cc-table-header-text svelte-102b4gf");
    			add_location(span0, file$c, 169, 13, 6353);
    			attr_dev(th0, "role", "columnheader");
    			attr_dev(th0, "scope", "col");
    			attr_dev(th0, "class", "svelte-102b4gf");
    			add_location(th0, file$c, 168, 10, 6303);
    			attr_dev(span1, "class", "cc-table-header-text svelte-102b4gf");
    			add_location(span1, file$c, 172, 13, 6479);
    			attr_dev(th1, "role", "columnheader");
    			attr_dev(th1, "scope", "col");
    			attr_dev(th1, "class", "svelte-102b4gf");
    			add_location(th1, file$c, 171, 10, 6429);
    			attr_dev(span2, "class", "cc-table-header-text svelte-102b4gf");
    			add_location(span2, file$c, 180, 13, 6822);
    			attr_dev(th2, "role", "columnheader");
    			attr_dev(th2, "scope", "col");
    			attr_dev(th2, "class", "svelte-102b4gf");
    			add_location(th2, file$c, 179, 10, 6772);
    			attr_dev(tr, "role", "row");
    			attr_dev(tr, "class", "svelte-102b4gf");
    			add_location(tr, file$c, 167, 8, 6276);
    			attr_dev(thead, "role", "rowgroup");
    			attr_dev(thead, "class", "svelte-102b4gf");
    			add_location(thead, file$c, 166, 6, 6243);
    			attr_dev(tbody, "class", "svelte-102b4gf");
    			add_location(tbody, file$c, 189, 6, 7154);
    			attr_dev(table, "class", "cc-responsive-table svelte-102b4gf");
    			attr_dev(table, "role", "table");
    			add_location(table, file$c, 164, 4, 6151);
    			attr_dev(div, "id", "cc-assessment-table");
    			attr_dev(div, "class", "cc-assessment-container cc-representation svelte-102b4gf");
    			add_location(div, file$c, 160, 2, 6051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, span0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, span1);
    			append_dev(tr, t3);
    			if (if_block0) if_block0.m(tr, null);
    			append_dev(tr, t4);
    			append_dev(tr, th2);
    			append_dev(th2, span2);
    			append_dev(tr, t6);
    			if (if_block1) if_block1.m(tr, null);
    			append_dev(table, t7);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*numWeighting*/ ctx[2] > 0 && !/*$configStore*/ ctx[6]["editMode"]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_12(ctx);
    					if_block0.c();
    					if_block0.m(tr, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*numLearningOutcomes*/ ctx[3] > 0 && !/*$configStore*/ ctx[6]["editMode"]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_11(ctx);
    					if_block1.c();
    					if_block1.m(tr, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*checkModuleMetaData, $collectionsStore, modules, $configStore, numLearningOutcomes, generateModuleDate, numWeighting, collection, getModuleUrl*/ 126) {
    				each_value_1 = /*modules*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(160:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:0) {#if claytons}
    function create_if_block$9(ctx) {
    	let div;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let span0;
    	let t1;
    	let th1;
    	let span1;
    	let t3;
    	let t4;
    	let th2;
    	let span2;
    	let t6;
    	let t7;
    	let tbody;
    	let if_block0 = /*numWeighting*/ ctx[2] > 0 && create_if_block_6$2(ctx);
    	let if_block1 = /*numLearningOutcomes*/ ctx[3] && create_if_block_5$2(ctx);
    	let each_value = /*modules*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			span0.textContent = "Title";
    			t1 = space();
    			th1 = element("th");
    			span1 = element("span");
    			span1.textContent = "Description";
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			th2 = element("th");
    			span2 = element("span");
    			span2.textContent = "Due Date";
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(span0, "color", "#ffffff");
    			add_location(span0, file$c, 58, 12, 2316);
    			attr_dev(th0, "role", "columnheader");
    			attr_dev(th0, "scope", "col");
    			set_style(th0, "background-color", "#c02123");
    			add_location(th0, file$c, 53, 10, 2180);
    			set_style(span1, "color", "#ffffff");
    			add_location(span1, file$c, 65, 12, 2537);
    			attr_dev(th1, "role", "columnheader");
    			attr_dev(th1, "scope", "col");
    			set_style(th1, "background-color", "#c02123");
    			set_style(th1, "width", "20rem");
    			add_location(th1, file$c, 60, 10, 2387);
    			set_style(span2, "color", "#ffffff");
    			add_location(span2, file$c, 81, 12, 3027);
    			attr_dev(th2, "role", "columnheader");
    			attr_dev(th2, "scope", "col");
    			set_style(th2, "background-color", "#c02123");
    			add_location(th2, file$c, 76, 10, 2891);
    			add_location(tr, file$c, 52, 8, 2164);
    			add_location(thead, file$c, 51, 6, 2147);
    			attr_dev(tbody, "class", "svelte-102b4gf");
    			add_location(tbody, file$c, 94, 6, 3416);
    			attr_dev(table, "class", "ic-Table--hover-row ic-Table ic-Table--striped -ic-Table-condensed");
    			add_location(table, file$c, 48, 4, 2044);
    			attr_dev(div, "id", "cc-assessment-table");
    			attr_dev(div, "class", "svelte-102b4gf");
    			add_location(div, file$c, 47, 2, 2008);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, span0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, span1);
    			append_dev(tr, t3);
    			if (if_block0) if_block0.m(tr, null);
    			append_dev(tr, t4);
    			append_dev(tr, th2);
    			append_dev(th2, span2);
    			append_dev(tr, t6);
    			if (if_block1) if_block1.m(tr, null);
    			append_dev(table, t7);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*numWeighting*/ ctx[2] > 0) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_6$2(ctx);
    					if_block0.c();
    					if_block0.m(tr, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*numLearningOutcomes*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_5$2(ctx);
    					if_block1.c();
    					if_block1.m(tr, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*checkModuleMetaData, $collectionsStore, modules, $configStore, claytons, numLearningOutcomes, generateModuleDate, numWeighting, collection, getModuleUrl*/ 127) {
    				each_value = /*modules*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(47:0) {#if claytons}",
    		ctx
    	});

    	return block;
    }

    // (175:10) {#if numWeighting > 0 && !$configStore["editMode"] }
    function create_if_block_12(ctx) {
    	let th;
    	let span;

    	const block = {
    		c: function create() {
    			th = element("th");
    			span = element("span");
    			span.textContent = "Weighting";
    			attr_dev(span, "class", "cc-table-header-text svelte-102b4gf");
    			add_location(span, file$c, 176, 13, 6675);
    			attr_dev(th, "role", "columnheader");
    			attr_dev(th, "scope", "col");
    			attr_dev(th, "class", "svelte-102b4gf");
    			add_location(th, file$c, 175, 10, 6625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(175:10) {#if numWeighting > 0 && !$configStore[\\\"editMode\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (183:10) {#if numLearningOutcomes > 0 && !$configStore["editMode"] }
    function create_if_block_11(ctx) {
    	let th;
    	let span;

    	const block = {
    		c: function create() {
    			th = element("th");
    			span = element("span");
    			span.textContent = "Learning Outcomes";
    			attr_dev(span, "class", "cc-table-header-text svelte-102b4gf");
    			add_location(span, file$c, 184, 13, 7022);
    			attr_dev(th, "role", "columnheader");
    			attr_dev(th, "scope", "col");
    			attr_dev(th, "class", "svelte-102b4gf");
    			add_location(th, file$c, 183, 10, 6972);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(183:10) {#if numLearningOutcomes > 0 && !$configStore[\\\"editMode\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (210:14) {#if $configStore["editMode"] && !$collectionsStore["MODULES"][module.id].published}
    function create_if_block_10(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Unpublished";
    			attr_dev(div, "class", "cc-published svelte-102b4gf");
    			add_location(div, file$c, 210, 16, 8019);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(210:14) {#if $configStore[\\\"editMode\\\"] && !$collectionsStore[\\\"MODULES\\\"][module.id].published}",
    		ctx
    	});

    	return block;
    }

    // (213:14) {#if $configStore["editMode"] && $collectionsStore["MODULES"][module.id].collection !== collection}
    function create_if_block_9(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No collection allocated";
    			attr_dev(div, "class", "cc-unallocated svelte-102b4gf");
    			add_location(div, file$c, 213, 16, 8216);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(213:14) {#if $configStore[\\\"editMode\\\"] && $collectionsStore[\\\"MODULES\\\"][module.id].collection !== collection}",
    		ctx
    	});

    	return block;
    }

    // (222:10) {#if numWeighting > 0 && ! $configStore["editMode"] }
    function create_if_block_8(ctx) {
    	let td;
    	let span;
    	let t1;
    	let div;
    	let p;
    	let t2_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "weighting", /*$configStore*/ ctx[6]["editMode"]) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			td = element("td");
    			span = element("span");
    			span.textContent = "Weighting";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(span, "class", "cc-responsive-table__heading svelte-102b4gf");
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$c, 223, 14, 8616);
    			attr_dev(p, "class", "svelte-102b4gf");
    			add_location(p, file$c, 227, 16, 8794);
    			attr_dev(div, "class", "cc-table-cell-text svelte-102b4gf");
    			add_location(div, file$c, 226, 14, 8744);
    			attr_dev(td, "role", "cell");
    			attr_dev(td, "class", "svelte-102b4gf");
    			add_location(td, file$c, 222, 12, 8584);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, span);
    			append_dev(td, t1);
    			append_dev(td, div);
    			append_dev(div, p);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules, $configStore*/ 112 && t2_value !== (t2_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "weighting", /*$configStore*/ ctx[6]["editMode"]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(222:10) {#if numWeighting > 0 && ! $configStore[\\\"editMode\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (248:10) {#if numLearningOutcomes > 0 && !$configStore["editMode"] }
    function create_if_block_7$1(ctx) {
    	let td;
    	let span;
    	let t1;
    	let div;
    	let p;
    	let t2_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "learning outcomes", /*$configStore*/ ctx[6]["editMode"]) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			td = element("td");
    			span = element("span");
    			span.textContent = "Learning Outcomes";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(span, "class", "cc-responsive-table__heading svelte-102b4gf");
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$c, 249, 14, 9571);
    			attr_dev(p, "class", "svelte-102b4gf");
    			add_location(p, file$c, 253, 16, 9757);
    			attr_dev(div, "class", "cc-table-cell-text svelte-102b4gf");
    			add_location(div, file$c, 252, 14, 9707);
    			attr_dev(td, "role", "cell");
    			attr_dev(td, "class", "svelte-102b4gf");
    			add_location(td, file$c, 248, 12, 9539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, span);
    			append_dev(td, t1);
    			append_dev(td, div);
    			append_dev(div, p);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules, $configStore*/ 112 && t2_value !== (t2_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "learning outcomes", /*$configStore*/ ctx[6]["editMode"]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(248:10) {#if numLearningOutcomes > 0 && !$configStore[\\\"editMode\\\"] }",
    		ctx
    	});

    	return block;
    }

    // (191:8) {#each modules as module}
    function create_each_block_1$2(ctx) {
    	let tr;
    	let td0;
    	let span0;
    	let t1;
    	let div0;
    	let p0;
    	let a;
    	let t2_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].name + "";
    	let t2;
    	let a_href_value;
    	let t3;
    	let td1;
    	let span1;
    	let t5;
    	let t6;
    	let t7;
    	let div1;
    	let p1;
    	let raw_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].description + "";
    	let t8;
    	let t9;
    	let td2;
    	let span2;
    	let t11;
    	let div2;
    	let p2;
    	let t12_value = generateModuleDate(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id]) + "";
    	let t12;
    	let t13;
    	let t14;
    	let if_block0 = /*$configStore*/ ctx[6]["editMode"] && !/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].published && create_if_block_10(ctx);
    	let if_block1 = /*$configStore*/ ctx[6]["editMode"] && /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].collection !== /*collection*/ ctx[1] && create_if_block_9(ctx);
    	let if_block2 = /*numWeighting*/ ctx[2] > 0 && !/*$configStore*/ ctx[6]["editMode"] && create_if_block_8(ctx);
    	let if_block3 = /*numLearningOutcomes*/ ctx[3] > 0 && !/*$configStore*/ ctx[6]["editMode"] && create_if_block_7$1(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			span0 = element("span");
    			span0.textContent = "Title";
    			t1 = space();
    			div0 = element("div");
    			p0 = element("p");
    			a = element("a");
    			t2 = text(t2_value);
    			t3 = space();
    			td1 = element("td");
    			span1 = element("span");
    			span1.textContent = "Description";
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			div1 = element("div");
    			p1 = element("p");
    			t8 = space();
    			if (if_block2) if_block2.c();
    			t9 = space();
    			td2 = element("td");
    			span2 = element("span");
    			span2.textContent = "Due Date";
    			t11 = space();
    			div2 = element("div");
    			p2 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			if (if_block3) if_block3.c();
    			t14 = space();
    			attr_dev(span0, "class", "cc-responsive-table__heading svelte-102b4gf");
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$c, 193, 14, 7269);
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*module*/ ctx[7].id));
    			add_location(a, file$c, 198, 18, 7466);
    			attr_dev(p0, "class", "svelte-102b4gf");
    			add_location(p0, file$c, 197, 16, 7443);
    			attr_dev(div0, "class", "cc-table-cell-text svelte-102b4gf");
    			add_location(div0, file$c, 196, 14, 7393);
    			attr_dev(td0, "role", "cell");
    			attr_dev(td0, "class", "svelte-102b4gf");
    			add_location(td0, file$c, 192, 12, 7237);
    			attr_dev(span1, "class", "cc-responsive-table__heading svelte-102b4gf");
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$c, 206, 14, 7787);
    			attr_dev(p1, "class", "svelte-102b4gf");
    			add_location(p1, file$c, 216, 16, 8360);
    			attr_dev(div1, "class", "cc-table-cell-text svelte-102b4gf");
    			add_location(div1, file$c, 215, 14, 8310);
    			attr_dev(td1, "role", "cell");
    			attr_dev(td1, "class", "descriptionCell svelte-102b4gf");
    			add_location(td1, file$c, 205, 12, 7731);
    			attr_dev(span2, "class", "cc-responsive-table__heading svelte-102b4gf");
    			attr_dev(span2, "aria-hidden", "true");
    			add_location(span2, file$c, 238, 14, 9130);
    			attr_dev(p2, "class", "svelte-102b4gf");
    			add_location(p2, file$c, 242, 16, 9307);
    			attr_dev(div2, "class", "cc-table-cell-text svelte-102b4gf");
    			add_location(div2, file$c, 241, 14, 9257);
    			attr_dev(td2, "role", "cell");
    			attr_dev(td2, "class", "svelte-102b4gf");
    			add_location(td2, file$c, 237, 12, 9098);
    			attr_dev(tr, "role", "row");
    			attr_dev(tr, "class", "svelte-102b4gf");
    			add_location(tr, file$c, 191, 10, 7208);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, span0);
    			append_dev(td0, t1);
    			append_dev(td0, div0);
    			append_dev(div0, p0);
    			append_dev(p0, a);
    			append_dev(a, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td1);
    			append_dev(td1, span1);
    			append_dev(td1, t5);
    			if (if_block0) if_block0.m(td1, null);
    			append_dev(td1, t6);
    			if (if_block1) if_block1.m(td1, null);
    			append_dev(td1, t7);
    			append_dev(td1, div1);
    			append_dev(div1, p1);
    			p1.innerHTML = raw_value;
    			append_dev(tr, t8);
    			if (if_block2) if_block2.m(tr, null);
    			append_dev(tr, t9);
    			append_dev(tr, td2);
    			append_dev(td2, span2);
    			append_dev(td2, t11);
    			append_dev(td2, div2);
    			append_dev(div2, p2);
    			append_dev(p2, t12);
    			append_dev(tr, t13);
    			if (if_block3) if_block3.m(tr, null);
    			append_dev(tr, t14);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 48 && t2_value !== (t2_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].name + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*modules*/ 16 && a_href_value !== (a_href_value = getModuleUrl(/*module*/ ctx[7].id))) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (/*$configStore*/ ctx[6]["editMode"] && !/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].published) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_10(ctx);
    					if_block0.c();
    					if_block0.m(td1, t6);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$configStore*/ ctx[6]["editMode"] && /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].collection !== /*collection*/ ctx[1]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_9(ctx);
    					if_block1.c();
    					if_block1.m(td1, t7);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$collectionsStore, modules*/ 48 && raw_value !== (raw_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].description + "")) p1.innerHTML = raw_value;
    			if (/*numWeighting*/ ctx[2] > 0 && !/*$configStore*/ ctx[6]["editMode"]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_8(ctx);
    					if_block2.c();
    					if_block2.m(tr, t9);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$collectionsStore, modules*/ 48 && t12_value !== (t12_value = generateModuleDate(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id]) + "")) set_data_dev(t12, t12_value);

    			if (/*numLearningOutcomes*/ ctx[3] > 0 && !/*$configStore*/ ctx[6]["editMode"]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_7$1(ctx);
    					if_block3.c();
    					if_block3.m(tr, t14);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(191:8) {#each modules as module}",
    		ctx
    	});

    	return block;
    }

    // (68:10) {#if numWeighting > 0 }
    function create_if_block_6$2(ctx) {
    	let th;
    	let span;

    	const block = {
    		c: function create() {
    			th = element("th");
    			span = element("span");
    			span.textContent = "Weighting";
    			set_style(span, "color", "#ffffff");
    			add_location(span, file$c, 73, 14, 2797);
    			attr_dev(th, "role", "columnheader");
    			attr_dev(th, "scope", "col");
    			set_style(th, "background-color", "#c02123");
    			add_location(th, file$c, 68, 12, 2651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(68:10) {#if numWeighting > 0 }",
    		ctx
    	});

    	return block;
    }

    // (84:10) {#if numLearningOutcomes }
    function create_if_block_5$2(ctx) {
    	let th;
    	let span;

    	const block = {
    		c: function create() {
    			th = element("th");
    			span = element("span");
    			span.textContent = "Learning Outcomes";
    			set_style(span, "color", "#ffffff");
    			add_location(span, file$c, 89, 14, 3287);
    			attr_dev(th, "role", "columnheader");
    			attr_dev(th, "scope", "col");
    			set_style(th, "background-color", "#c02123");
    			add_location(th, file$c, 84, 12, 3141);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(84:10) {#if numLearningOutcomes }",
    		ctx
    	});

    	return block;
    }

    // (108:14) {#if $configStore["editMode"] && !claytons && !$collectionsStore["MODULES"][module.id].published}
    function create_if_block_4$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Unpublished";
    			attr_dev(div, "class", "cc-published svelte-102b4gf");
    			add_location(div, file$c, 108, 16, 4088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(108:14) {#if $configStore[\\\"editMode\\\"] && !claytons && !$collectionsStore[\\\"MODULES\\\"][module.id].published}",
    		ctx
    	});

    	return block;
    }

    // (111:14) {#if $configStore["editMode"] && !claytons && $collectionsStore["MODULES"][module.id].collection !== collection}
    function create_if_block_3$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No collection allocated";
    			attr_dev(div, "class", "cc-unallocated svelte-102b4gf");
    			add_location(div, file$c, 111, 16, 4298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(111:14) {#if $configStore[\\\"editMode\\\"] && !claytons && $collectionsStore[\\\"MODULES\\\"][module.id].collection !== collection}",
    		ctx
    	});

    	return block;
    }

    // (120:12) {#if numWeighting > 0 }
    function create_if_block_2$7(ctx) {
    	let td;
    	let div;
    	let p;
    	let t_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "weighting", /*$configStore*/ ctx[6]["editMode"], /*claytons*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			div = element("div");
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$c, 122, 18, 4807);
    			set_style(div, "margin", "0");
    			set_style(div, "font-size", "0.8rem");
    			add_location(div, file$c, 121, 16, 4747);
    			attr_dev(td, "role", "cell");
    			set_style(td, "display", "table-cell");
    			set_style(td, "text-align", "left");
    			set_style(td, "vertical-align", "top");
    			attr_dev(td, "class", "svelte-102b4gf");
    			add_location(td, file$c, 120, 14, 4648);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, div);
    			append_dev(div, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules, $configStore, claytons*/ 113 && t_value !== (t_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "weighting", /*$configStore*/ ctx[6]["editMode"], /*claytons*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(120:12) {#if numWeighting > 0 }",
    		ctx
    	});

    	return block;
    }

    // (141:12) {#if numLearningOutcomes}
    function create_if_block_1$8(ctx) {
    	let td;
    	let div;
    	let p;
    	let t_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "learning outcomes", /*$configStore*/ ctx[6]["editMode"], /*claytons*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			div = element("div");
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$c, 143, 18, 5617);
    			set_style(div, "margin", "0");
    			set_style(div, "font-size", "0.8rem");
    			add_location(div, file$c, 142, 16, 5557);
    			attr_dev(td, "role", "cell");
    			attr_dev(td, "class", "svelte-102b4gf");
    			add_location(td, file$c, 141, 14, 5523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, div);
    			append_dev(div, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules, $configStore, claytons*/ 113 && t_value !== (t_value = checkModuleMetaData(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id], "learning outcomes", /*$configStore*/ ctx[6]["editMode"], /*claytons*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(141:12) {#if numLearningOutcomes}",
    		ctx
    	});

    	return block;
    }

    // (96:8) {#each modules as module}
    function create_each_block$8(ctx) {
    	let tr;
    	let td0;
    	let div0;
    	let p0;
    	let a;
    	let raw0_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].name + "";
    	let a_href_value;
    	let t0;
    	let td1;
    	let t1;
    	let t2;
    	let div1;
    	let p1;
    	let raw1_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].description + "";
    	let t3;
    	let t4;
    	let td2;
    	let div2;
    	let p2;
    	let raw2_value = generateModuleDate(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id]) + "";
    	let t5;
    	let t6;
    	let if_block0 = /*$configStore*/ ctx[6]["editMode"] && !/*claytons*/ ctx[0] && !/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].published && create_if_block_4$3(ctx);
    	let if_block1 = /*$configStore*/ ctx[6]["editMode"] && !/*claytons*/ ctx[0] && /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].collection !== /*collection*/ ctx[1] && create_if_block_3$4(ctx);
    	let if_block2 = /*numWeighting*/ ctx[2] > 0 && create_if_block_2$7(ctx);
    	let if_block3 = /*numLearningOutcomes*/ ctx[3] && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div0 = element("div");
    			p0 = element("p");
    			a = element("a");
    			t0 = space();
    			td1 = element("td");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div1 = element("div");
    			p1 = element("p");
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			td2 = element("td");
    			div2 = element("div");
    			p2 = element("p");
    			t5 = space();
    			if (if_block3) if_block3.c();
    			t6 = space();
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*module*/ ctx[7].id));
    			add_location(a, file$c, 100, 18, 3667);
    			add_location(p0, file$c, 99, 16, 3644);
    			set_style(div0, "margin", "0");
    			set_style(div0, "font-size", "0.8rem");
    			add_location(div0, file$c, 98, 14, 3586);
    			attr_dev(td0, "role", "cell");
    			set_style(td0, "display", "table-cell");
    			set_style(td0, "text-align", "left");
    			set_style(td0, "vertical-align", "top");
    			attr_dev(td0, "class", "svelte-102b4gf");
    			add_location(td0, file$c, 97, 12, 3488);
    			add_location(p1, file$c, 114, 16, 4450);
    			set_style(div1, "margin", "0");
    			set_style(div1, "font-size", "0.8rem");
    			add_location(div1, file$c, 113, 14, 4392);
    			attr_dev(td1, "role", "cell");
    			set_style(td1, "display", "table-cell");
    			set_style(td1, "text-align", "left");
    			set_style(td1, "vertical-align", "top");
    			attr_dev(td1, "class", "svelte-102b4gf");
    			add_location(td1, file$c, 106, 12, 3876);
    			add_location(p2, file$c, 135, 16, 5315);
    			set_style(div2, "margin", "0");
    			set_style(div2, "font-size", "0.8rem");
    			add_location(div2, file$c, 134, 14, 5257);
    			attr_dev(td2, "role", "cell");
    			set_style(td2, "display", "table-cell");
    			set_style(td2, "text-align", "left");
    			set_style(td2, "vertical-align", "top");
    			attr_dev(td2, "class", "svelte-102b4gf");
    			add_location(td2, file$c, 133, 12, 5160);
    			attr_dev(tr, "class", "svelte-102b4gf");
    			add_location(tr, file$c, 96, 10, 3470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div0);
    			append_dev(div0, p0);
    			append_dev(p0, a);
    			a.innerHTML = raw0_value;
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			if (if_block0) if_block0.m(td1, null);
    			append_dev(td1, t1);
    			if (if_block1) if_block1.m(td1, null);
    			append_dev(td1, t2);
    			append_dev(td1, div1);
    			append_dev(div1, p1);
    			p1.innerHTML = raw1_value;
    			append_dev(tr, t3);
    			if (if_block2) if_block2.m(tr, null);
    			append_dev(tr, t4);
    			append_dev(tr, td2);
    			append_dev(td2, div2);
    			append_dev(div2, p2);
    			p2.innerHTML = raw2_value;
    			append_dev(tr, t5);
    			if (if_block3) if_block3.m(tr, null);
    			append_dev(tr, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modules*/ 48 && raw0_value !== (raw0_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].name + "")) a.innerHTML = raw0_value;
    			if (dirty & /*modules*/ 16 && a_href_value !== (a_href_value = getModuleUrl(/*module*/ ctx[7].id))) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (/*$configStore*/ ctx[6]["editMode"] && !/*claytons*/ ctx[0] && !/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].published) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_4$3(ctx);
    					if_block0.c();
    					if_block0.m(td1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$configStore*/ ctx[6]["editMode"] && !/*claytons*/ ctx[0] && /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].collection !== /*collection*/ ctx[1]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					if_block1.m(td1, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$collectionsStore, modules*/ 48 && raw1_value !== (raw1_value = /*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id].description + "")) p1.innerHTML = raw1_value;
    			if (/*numWeighting*/ ctx[2] > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_2$7(ctx);
    					if_block2.c();
    					if_block2.m(tr, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$collectionsStore, modules*/ 48 && raw2_value !== (raw2_value = generateModuleDate(/*$collectionsStore*/ ctx[5]["MODULES"][/*module*/ ctx[7].id]) + "")) p2.innerHTML = raw2_value;
    			if (/*numLearningOutcomes*/ ctx[3]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_1$8(ctx);
    					if_block3.c();
    					if_block3.m(tr, t6);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(96:8) {#each modules as module}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*claytons*/ ctx[0]) return create_if_block$9;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	let $configStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(5, $collectionsStore = $$value));
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(6, $configStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AssessmentTable', slots, []);
    	let { collection } = $$props;
    	let { claytons } = $$props;

    	if (!claytons) {
    		claytons = false;
    	}

    	let numWeighting = 0;
    	let numLearningOutcomes = 0;

    	// kludge to test reactive nature
    	// set collection to currentCollection
    	// TODO - this isn't right, the prop isn't being dynamically updated
    	//collection = $configStore['currentCollection'];
    	let modules;

    	$$self.$$.on_mount.push(function () {
    		if (collection === undefined && !('collection' in $$props || $$self.$$.bound[$$self.$$.props['collection']])) {
    			console.warn("<AssessmentTable> was created without expected prop 'collection'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<AssessmentTable> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['collection', 'claytons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AssessmentTable> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('collection' in $$props) $$invalidate(1, collection = $$props.collection);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		modulesStore,
    		configStore,
    		getCollectionCanvasModules,
    		addUnallocatedModules,
    		getModuleUrl,
    		getRepresentationModules,
    		generateModuleDate,
    		checkModuleMetaData,
    		collection,
    		claytons,
    		numWeighting,
    		numLearningOutcomes,
    		modules,
    		$collectionsStore,
    		$configStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collection' in $$props) $$invalidate(1, collection = $$props.collection);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    		if ('numWeighting' in $$props) $$invalidate(2, numWeighting = $$props.numWeighting);
    		if ('numLearningOutcomes' in $$props) $$invalidate(3, numLearningOutcomes = $$props.numLearningOutcomes);
    		if ('modules' in $$props) $$invalidate(4, modules = $$props.modules);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*collection, claytons, $collectionsStore, modules, numWeighting, numLearningOutcomes*/ 63) {
    			{
    				$$invalidate(4, modules = getRepresentationModules(collection, claytons, $collectionsStore["COLLECTIONS"][collection]["unallocated"]));

    				// count the number of modules that have weighting and learning outcomes
    				modules.forEach(module => {
    					if ($collectionsStore["MODULES"][module.id].hasOwnProperty("metadata") && $collectionsStore["MODULES"][module.id]["metadata"].hasOwnProperty("weighting") && $collectionsStore["MODULES"][module.id]["metadata"]["weighting"] !== "") {
    						$$invalidate(2, numWeighting++, numWeighting);
    					}

    					if ($collectionsStore["MODULES"][module.id].hasOwnProperty("metadata") && $collectionsStore["MODULES"][module.id]["metadata"].hasOwnProperty("learning outcomes") && $collectionsStore["MODULES"][module.id]["metadata"]["learning outcomes"] !== "") {
    						$$invalidate(3, numLearningOutcomes++, numLearningOutcomes);
    					}
    				});
    			}
    		}
    	};

    	return [
    		claytons,
    		collection,
    		numWeighting,
    		numLearningOutcomes,
    		modules,
    		$collectionsStore,
    		$configStore
    	];
    }

    class AssessmentTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { collection: 1, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AssessmentTable",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get collection() {
    		throw new Error("<AssessmentTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<AssessmentTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error("<AssessmentTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error("<AssessmentTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Representations\CollectionsTable.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1$4 } = globals;

    const file$b = "src\\components\\Representations\\CollectionsTable.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (86:6) {#if collectionName !== "unallocated"}
    function create_if_block_3$3(ctx) {
    	let t0;
    	let a;
    	let t1_value = /*collectionName*/ ctx[9] + "";
    	let t1;
    	let a_href_value;
    	let t2;
    	let show_if = !(/*collectionsOrder*/ ctx[1].length - 1 === /*collectionsOrder*/ ctx[1].indexOf(/*collectionName*/ ctx[9]));
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_4$2(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("");
    			a = element("a");
    			t1 = text(t1_value);
    			t2 = text("\r\n        ");
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(a, "href", a_href_value = "#collection-" + /*collectionName*/ ctx[9]);
    			add_location(a, file$b, 86, 14, 3266);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a, anchor);
    			append_dev(a, t1);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*collectionsOrder*/ 2 && t1_value !== (t1_value = /*collectionName*/ ctx[9] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*collectionsOrder*/ 2 && a_href_value !== (a_href_value = "#collection-" + /*collectionName*/ ctx[9])) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*collectionsOrder*/ 2) show_if = !(/*collectionsOrder*/ ctx[1].length - 1 === /*collectionsOrder*/ ctx[1].indexOf(/*collectionName*/ ctx[9]));

    			if (show_if) {
    				if (if_block) ; else {
    					if_block = create_if_block_4$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(86:6) {#if collectionName !== \\\"unallocated\\\"}",
    		ctx
    	});

    	return block;
    }

    // (88:8) {#if !(collectionsOrder.length - 1 === collectionsOrder.indexOf(collectionName))}
    function create_if_block_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("|");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(88:8) {#if !(collectionsOrder.length - 1 === collectionsOrder.indexOf(collectionName))}",
    		ctx
    	});

    	return block;
    }

    // (85:4) {#each collectionsOrder as collectionName}
    function create_each_block_2$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*collectionName*/ ctx[9] !== "unallocated" && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*collectionName*/ ctx[9] !== "unallocated") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(85:4) {#each collectionsOrder as collectionName}",
    		ctx
    	});

    	return block;
    }

    // (123:8) {#if collectionName !== "unallocated"}
    function create_if_block_2$6(ctx) {
    	let tr;
    	let td;
    	let h3;
    	let t_value = /*collectionName*/ ctx[9] + "";
    	let t;
    	let h3_id_value;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			h3 = element("h3");
    			t = text(t_value);
    			attr_dev(h3, "id", h3_id_value = "collection-" + /*collectionName*/ ctx[9]);
    			add_location(h3, file$b, 129, 14, 4563);
    			set_style(td, "vertical-align", "top: padding:0.5rem");
    			attr_dev(td, "role", "cell");
    			attr_dev(td, "colspan", "3");
    			add_location(td, file$b, 124, 12, 4415);
    			set_style(tr, "background", "white");
    			add_location(tr, file$b, 123, 10, 4371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, h3);
    			append_dev(h3, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*collectionsOrder*/ 2 && t_value !== (t_value = /*collectionName*/ ctx[9] + "")) set_data_dev(t, t_value);

    			if (dirty & /*collectionsOrder*/ 2 && h3_id_value !== (h3_id_value = "collection-" + /*collectionName*/ ctx[9])) {
    				attr_dev(h3, "id", h3_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(123:8) {#if collectionName !== \\\"unallocated\\\"}",
    		ctx
    	});

    	return block;
    }

    // (153:16) {#if !claytons && $configStore["editMode"] && !$collectionsStore["MODULES"][module.id].published}
    function create_if_block_1$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Unpublished";
    			attr_dev(div, "class", "cc-published svelte-zkzf4g");
    			add_location(div, file$b, 153, 18, 5588);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(153:16) {#if !claytons && $configStore[\\\"editMode\\\"] && !$collectionsStore[\\\"MODULES\\\"][module.id].published}",
    		ctx
    	});

    	return block;
    }

    // (156:16) {#if !claytons && $configStore["editMode"] && $collectionsStore["MODULES"][module.id].collection !== collectionName}
    function create_if_block$8(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No collection allocated";
    			attr_dev(div, "class", "cc-unallocated svelte-zkzf4g");
    			add_location(div, file$b, 156, 18, 5808);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(156:16) {#if !claytons && $configStore[\\\"editMode\\\"] && $collectionsStore[\\\"MODULES\\\"][module.id].collection !== collectionName}",
    		ctx
    	});

    	return block;
    }

    // (135:8) {#each modulesObj[collectionName] as module}
    function create_each_block_1$1(ctx) {
    	let tr;
    	let td0;
    	let div0;
    	let p0;
    	let t0_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].actualNum + "";
    	let t0;
    	let t1;
    	let td1;
    	let div1;
    	let p1;
    	let a;
    	let raw0_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id]) + "";
    	let a_href_value;
    	let t2;
    	let td2;
    	let div2;
    	let t3;
    	let t4;
    	let p2;
    	let raw1_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].description + "";
    	let t5;
    	let if_block0 = !/*claytons*/ ctx[0] && /*$configStore*/ ctx[5]["editMode"] && !/*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].published && create_if_block_1$7(ctx);
    	let if_block1 = !/*claytons*/ ctx[0] && /*$configStore*/ ctx[5]["editMode"] && /*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].collection !== /*collectionName*/ ctx[9] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div0 = element("div");
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			div1 = element("div");
    			p1 = element("p");
    			a = element("a");
    			t2 = space();
    			td2 = element("td");
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			p2 = element("p");
    			t5 = space();
    			add_location(p0, file$b, 138, 16, 4876);
    			set_style(div0, "margin", "0");
    			add_location(div0, file$b, 137, 14, 4835);
    			attr_dev(td0, "role", "cell");
    			set_style(td0, "vertical-align", "top");
    			set_style(td0, "padding", "0.5rem");
    			add_location(td0, file$b, 136, 12, 4758);
    			attr_dev(a, "href", a_href_value = getModuleUrl(/*module*/ ctx[12].id));
    			add_location(a, file$b, 144, 18, 5130);
    			add_location(p1, file$b, 143, 16, 5107);
    			set_style(div1, "margin", "0");
    			add_location(div1, file$b, 142, 14, 5066);
    			attr_dev(td1, "role", "cell");
    			set_style(td1, "vertical-align", "top");
    			set_style(td1, "padding", "0.5rem");
    			add_location(td1, file$b, 141, 12, 4989);
    			add_location(p2, file$b, 158, 16, 5906);
    			set_style(div2, "margin", "0");
    			add_location(div2, file$b, 151, 14, 5430);
    			attr_dev(td2, "role", "cell");
    			set_style(td2, "vertical-align", "top");
    			set_style(td2, "padding", "0.5rem");
    			add_location(td2, file$b, 150, 12, 5353);
    			add_location(tr, file$b, 135, 10, 4740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div0);
    			append_dev(div0, p0);
    			append_dev(p0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, div1);
    			append_dev(div1, p1);
    			append_dev(p1, a);
    			a.innerHTML = raw0_value;
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, div2);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t3);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t4);
    			append_dev(div2, p2);
    			p2.innerHTML = raw1_value;
    			append_dev(tr, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$collectionsStore, modulesObj, collectionsOrder*/ 22 && t0_value !== (t0_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].actualNum + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$collectionsStore, modulesObj, collectionsOrder*/ 22 && raw0_value !== (raw0_value = deLabelModuleName(/*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id]) + "")) a.innerHTML = raw0_value;
    			if (dirty & /*modulesObj, collectionsOrder*/ 18 && a_href_value !== (a_href_value = getModuleUrl(/*module*/ ctx[12].id))) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (!/*claytons*/ ctx[0] && /*$configStore*/ ctx[5]["editMode"] && !/*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].published) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$7(ctx);
    					if_block0.c();
    					if_block0.m(div2, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*claytons*/ ctx[0] && /*$configStore*/ ctx[5]["editMode"] && /*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].collection !== /*collectionName*/ ctx[9]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					if_block1.m(div2, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$collectionsStore, modulesObj, collectionsOrder*/ 22 && raw1_value !== (raw1_value = /*$collectionsStore*/ ctx[2]["MODULES"][/*module*/ ctx[12].id].description + "")) p2.innerHTML = raw1_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(135:8) {#each modulesObj[collectionName] as module}",
    		ctx
    	});

    	return block;
    }

    // (122:6) {#each collectionsOrder as collectionName}
    function create_each_block$7(ctx) {
    	let t;
    	let each_1_anchor;
    	let if_block = /*collectionName*/ ctx[9] !== "unallocated" && create_if_block_2$6(ctx);
    	let each_value_1 = /*modulesObj*/ ctx[4][/*collectionName*/ ctx[9]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*collectionName*/ ctx[9] !== "unallocated") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$collectionsStore, modulesObj, collectionsOrder, claytons, $configStore, getModuleUrl, deLabelModuleName*/ 55) {
    				each_value_1 = /*modulesObj*/ ctx[4][/*collectionName*/ ctx[9]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(122:6) {#each collectionsOrder as collectionName}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let span0;
    	let t3;
    	let t4;
    	let th1;
    	let span1;
    	let t6;
    	let th2;
    	let span2;
    	let t8;
    	let tbody;
    	let each_value_2 = /*collectionsOrder*/ ctx[1];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each_value = /*collectionsOrder*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("[\r\n    ");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t1 = text("\r\n    ]");
    			t2 = space();
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			t3 = text(/*labelHeader*/ ctx[3]);
    			t4 = space();
    			th1 = element("th");
    			span1 = element("span");
    			span1.textContent = "Title";
    			t6 = space();
    			th2 = element("th");
    			span2 = element("span");
    			span2.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "cc-collections-table-nav");
    			set_style(div0, "width", "100%");
    			set_style(div0, "text-align", "center");
    			set_style(div0, "padding", "1em");
    			add_location(div0, file$b, 79, 2, 3048);
    			set_style(span0, "color", "#ffffff");
    			add_location(span0, file$b, 102, 10, 3740);
    			attr_dev(th0, "role", "columnheader");
    			attr_dev(th0, "scope", "col");
    			set_style(th0, "width", "10%");
    			set_style(th0, "background-color", "#c02123");
    			add_location(th0, file$b, 97, 8, 3602);
    			set_style(span1, "color", "#ffffff");
    			add_location(span1, file$b, 109, 10, 3953);
    			attr_dev(th1, "role", "columnheader");
    			attr_dev(th1, "scope", "col");
    			set_style(th1, "width", "40%");
    			set_style(th1, "background-color", "#c02123");
    			add_location(th1, file$b, 104, 8, 3815);
    			set_style(span2, "color", "#ffffff");
    			add_location(span2, file$b, 116, 10, 4158);
    			attr_dev(th2, "role", "columnheader");
    			attr_dev(th2, "scope", "col");
    			set_style(th2, "width", "50%");
    			set_style(th2, "background-color", "#c02123");
    			add_location(th2, file$b, 111, 8, 4020);
    			add_location(tr, file$b, 96, 6, 3588);
    			add_location(thead, file$b, 95, 4, 3573);
    			add_location(tbody, file$b, 120, 4, 4254);
    			attr_dev(table, "class", "ic-Table--hover-row ic-Table ic-Table--striped -ic-Table--condensed");
    			add_location(table, file$b, 92, 2, 3475);
    			attr_dev(div1, "id", "cc-collections-table");
    			add_location(div1, file$b, 78, 0, 3013);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append_dev(div0, t1);
    			append_dev(div1, t2);
    			append_dev(div1, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, span0);
    			append_dev(span0, t3);
    			append_dev(tr, t4);
    			append_dev(tr, th1);
    			append_dev(th1, span1);
    			append_dev(tr, t6);
    			append_dev(tr, th2);
    			append_dev(th2, span2);
    			append_dev(table, t8);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*collectionsOrder*/ 2) {
    				each_value_2 = /*collectionsOrder*/ ctx[1];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div0, t1);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty & /*labelHeader*/ 8) set_data_dev(t3, /*labelHeader*/ ctx[3]);

    			if (dirty & /*modulesObj, collectionsOrder, $collectionsStore, claytons, $configStore, getModuleUrl, deLabelModuleName*/ 55) {
    				each_value = /*collectionsOrder*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	let $configStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(5, $configStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionsTable', slots, []);
    	let { collection } = $$props;
    	let { claytons } = $$props;

    	if (!claytons) {
    		claytons = false;
    	}

    	let labelHeader = "Week";

    	// kludge to test reactive nature
    	// set collection to currentCollection
    	let modulesObj;

    	let collectionsOrder = [];

    	/**
     * @function getMostUsedLabel
     * @description Return the label that is used the most by the modules
     */
    	function getMostUsedLabel() {
    		let labelCounts = {};

    		// loop through all of the modules
    		// - count the number of times each label is used
    		for (const key in $collectionsStore["MODULES"]) {
    			if (!labelCounts.hasOwnProperty($collectionsStore["MODULES"][key].label)) {
    				labelCounts[$collectionsStore["MODULES"][key].label] = 0;
    			}

    			labelCounts[$collectionsStore["MODULES"][key].label] += 1;
    		}

    		//    $collectionsStore["MODULES"].forEach((module) => {
    		//   });
    		// return the label that is used the most
    		return Object.keys(labelCounts).reduce((a, b) => labelCounts[a] > labelCounts[b] ? a : b);
    	}

    	/**
     * @function getCollectionsTableModules
     * @description Return an object that contains all modules organised into
     * the following attributes
     * - unallocated - all modules not allocated to a collection
     * - <collectionNam/No ce> - one attribute for each collection with all the modules for that collection
     *
     */
    	function getCollectionsTableModules() {
    		let modulesObj = {
    			unallocated: addUnallocatedModules($configStore["editMode"])
    		};

    		// loop through all of the COLLECTIONS_ORDER
    		// - create an attribute for that collection
    		// - add all the modules for that collection
    		$collectionsStore["COLLECTIONS_ORDER"].forEach(collectionName => {
    			modulesObj[collectionName] = getCollectionCanvasModules(collectionName);
    		});

    		return modulesObj;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (collection === undefined && !('collection' in $$props || $$self.$$.bound[$$self.$$.props['collection']])) {
    			console.warn("<CollectionsTable> was created without expected prop 'collection'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<CollectionsTable> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['collection', 'claytons'];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollectionsTable> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('collection' in $$props) $$invalidate(6, collection = $$props.collection);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		deLabelModuleName,
    		addUnallocatedModules,
    		getModuleUrl,
    		getCollectionCanvasModules,
    		collection,
    		claytons,
    		labelHeader,
    		modulesObj,
    		collectionsOrder,
    		getMostUsedLabel,
    		getCollectionsTableModules,
    		$collectionsStore,
    		$configStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collection' in $$props) $$invalidate(6, collection = $$props.collection);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    		if ('labelHeader' in $$props) $$invalidate(3, labelHeader = $$props.labelHeader);
    		if ('modulesObj' in $$props) $$invalidate(4, modulesObj = $$props.modulesObj);
    		if ('collectionsOrder' in $$props) $$invalidate(1, collectionsOrder = $$props.collectionsOrder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$collectionsStore, collectionsOrder*/ 6) {
    			{
    				// get object attributes set to collection names, including unallocated
    				$$invalidate(4, modulesObj = getCollectionsTableModules());

    				$$invalidate(1, collectionsOrder = ["unallocated"]);

    				// add all the unhidden collections to the order
    				$collectionsStore["COLLECTIONS_ORDER"].forEach(collectionName => {
    					if (!$collectionsStore["COLLECTIONS"][collectionName].hide) {
    						collectionsOrder.push(collectionName);
    					}
    				});

    				$$invalidate(3, labelHeader = getMostUsedLabel());
    			}
    		}
    	};

    	return [
    		claytons,
    		collectionsOrder,
    		$collectionsStore,
    		labelHeader,
    		modulesObj,
    		$configStore,
    		collection
    	];
    }

    class CollectionsTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { collection: 6, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionsTable",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get collection() {
    		throw new Error("<CollectionsTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<CollectionsTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error("<CollectionsTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error("<CollectionsTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // currently collectionStore will contain the parsed collections JSON
    // - COLLECTIONS - dict of dicts, keyed on module name, one per collection
    // - COLLECTIONS_ORDER - array of collection names in order to display
    // - DEFAULT_ACTIVE_COLLECTION
    // - MODULES - dict of dicts, keyed on module id
    // - VISIBILITY - string: no-one, students, staff, all
    const collectionsStore = writable({});
    // Array of Canvas module information in order of display
    const modulesStore = writable([]);
    // Object providing basic info about context
    // - courseId
    // - editMode
    const configStore = writable({});
    // List of available representations
    // TODO bit of a kludge for now
    const representationsStore = writable({
        "GriffithCards": GriffithCards, "CollectionOnly": CollectionOnly,
        "AssessmentTable": AssessmentTable,
        "CollectionsTable": CollectionsTable
    });

    /* src\components\Import\ImportModules.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1$3 } = globals;
    const file$a = "src\\components\\Import\\ImportModules.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    // (173:0) {#if numCurrentModules !== numImportModules}
    function create_if_block_7(ctx) {
    	let p;
    	let t1;
    	let ol;
    	let li0;
    	let t4;
    	let li1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Warning: the number of modules does not match:";
    			t1 = space();
    			ol = element("ol");
    			li0 = element("li");
    			li0.textContent = `# current modules: ${/*numCurrentModules*/ ctx[4]}`;
    			t4 = space();
    			li1 = element("li");
    			li1.textContent = `# import modules: ${/*numImportModules*/ ctx[5]}`;
    			add_location(p, file$a, 173, 2, 6107);
    			add_location(li0, file$a, 175, 4, 6174);
    			add_location(li1, file$a, 176, 4, 6227);
    			add_location(ol, file$a, 174, 2, 6164);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, ol, anchor);
    			append_dev(ol, li0);
    			append_dev(ol, t4);
    			append_dev(ol, li1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(ol);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(173:0) {#if numCurrentModules !== numImportModules}",
    		ctx
    	});

    	return block;
    }

    // (186:2) {:else}
    function create_else_block_2(ctx) {
    	let sl_tab;

    	const block = {
    		c: function create() {
    			sl_tab = element("sl-tab");
    			sl_tab.textContent = `Imported modules matched (n=${/*numImportsMatched*/ ctx[6]})`;
    			set_custom_element_data(sl_tab, "slot", "nav");
    			set_custom_element_data(sl_tab, "panel", "importedMatched");
    			add_location(sl_tab, file$a, 186, 4, 6468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tab, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(186:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (182:2) {#if numImportsMatched === 0}
    function create_if_block_6$1(ctx) {
    	let sl_tab;

    	const block = {
    		c: function create() {
    			sl_tab = element("sl-tab");
    			sl_tab.textContent = "Imported modules matched (n=0})";
    			set_custom_element_data(sl_tab, "slot", "nav");
    			set_custom_element_data(sl_tab, "panel", "importedMatched");
    			set_custom_element_data(sl_tab, "disabled", "");
    			add_location(sl_tab, file$a, 182, 4, 6345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tab, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(182:2) {#if numImportsMatched === 0}",
    		ctx
    	});

    	return block;
    }

    // (196:2) {:else}
    function create_else_block_1$1(ctx) {
    	let sl_tab;

    	const block = {
    		c: function create() {
    			sl_tab = element("sl-tab");
    			sl_tab.textContent = `Imported modules not matched (n=${/*importedModuleIds*/ ctx[8].length - /*numImportsMatched*/ ctx[6]})`;
    			set_custom_element_data(sl_tab, "slot", "nav");
    			set_custom_element_data(sl_tab, "panel", "importedNotMatched");
    			add_location(sl_tab, file$a, 196, 4, 6780);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tab, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(196:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (192:2) {#if numImportModules - numImportsMatched === 0}
    function create_if_block_5$1(ctx) {
    	let sl_tab;

    	const block = {
    		c: function create() {
    			sl_tab = element("sl-tab");
    			sl_tab.textContent = "Imported modules not matched (n=0)";
    			set_custom_element_data(sl_tab, "slot", "nav");
    			set_custom_element_data(sl_tab, "panel", "importedNotMatched");
    			set_custom_element_data(sl_tab, "disabled", "");
    			add_location(sl_tab, file$a, 192, 4, 6651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tab, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(192:2) {#if numImportModules - numImportsMatched === 0}",
    		ctx
    	});

    	return block;
    }

    // (207:2) {:else}
    function create_else_block$3(ctx) {
    	let sl_tab;

    	const block = {
    		c: function create() {
    			sl_tab = element("sl-tab");
    			sl_tab.textContent = `Current modules not matched (n=${currentModuleIds.length - /*numCurrentMatched*/ ctx[7]})`;
    			set_custom_element_data(sl_tab, "slot", "nav");
    			set_custom_element_data(sl_tab, "panel", "currentNotMatched");
    			add_location(sl_tab, file$a, 207, 4, 7114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tab, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(207:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (203:2) {#if numCurrentMatched !== 0}
    function create_if_block_4$1(ctx) {
    	let sl_tab;

    	const block = {
    		c: function create() {
    			sl_tab = element("sl-tab");
    			sl_tab.textContent = "Current modules not matched (n=0)";
    			set_custom_element_data(sl_tab, "slot", "nav");
    			set_custom_element_data(sl_tab, "panel", "currentNotMatched");
    			set_custom_element_data(sl_tab, "disabled", "");
    			add_location(sl_tab, file$a, 203, 4, 6987);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tab, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(203:2) {#if numCurrentMatched !== 0}",
    		ctx
    	});

    	return block;
    }

    // (215:4) {#if numImportsMatched > 0}
    function create_if_block_2$5(ctx) {
    	let table;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let each_value_2 = /*importedModuleIds*/ ctx[8];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Imported module";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Current Module";
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$a, 217, 10, 7418);
    			add_location(th1, file$a, 218, 10, 7454);
    			attr_dev(tr, "class", "svelte-13y8kz6");
    			add_location(tr, file$a, 216, 8, 7402);
    			attr_dev(table, "class", "cc-import-table svelte-13y8kz6");
    			add_location(table, file$a, 215, 6, 7361);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(table, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentCourseId, importModuleDetails, importedModuleIds, currentModules, importCourseId, collectionsDetails*/ 783) {
    				each_value_2 = /*importedModuleIds*/ ctx[8];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(215:4) {#if numImportsMatched > 0}",
    		ctx
    	});

    	return block;
    }

    // (222:10) {#if importModuleDetails[importedModuleId].matched}
    function create_if_block_3$2(ctx) {
    	let tr;
    	let td;
    	let a0;
    	let t0_value = /*collectionsDetails*/ ctx[2].collections.MODULES[/*importedModuleId*/ ctx[21]].name + "";
    	let t0;
    	let a0_href_value;
    	let t1;
    	let a1;
    	let t2_value = /*currentModules*/ ctx[3][/*importModuleDetails*/ ctx[9][/*importedModuleId*/ ctx[21]].currentModuleId].name + "";
    	let t2;
    	let a1_href_value;
    	let t3;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			a0 = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			a1 = element("a");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "href", a0_href_value = "/courses/" + /*importCourseId*/ ctx[1] + "/modules/#module_" + /*importedModuleId*/ ctx[21]);
    			add_location(a0, file$a, 224, 16, 7666);
    			attr_dev(td, "class", "svelte-13y8kz6");
    			add_location(td, file$a, 223, 14, 7644);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			attr_dev(a1, "href", a1_href_value = "/courses/" + /*currentCourseId*/ ctx[0] + "/modules/#module_" + /*importModuleDetails*/ ctx[9][/*importedModuleId*/ ctx[21]].currentModuleId);
    			add_location(a1, file$a, 232, 14, 7991);
    			attr_dev(tr, "class", "svelte-13y8kz6");
    			add_location(tr, file$a, 222, 12, 7624);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, a0);
    			append_dev(a0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, a1);
    			append_dev(a1, t2);
    			append_dev(tr, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*collectionsDetails*/ 4 && t0_value !== (t0_value = /*collectionsDetails*/ ctx[2].collections.MODULES[/*importedModuleId*/ ctx[21]].name + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*importCourseId*/ 2 && a0_href_value !== (a0_href_value = "/courses/" + /*importCourseId*/ ctx[1] + "/modules/#module_" + /*importedModuleId*/ ctx[21])) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*currentModules*/ 8 && t2_value !== (t2_value = /*currentModules*/ ctx[3][/*importModuleDetails*/ ctx[9][/*importedModuleId*/ ctx[21]].currentModuleId].name + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*currentCourseId*/ 1 && a1_href_value !== (a1_href_value = "/courses/" + /*currentCourseId*/ ctx[0] + "/modules/#module_" + /*importModuleDetails*/ ctx[9][/*importedModuleId*/ ctx[21]].currentModuleId)) {
    				attr_dev(a1, "href", a1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(222:10) {#if importModuleDetails[importedModuleId].matched}",
    		ctx
    	});

    	return block;
    }

    // (221:8) {#each importedModuleIds as importedModuleId}
    function create_each_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = /*importModuleDetails*/ ctx[9][/*importedModuleId*/ ctx[21]].matched && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*importModuleDetails*/ ctx[9][/*importedModuleId*/ ctx[21]].matched) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(221:8) {#each importedModuleIds as importedModuleId}",
    		ctx
    	});

    	return block;
    }

    // (250:6) {#if !module.matched}
    function create_if_block_1$6(ctx) {
    	let p;
    	let t_value = /*module*/ ctx[16].importedModuleId + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$a, 250, 8, 8594);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(250:6) {#if !module.matched}",
    		ctx
    	});

    	return block;
    }

    // (249:4) {#each Object.values(importModuleDetails) as module}
    function create_each_block_1(ctx) {
    	let if_block_anchor;
    	let if_block = !/*module*/ ctx[16].matched && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*module*/ ctx[16].matched) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(249:4) {#each Object.values(importModuleDetails) as module}",
    		ctx
    	});

    	return block;
    }

    // (257:6) {#if !module.matched}
    function create_if_block$7(ctx) {
    	let p;
    	let t_value = /*module*/ ctx[16].currentModuleId + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$a, 257, 8, 8812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(257:6) {#if !module.matched}",
    		ctx
    	});

    	return block;
    }

    // (256:4) {#each Object.values(currentModuleDetails) as module}
    function create_each_block$6(ctx) {
    	let if_block_anchor;
    	let if_block = !/*module*/ ctx[16].matched && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*module*/ ctx[16].matched) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(256:4) {#each Object.values(currentModuleDetails) as module}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let t0;
    	let sl_tab_group;
    	let t1;
    	let t2;
    	let t3;
    	let sl_tab_panel0;
    	let t4;
    	let sl_tab_panel1;
    	let t5;
    	let sl_tab_panel2;
    	let if_block0 = /*numCurrentModules*/ ctx[4] !== /*numImportModules*/ ctx[5] && create_if_block_7(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*numImportsMatched*/ ctx[6] === 0) return create_if_block_6$1;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*numImportModules*/ ctx[5] - /*numImportsMatched*/ ctx[6] === 0) return create_if_block_5$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block2 = current_block_type_1(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*numCurrentMatched*/ ctx[7] !== 0) return create_if_block_4$1;
    		return create_else_block$3;
    	}

    	let current_block_type_2 = select_block_type_2(ctx);
    	let if_block3 = current_block_type_2(ctx);
    	let if_block4 = /*numImportsMatched*/ ctx[6] > 0 && create_if_block_2$5(ctx);
    	let each_value_1 = Object.values(/*importModuleDetails*/ ctx[9]);
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = Object.values(/*currentModuleDetails*/ ctx[10]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			sl_tab_group = element("sl-tab-group");
    			if_block1.c();
    			t1 = space();
    			if_block2.c();
    			t2 = space();
    			if_block3.c();
    			t3 = space();
    			sl_tab_panel0 = element("sl-tab-panel");
    			if (if_block4) if_block4.c();
    			t4 = space();
    			sl_tab_panel1 = element("sl-tab-panel");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t5 = space();
    			sl_tab_panel2 = element("sl-tab-panel");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(sl_tab_panel0, "name", "importedMatched");
    			add_location(sl_tab_panel0, file$a, 213, 2, 7283);
    			set_custom_element_data(sl_tab_panel1, "name", "importedNotMatched");
    			add_location(sl_tab_panel1, file$a, 247, 2, 8457);
    			set_custom_element_data(sl_tab_panel2, "name", "currentNotMatched");
    			add_location(sl_tab_panel2, file$a, 254, 2, 8675);
    			add_location(sl_tab_group, file$a, 180, 0, 6292);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, sl_tab_group, anchor);
    			if_block1.m(sl_tab_group, null);
    			append_dev(sl_tab_group, t1);
    			if_block2.m(sl_tab_group, null);
    			append_dev(sl_tab_group, t2);
    			if_block3.m(sl_tab_group, null);
    			append_dev(sl_tab_group, t3);
    			append_dev(sl_tab_group, sl_tab_panel0);
    			if (if_block4) if_block4.m(sl_tab_panel0, null);
    			append_dev(sl_tab_group, t4);
    			append_dev(sl_tab_group, sl_tab_panel1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(sl_tab_panel1, null);
    			}

    			append_dev(sl_tab_group, t5);
    			append_dev(sl_tab_group, sl_tab_panel2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(sl_tab_panel2, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*numCurrentModules*/ ctx[4] !== /*numImportModules*/ ctx[5]) if_block0.p(ctx, dirty);
    			if_block1.p(ctx, dirty);
    			if_block2.p(ctx, dirty);
    			if_block3.p(ctx, dirty);
    			if (/*numImportsMatched*/ ctx[6] > 0) if_block4.p(ctx, dirty);

    			if (dirty & /*Object, importModuleDetails*/ 512) {
    				each_value_1 = Object.values(/*importModuleDetails*/ ctx[9]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(sl_tab_panel1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*Object, currentModuleDetails*/ 1024) {
    				each_value = Object.values(/*currentModuleDetails*/ ctx[10]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(sl_tab_panel2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(sl_tab_group);
    			if_block1.d();
    			if_block2.d();
    			if_block3.d();
    			if (if_block4) if_block4.d();
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $modulesStore;
    	validate_store(modulesStore, 'modulesStore');
    	component_subscribe($$self, modulesStore, $$value => $$invalidate(12, $modulesStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImportModules', slots, []);
    	let { modulesCompleteStatus = false } = $$props;
    	let { currentCourseId = null } = $$props;
    	let { importCourseId = null } = $$props;
    	let { collectionsDetails = null } = $$props;

    	// create hash currentModules keyed on moduleIds with value from modulesStore
    	let currentModules = {};

    	$modulesStore.forEach(module => {
    		$$invalidate(3, currentModules[module.id] = module, currentModules);
    	});

    	// get lists of both moduleIds
    	//  let importedModuleIds = Object.keys(collectionsDetails.collections.MODULES);
    	//  let currentModuleIds = Object.keys(currentModules);
    	//  let currentModuleDetails = {};
    	//  let importModuleDetails = {};
    	//  [currentModuleDetails, importModuleDetails] = initialiseModules();
    	//collectionsDetails.initialiseModules($modulesStore)
    	//matchModuleNames();
    	collectionsDetails.initialiseModules($modulesStore);

    	collectionsDetails.matchModuleNames($modulesStore);

    	//let numCurrentModules = Object.keys(currentModuleDetails).length;
    	let numCurrentModules = collectionsDetails.getNumCurrentModules();

    	//let numImportModules = Object.keys(importModuleDetails).length;
    	let numImportModules = collectionsDetails.getNumImportedModules();

    	// calculate numImportsMatched as number of importModuleDetails where matched is true
    	/*let numImportsMatched = Object.keys(importModuleDetails).reduce(
      (acc, key) => {
        if (importModuleDetails[key].matched) {
          return acc + 1;
        } else {
          return acc;
        }
      },
      0
    );
    // calculate numCurrentMatched as number of currentModuleDetails where matched is true
    let numCurrentMatched = Object.keys(currentModuleDetails).reduce(
      (acc, key) => {
        if (currentModuleDetails[key].matched) {
          return acc + 1;
        } else {
          return acc;
        }
      },
      0
    ); */
    	let numImportsMatched = collectionsDetails.getNumImportsMatched();

    	let numCurrentMatched = collectionsDetails.getNumCurrentMatched();
    	const importedModuleIds = collectionsDetails.getImportedModuleIds();
    	const importModuleDetails = collectionsDetails.getImportModuleDetails();
    	const currentModuleDetails = collectionsDetails.getCurrentModuleDetails();

    	let disabledImportsMatched = numImportsMatched === collectionsDetails.getNumImportedModules()
    	? "disabled"
    	: "";

    	//    numImportsMatched === numImportModules ? "disabled" : "";
    	let disabledImportNotMatched = collectionsDetails.getNumImportedModules() - numImportsMatched === 0
    	? "disabled"
    	: "";

    	//    numImportModules - numImportsMatched === 0 ? "disabled" : "";
    	let disabledCurrentNotMatched = numCurrentMatched - collectionsDetails.getNumCurrentMatched() === 0
    	? "disabled"
    	: "";

    	//    numCurrentMatched === numCurrentModules ? "disabled" : "";
    	/**
     * Figure out the moduleCompleteStatus
     * - ok - if all imports matched and there no imports not matched and no current not matched
     * - importProblem - if there are some imports not matched`
     */
    	if (!disabledImportsMatched && disabledImportNotMatched && disableCurrentNotMatched) {
    		modulesCompleteStatus = true;
    	}

    	modulesCompleteStatus = true;

    	const writable_props = [
    		'modulesCompleteStatus',
    		'currentCourseId',
    		'importCourseId',
    		'collectionsDetails'
    	];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportModules> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('modulesCompleteStatus' in $$props) $$invalidate(11, modulesCompleteStatus = $$props.modulesCompleteStatus);
    		if ('currentCourseId' in $$props) $$invalidate(0, currentCourseId = $$props.currentCourseId);
    		if ('importCourseId' in $$props) $$invalidate(1, importCourseId = $$props.importCourseId);
    		if ('collectionsDetails' in $$props) $$invalidate(2, collectionsDetails = $$props.collectionsDetails);
    	};

    	$$self.$capture_state = () => ({
    		modulesStore,
    		modulesCompleteStatus,
    		currentCourseId,
    		importCourseId,
    		collectionsDetails,
    		currentModules,
    		numCurrentModules,
    		numImportModules,
    		numImportsMatched,
    		numCurrentMatched,
    		importedModuleIds,
    		importModuleDetails,
    		currentModuleDetails,
    		disabledImportsMatched,
    		disabledImportNotMatched,
    		disabledCurrentNotMatched,
    		$modulesStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('modulesCompleteStatus' in $$props) $$invalidate(11, modulesCompleteStatus = $$props.modulesCompleteStatus);
    		if ('currentCourseId' in $$props) $$invalidate(0, currentCourseId = $$props.currentCourseId);
    		if ('importCourseId' in $$props) $$invalidate(1, importCourseId = $$props.importCourseId);
    		if ('collectionsDetails' in $$props) $$invalidate(2, collectionsDetails = $$props.collectionsDetails);
    		if ('currentModules' in $$props) $$invalidate(3, currentModules = $$props.currentModules);
    		if ('numCurrentModules' in $$props) $$invalidate(4, numCurrentModules = $$props.numCurrentModules);
    		if ('numImportModules' in $$props) $$invalidate(5, numImportModules = $$props.numImportModules);
    		if ('numImportsMatched' in $$props) $$invalidate(6, numImportsMatched = $$props.numImportsMatched);
    		if ('numCurrentMatched' in $$props) $$invalidate(7, numCurrentMatched = $$props.numCurrentMatched);
    		if ('disabledImportsMatched' in $$props) disabledImportsMatched = $$props.disabledImportsMatched;
    		if ('disabledImportNotMatched' in $$props) disabledImportNotMatched = $$props.disabledImportNotMatched;
    		if ('disabledCurrentNotMatched' in $$props) disabledCurrentNotMatched = $$props.disabledCurrentNotMatched;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		currentCourseId,
    		importCourseId,
    		collectionsDetails,
    		currentModules,
    		numCurrentModules,
    		numImportModules,
    		numImportsMatched,
    		numCurrentMatched,
    		importedModuleIds,
    		importModuleDetails,
    		currentModuleDetails,
    		modulesCompleteStatus
    	];
    }

    class ImportModules extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			modulesCompleteStatus: 11,
    			currentCourseId: 0,
    			importCourseId: 1,
    			collectionsDetails: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImportModules",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get modulesCompleteStatus() {
    		throw new Error("<ImportModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modulesCompleteStatus(value) {
    		throw new Error("<ImportModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentCourseId() {
    		throw new Error("<ImportModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentCourseId(value) {
    		throw new Error("<ImportModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get importCourseId() {
    		throw new Error("<ImportModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set importCourseId(value) {
    		throw new Error("<ImportModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collectionsDetails() {
    		throw new Error("<ImportModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collectionsDetails(value) {
    		throw new Error("<ImportModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Import\ImportImages.svelte generated by Svelte v3.55.0 */
    const file$9 = "src\\components\\Import\\ImportImages.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (105:2) {:else}
    function create_else_block$2(ctx) {
    	let each_1_anchor;
    	let each_value = /*images*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*images*/ 2) {
    				each_value = /*images*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(105:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (99:2) {#if !imageDataGenerated}
    function create_if_block$6(ctx) {
    	let tr;
    	let td;
    	let sl_spinner;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			sl_spinner = element("sl-spinner");
    			set_custom_element_data(sl_spinner, "class", "svelte-c3wo7j");
    			add_location(sl_spinner, file$9, 101, 8, 3053);
    			attr_dev(td, "colspan", "5");
    			attr_dev(td, "class", "svelte-c3wo7j");
    			add_location(td, file$9, 100, 6, 3027);
    			attr_dev(tr, "class", "svelte-c3wo7j");
    			add_location(tr, file$9, 99, 4, 3015);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, sl_spinner);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(99:2) {#if !imageDataGenerated}",
    		ctx
    	});

    	return block;
    }

    // (108:8) {#if image.courseImage}
    function create_if_block_2$4(ctx) {
    	let td;
    	let sl_icon;

    	const block = {
    		c: function create() {
    			td = element("td");
    			sl_icon = element("sl-icon");
    			set_custom_element_data(sl_icon, "name", "check-circle");
    			add_location(sl_icon, file$9, 109, 12, 3225);
    			attr_dev(td, "class", "cc-success svelte-c3wo7j");
    			add_location(td, file$9, 108, 10, 3188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, sl_icon);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(108:8) {#if image.courseImage}",
    		ctx
    	});

    	return block;
    }

    // (113:8) {#if image.otherCourse}
    function create_if_block_1$5(ctx) {
    	let td;
    	let sl_icon;
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			sl_icon = element("sl-icon");
    			t = text(" Other course");
    			set_custom_element_data(sl_icon, "name", "exclamation-triangle");
    			add_location(sl_icon, file$9, 114, 12, 3368);
    			attr_dev(td, "class", "cc-error svelte-c3wo7j");
    			add_location(td, file$9, 113, 10, 3333);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, sl_icon);
    			append_dev(td, t);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(113:8) {#if image.otherCourse}",
    		ctx
    	});

    	return block;
    }

    // (106:4) {#each images as image}
    function create_each_block$5(ctx) {
    	let tr;
    	let t0;
    	let t1;
    	let td0;
    	let t2_value = /*image*/ ctx[10].moduleName + "";
    	let t2;
    	let t3;
    	let td1;
    	let a;
    	let t4_value = /*image*/ ctx[10].display_name + "";
    	let t4;
    	let t5;
    	let td2;
    	let t6_value = /*image*/ ctx[10].size + "";
    	let t6;
    	let t7;
    	let td3;
    	let t8_value = /*image*/ ctx[10]["content-type"] + "";
    	let t8;
    	let t9;
    	let if_block0 = /*image*/ ctx[10].courseImage && create_if_block_2$4(ctx);
    	let if_block1 = /*image*/ ctx[10].otherCourse && create_if_block_1$5(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			td0 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td1 = element("td");
    			a = element("a");
    			t4 = text(t4_value);
    			t5 = space();
    			td2 = element("td");
    			t6 = text(t6_value);
    			t7 = space();
    			td3 = element("td");
    			t8 = text(t8_value);
    			t9 = space();
    			attr_dev(td0, "class", "svelte-c3wo7j");
    			add_location(td0, file$9, 117, 8, 3462);
    			attr_dev(a, "href", /*image*/ ctx[10].src);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			add_location(a, file$9, 121, 10, 3537);
    			attr_dev(td1, "class", "svelte-c3wo7j");
    			add_location(td1, file$9, 120, 8, 3521);
    			attr_dev(td2, "class", "svelte-c3wo7j");
    			add_location(td2, file$9, 125, 8, 3665);
    			attr_dev(td3, "class", "svelte-c3wo7j");
    			add_location(td3, file$9, 126, 8, 3697);
    			attr_dev(tr, "class", "svelte-c3wo7j");
    			add_location(tr, file$9, 106, 6, 3139);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			if (if_block0) if_block0.m(tr, null);
    			append_dev(tr, t0);
    			if (if_block1) if_block1.m(tr, null);
    			append_dev(tr, t1);
    			append_dev(tr, td0);
    			append_dev(td0, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td1);
    			append_dev(td1, a);
    			append_dev(a, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td2);
    			append_dev(td2, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td3);
    			append_dev(td3, t8);
    			append_dev(tr, t9);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(106:4) {#each images as image}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let table;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;

    	function select_block_type(ctx, dirty) {
    		if (!/*imageDataGenerated*/ ctx[0]) return create_if_block$6;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Status";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Module Name";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Image";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Size";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Type";
    			t9 = space();
    			if_block.c();
    			add_location(th0, file$9, 92, 4, 2872);
    			add_location(th1, file$9, 93, 4, 2893);
    			add_location(th2, file$9, 94, 4, 2919);
    			add_location(th3, file$9, 95, 4, 2939);
    			add_location(th4, file$9, 96, 4, 2958);
    			attr_dev(tr, "class", "svelte-c3wo7j");
    			add_location(tr, file$9, 91, 2, 2862);
    			attr_dev(table, "class", "cc-import-table svelte-c3wo7j");
    			add_location(table, file$9, 90, 0, 2827);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(table, t9);
    			if_block.m(table, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(table, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImportImages', slots, []);
    	let { imagesCompleteStatus = false } = $$props;
    	let { currentCourseId } = $$props;
    	let { importCourseId } = $$props;
    	let { collectionsDetails } = $$props;
    	let imageDataGenerated = false;
    	let numImagesReceived = 0;
    	const currentHostName = document.location.hostname;
    	const baseApiUrl = `https://${currentHostName}/api/v1`;
    	let images = collectionsDetails.getImportedImages(); //convertCourseImages(courseImages);
    	checkImagesExist();

    	/**
     * @function checkImagesExist
     * @description perform various checks on courseImages and update in response
     *     { courseImage : boolean - is it a local course image
     *       found: boolean,
     *        otherCourse: null / int,
     *        content-type: string,
     *        size
     *  }
     * - loop through each image
     * - check that the URL contains a courseId matching the current course
     * - attempt to retrieve the file, test that exists and update the content-type
     *   and maybe file size
     */
    	function checkImagesExist() {
    		images.forEach(image => {
    			image.otherCourse = null;
    			let url = image.src;

    			// url should be in the format
    			//  https://<hostname>/courses/<courseId>/files/<fileId>/download
    			const regex = new RegExp(`${currentHostName}\/courses\/([0-9]+)\/files\/([0-9]+)\/`);

    			let matches = url.match(regex);

    			if (matches) {
    				// we've got a local Canvas course image
    				const urlCourseId = matches[1];

    				image.fileId = matches[2];
    				image["courseImage"] = true;

    				if (urlCourseId !== currentCourseId) {
    					// it's not the current course
    					image["otherCourse"] = parseInt(urlCourseId);
    				} else {
    					// it is the current course, so we can try to retrieve it
    					wf_fetchData(`${baseApiUrl}/courses/${currentCourseId}/files/${image.fileId}`).then(msg => {
    						if (msg.status === 200) {
    							["size", "content-type", "display_name"].forEach(key => {
    								image[key] = msg.body[key];
    							});

    							image.details = true;
    						}

    						$$invalidate(6, numImagesReceived++, numImagesReceived);
    					});
    				}
    			} else {
    				image["courseImage"] = false;
    			}
    		});
    	}

    	$$self.$$.on_mount.push(function () {
    		if (currentCourseId === undefined && !('currentCourseId' in $$props || $$self.$$.bound[$$self.$$.props['currentCourseId']])) {
    			console.warn("<ImportImages> was created without expected prop 'currentCourseId'");
    		}

    		if (importCourseId === undefined && !('importCourseId' in $$props || $$self.$$.bound[$$self.$$.props['importCourseId']])) {
    			console.warn("<ImportImages> was created without expected prop 'importCourseId'");
    		}

    		if (collectionsDetails === undefined && !('collectionsDetails' in $$props || $$self.$$.bound[$$self.$$.props['collectionsDetails']])) {
    			console.warn("<ImportImages> was created without expected prop 'collectionsDetails'");
    		}
    	});

    	const writable_props = [
    		'imagesCompleteStatus',
    		'currentCourseId',
    		'importCourseId',
    		'collectionsDetails'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportImages> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('imagesCompleteStatus' in $$props) $$invalidate(2, imagesCompleteStatus = $$props.imagesCompleteStatus);
    		if ('currentCourseId' in $$props) $$invalidate(3, currentCourseId = $$props.currentCourseId);
    		if ('importCourseId' in $$props) $$invalidate(4, importCourseId = $$props.importCourseId);
    		if ('collectionsDetails' in $$props) $$invalidate(5, collectionsDetails = $$props.collectionsDetails);
    	};

    	$$self.$capture_state = () => ({
    		modulesStore,
    		wf_fetchData,
    		imagesCompleteStatus,
    		currentCourseId,
    		importCourseId,
    		collectionsDetails,
    		imageDataGenerated,
    		numImagesReceived,
    		currentHostName,
    		baseApiUrl,
    		images,
    		checkImagesExist
    	});

    	$$self.$inject_state = $$props => {
    		if ('imagesCompleteStatus' in $$props) $$invalidate(2, imagesCompleteStatus = $$props.imagesCompleteStatus);
    		if ('currentCourseId' in $$props) $$invalidate(3, currentCourseId = $$props.currentCourseId);
    		if ('importCourseId' in $$props) $$invalidate(4, importCourseId = $$props.importCourseId);
    		if ('collectionsDetails' in $$props) $$invalidate(5, collectionsDetails = $$props.collectionsDetails);
    		if ('imageDataGenerated' in $$props) $$invalidate(0, imageDataGenerated = $$props.imageDataGenerated);
    		if ('numImagesReceived' in $$props) $$invalidate(6, numImagesReceived = $$props.numImagesReceived);
    		if ('images' in $$props) $$invalidate(1, images = $$props.images);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*numImagesReceived, imageDataGenerated*/ 65) {
    			{
    				$$invalidate(0, imageDataGenerated = numImagesReceived === images.length);

    				if (imageDataGenerated) {
    					$$invalidate(2, imagesCompleteStatus = true);
    				}
    			}
    		}
    	};

    	return [
    		imageDataGenerated,
    		images,
    		imagesCompleteStatus,
    		currentCourseId,
    		importCourseId,
    		collectionsDetails,
    		numImagesReceived
    	];
    }

    class ImportImages extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			imagesCompleteStatus: 2,
    			currentCourseId: 3,
    			importCourseId: 4,
    			collectionsDetails: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImportImages",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get imagesCompleteStatus() {
    		throw new Error("<ImportImages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imagesCompleteStatus(value) {
    		throw new Error("<ImportImages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentCourseId() {
    		throw new Error("<ImportImages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentCourseId(value) {
    		throw new Error("<ImportImages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get importCourseId() {
    		throw new Error("<ImportImages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set importCourseId(value) {
    		throw new Error("<ImportImages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collectionsDetails() {
    		throw new Error("<ImportImages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collectionsDetails(value) {
    		throw new Error("<ImportImages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\ProcessImportedCollections.svelte generated by Svelte v3.55.0 */
    const file$8 = "src\\components\\ProcessImportedCollections.svelte";

    // (115:8) {:else}
    function create_else_block_1(ctx) {
    	let sl_spinner;

    	const block = {
    		c: function create() {
    			sl_spinner = element("sl-spinner");
    			add_location(sl_spinner, file$8, 115, 10, 4432);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_spinner, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_spinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(115:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (113:8) {#if modulesCompleteStatus}
    function create_if_block_2$3(ctx) {
    	let sl_badge;

    	const block = {
    		c: function create() {
    			sl_badge = element("sl-badge");
    			sl_badge.textContent = "Ok";
    			set_custom_element_data(sl_badge, "variant", "success");
    			add_location(sl_badge, file$8, 113, 10, 4362);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_badge, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_badge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(113:8) {#if modulesCompleteStatus}",
    		ctx
    	});

    	return block;
    }

    // (129:8) {:else}
    function create_else_block$1(ctx) {
    	let sl_spinner;

    	const block = {
    		c: function create() {
    			sl_spinner = element("sl-spinner");
    			add_location(sl_spinner, file$8, 129, 10, 4921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_spinner, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_spinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(129:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (127:8) {#if imagesCompleteStatus}
    function create_if_block_1$4(ctx) {
    	let sl_badge;

    	const block = {
    		c: function create() {
    			sl_badge = element("sl-badge");
    			sl_badge.textContent = "Ok";
    			set_custom_element_data(sl_badge, "variant", "success");
    			add_location(sl_badge, file$8, 127, 10, 4851);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_badge, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_badge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(127:8) {#if imagesCompleteStatus}",
    		ctx
    	});

    	return block;
    }

    // (143:12) {#if importCourseDetails}
    function create_if_block$5(ctx) {
    	let t0;
    	let a;
    	let t1_value = /*importCourseDetails*/ ctx[3].course_code + "";
    	let t1;
    	let t2;
    	let t3_value = /*importCourseDetails*/ ctx[3].name + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			t0 = text("(\r\n              ");
    			a = element("a");
    			t1 = text(t1_value);
    			t2 = text(" - ");
    			t3 = text(t3_value);
    			t4 = text("\r\n              )\r\n            ");
    			attr_dev(a, "href", "/courses/" + /*importCourseId*/ ctx[5] + "/");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			add_location(a, file$8, 144, 14, 5399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a, anchor);
    			append_dev(a, t1);
    			append_dev(a, t2);
    			append_dev(a, t3);
    			insert_dev(target, t4, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*importCourseDetails*/ 8 && t1_value !== (t1_value = /*importCourseDetails*/ ctx[3].course_code + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*importCourseDetails*/ 8 && t3_value !== (t3_value = /*importCourseDetails*/ ctx[3].name + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(143:12) {#if importCourseDetails}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let sl_dialog;
    	let div8;
    	let sl_tab_group;
    	let sl_tab0;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[7].summary.tooltip + "";
    	let t0;
    	let a0;
    	let i0;
    	let t1;
    	let t2;
    	let sl_tab1;
    	let sl_tooltip1;
    	let div1;
    	let raw1_value = /*HELP*/ ctx[7].modules.tooltip + "";
    	let t3;
    	let a1;
    	let i1;
    	let t4;
    	let t5;
    	let sl_tab2;
    	let sl_tooltip2;
    	let div2;
    	let raw2_value = /*HELP*/ ctx[7].images.tooltip + "";
    	let t6;
    	let a2;
    	let i2;
    	let t7;
    	let t8;
    	let sl_tab_panel0;
    	let div7;
    	let p0;
    	let a3;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let ul;
    	let li0;
    	let sl_tooltip3;
    	let div3;
    	let raw3_value = /*HELP*/ ctx[7].proceed.tooltip + "";
    	let t13;
    	let a4;
    	let i3;
    	let t14;
    	let t15;
    	let li1;
    	let sl_tooltip4;
    	let div4;
    	let raw4_value = /*HELP*/ ctx[7].cancel.tooltip + "";
    	let t16;
    	let a5;
    	let i4;
    	let t17;
    	let t18;
    	let li2;
    	let sl_tooltip5;
    	let div5;
    	let raw5_value = /*HELP*/ ctx[7].refresh.tooltip + "";
    	let t19;
    	let a6;
    	let i5;
    	let t20;
    	let t21;
    	let div6;
    	let sl_button0;
    	let t23;
    	let sl_button1;
    	let t25;
    	let sl_button2;
    	let t27;
    	let p1;
    	let t28;
    	let sl_tab_panel1;
    	let importmodules;
    	let updating_modulesCompleteStatus;
    	let t29;
    	let sl_tab_panel2;
    	let importimages;
    	let updating_imagesCompleteStatus;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*modulesCompleteStatus*/ ctx[1]) return create_if_block_2$3;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*imagesCompleteStatus*/ ctx[2]) return create_if_block_1$4;
    		return create_else_block$1;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);
    	let if_block2 = /*importCourseDetails*/ ctx[3] && create_if_block$5(ctx);

    	function importmodules_modulesCompleteStatus_binding(value) {
    		/*importmodules_modulesCompleteStatus_binding*/ ctx[14](value);
    	}

    	let importmodules_props = {
    		currentCourseId: /*currentCourseId*/ ctx[4],
    		importCourseId: /*importCourseId*/ ctx[5],
    		collectionsDetails: /*collectionsDetails*/ ctx[0]
    	};

    	if (/*modulesCompleteStatus*/ ctx[1] !== void 0) {
    		importmodules_props.modulesCompleteStatus = /*modulesCompleteStatus*/ ctx[1];
    	}

    	importmodules = new ImportModules({
    			props: importmodules_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(importmodules, 'modulesCompleteStatus', importmodules_modulesCompleteStatus_binding, /*modulesCompleteStatus*/ ctx[1]));

    	function importimages_imagesCompleteStatus_binding(value) {
    		/*importimages_imagesCompleteStatus_binding*/ ctx[15](value);
    	}

    	let importimages_props = {
    		currentCourseId: /*currentCourseId*/ ctx[4],
    		importCourseId: /*importCourseId*/ ctx[5],
    		collectionsDetails: /*collectionsDetails*/ ctx[0]
    	};

    	if (/*imagesCompleteStatus*/ ctx[2] !== void 0) {
    		importimages_props.imagesCompleteStatus = /*imagesCompleteStatus*/ ctx[2];
    	}

    	importimages = new ImportImages({
    			props: importimages_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(importimages, 'imagesCompleteStatus', importimages_imagesCompleteStatus_binding, /*imagesCompleteStatus*/ ctx[2]));

    	const block = {
    		c: function create() {
    			sl_dialog = element("sl-dialog");
    			div8 = element("div");
    			sl_tab_group = element("sl-tab-group");
    			sl_tab0 = element("sl-tab");
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t0 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t1 = text("  Summary");
    			t2 = space();
    			sl_tab1 = element("sl-tab");
    			sl_tooltip1 = element("sl-tooltip");
    			div1 = element("div");
    			t3 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t4 = text("\r\n         Modules \r\n        ");
    			if_block0.c();
    			t5 = space();
    			sl_tab2 = element("sl-tab");
    			sl_tooltip2 = element("sl-tooltip");
    			div2 = element("div");
    			t6 = space();
    			a2 = element("a");
    			i2 = element("i");
    			t7 = text("\r\n         Images \r\n        ");
    			if_block1.c();
    			t8 = space();
    			sl_tab_panel0 = element("sl-tab-panel");
    			div7 = element("div");
    			p0 = element("p");
    			a3 = element("a");
    			t9 = text("Collections configuration page");
    			t10 = text("\r\n            has been imported from another course\r\n            ");
    			if (if_block2) if_block2.c();
    			t11 = text(". Check the status and details here and choose whether to");
    			t12 = space();
    			ul = element("ul");
    			li0 = element("li");
    			sl_tooltip3 = element("sl-tooltip");
    			div3 = element("div");
    			t13 = space();
    			a4 = element("a");
    			i3 = element("i");
    			t14 = text("\r\n               Proceed");
    			t15 = space();
    			li1 = element("li");
    			sl_tooltip4 = element("sl-tooltip");
    			div4 = element("div");
    			t16 = space();
    			a5 = element("a");
    			i4 = element("i");
    			t17 = text("\r\n               Cancel");
    			t18 = space();
    			li2 = element("li");
    			sl_tooltip5 = element("sl-tooltip");
    			div5 = element("div");
    			t19 = space();
    			a6 = element("a");
    			i5 = element("i");
    			t20 = text("\r\n               Refresh");
    			t21 = space();
    			div6 = element("div");
    			sl_button0 = element("sl-button");
    			sl_button0.textContent = "Proceed";
    			t23 = space();
    			sl_button1 = element("sl-button");
    			sl_button1.textContent = "Cancel";
    			t25 = space();
    			sl_button2 = element("sl-button");
    			sl_button2.textContent = "Refresh";
    			t27 = space();
    			p1 = element("p");
    			t28 = space();
    			sl_tab_panel1 = element("sl-tab-panel");
    			create_component(importmodules.$$.fragment);
    			t29 = space();
    			sl_tab_panel2 = element("sl-tab-panel");
    			create_component(importimages.$$.fragment);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$8, 98, 10, 3731);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$8, 100, 13, 3871);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "href", /*HELP*/ ctx[7].summary.url);
    			add_location(a0, file$8, 99, 10, 3797);
    			add_location(sl_tooltip0, file$8, 97, 8, 3707);
    			set_custom_element_data(sl_tab0, "slot", "nav");
    			set_custom_element_data(sl_tab0, "panel", "summary");
    			add_location(sl_tab0, file$8, 96, 6, 3662);
    			attr_dev(div1, "slot", "content");
    			add_location(div1, file$8, 106, 10, 4061);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$8, 108, 13, 4201);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			attr_dev(a1, "href", /*HELP*/ ctx[7].modules.url);
    			add_location(a1, file$8, 107, 10, 4127);
    			add_location(sl_tooltip1, file$8, 105, 8, 4037);
    			set_custom_element_data(sl_tab1, "slot", "nav");
    			set_custom_element_data(sl_tab1, "panel", "modules");
    			add_location(sl_tab1, file$8, 104, 6, 3992);
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$8, 120, 10, 4554);
    			attr_dev(i2, "class", "icon-question cc-module-icon");
    			add_location(i2, file$8, 122, 13, 4692);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noreferrer");
    			attr_dev(a2, "href", /*HELP*/ ctx[7].images.url);
    			add_location(a2, file$8, 121, 10, 4619);
    			add_location(sl_tooltip2, file$8, 119, 8, 4530);
    			set_custom_element_data(sl_tab2, "slot", "nav");
    			set_custom_element_data(sl_tab2, "panel", "images");
    			add_location(sl_tab2, file$8, 118, 6, 4486);
    			attr_dev(a3, "href", "/courses/" + /*currentCourseId*/ ctx[4] + "/pages/canvas-collections-configuration");
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "rel", "noreferrer");
    			add_location(a3, file$8, 136, 12, 5074);
    			add_location(p0, file$8, 135, 10, 5057);
    			attr_dev(div3, "slot", "content");
    			add_location(div3, file$8, 157, 16, 5852);
    			attr_dev(i3, "class", "icon-question cc-module-icon");
    			add_location(i3, file$8, 159, 19, 6004);
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "rel", "noreferrer");
    			attr_dev(a4, "href", /*HELP*/ ctx[7].proceed.url);
    			add_location(a4, file$8, 158, 16, 5924);
    			add_location(sl_tooltip3, file$8, 156, 14, 5822);
    			attr_dev(li0, "class", "svelte-15b5l4i");
    			add_location(li0, file$8, 155, 12, 5802);
    			attr_dev(div4, "slot", "content");
    			add_location(div4, file$8, 166, 16, 6210);
    			attr_dev(i4, "class", "icon-question cc-module-icon");
    			add_location(i4, file$8, 168, 19, 6360);
    			attr_dev(a5, "target", "_blank");
    			attr_dev(a5, "rel", "noreferrer");
    			attr_dev(a5, "href", /*HELP*/ ctx[7].cancel.url);
    			add_location(a5, file$8, 167, 16, 6281);
    			add_location(sl_tooltip4, file$8, 165, 14, 6180);
    			attr_dev(li1, "class", "svelte-15b5l4i");
    			add_location(li1, file$8, 164, 12, 6160);
    			attr_dev(div5, "slot", "content");
    			add_location(div5, file$8, 175, 16, 6565);
    			attr_dev(i5, "class", "icon-question cc-module-icon");
    			add_location(i5, file$8, 177, 19, 6717);
    			attr_dev(a6, "target", "_blank");
    			attr_dev(a6, "rel", "noreferrer");
    			attr_dev(a6, "href", /*HELP*/ ctx[7].refresh.url);
    			add_location(a6, file$8, 176, 16, 6637);
    			add_location(sl_tooltip5, file$8, 174, 14, 6535);
    			attr_dev(li2, "class", "svelte-15b5l4i");
    			add_location(li2, file$8, 173, 12, 6515);
    			attr_dev(ul, "class", "cc-horizontal-list svelte-15b5l4i");
    			add_location(ul, file$8, 154, 10, 5757);
    			set_custom_element_data(sl_button0, "slot", "footer");
    			set_custom_element_data(sl_button0, "variant", "success");
    			set_custom_element_data(sl_button0, "type", "submit");
    			add_location(sl_button0, file$8, 186, 12, 6929);
    			set_custom_element_data(sl_button1, "slot", "footer");
    			set_custom_element_data(sl_button1, "variant", "warning");
    			set_custom_element_data(sl_button1, "type", "submit");
    			add_location(sl_button1, file$8, 193, 12, 7194);
    			set_custom_element_data(sl_button2, "slot", "footer");
    			set_custom_element_data(sl_button2, "variant", "danger");
    			set_custom_element_data(sl_button2, "type", "submit");
    			add_location(sl_button2, file$8, 200, 12, 7456);
    			attr_dev(div6, "class", "cc-footer svelte-15b5l4i");
    			add_location(div6, file$8, 185, 10, 6892);
    			attr_dev(div7, "class", "cc-import-intro svelte-15b5l4i");
    			add_location(div7, file$8, 134, 8, 5016);
    			add_location(p1, file$8, 210, 8, 7752);
    			set_custom_element_data(sl_tab_panel0, "name", "summary");
    			add_location(sl_tab_panel0, file$8, 133, 6, 4977);
    			set_custom_element_data(sl_tab_panel1, "name", "modules");
    			add_location(sl_tab_panel1, file$8, 212, 6, 7788);
    			set_custom_element_data(sl_tab_panel2, "name", "images");
    			add_location(sl_tab_panel2, file$8, 220, 6, 8011);
    			set_custom_element_data(sl_tab_group, "placement", "start");
    			add_location(sl_tab_group, file$8, 95, 4, 3622);
    			attr_dev(div8, "class", "cc-process-import svelte-15b5l4i");
    			add_location(div8, file$8, 94, 2, 3585);
    			set_custom_element_data(sl_dialog, "class", "cc-dialog svelte-15b5l4i");
    			set_style(sl_dialog, "--width", "75vw");
    			set_custom_element_data(sl_dialog, "label", "How to proceed with the import of Canvas Collections configuration?");
    			set_custom_element_data(sl_dialog, "open", "");
    			add_location(sl_dialog, file$8, 88, 0, 3435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_dialog, anchor);
    			append_dev(sl_dialog, div8);
    			append_dev(div8, sl_tab_group);
    			append_dev(sl_tab_group, sl_tab0);
    			append_dev(sl_tab0, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t0);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			append_dev(sl_tab0, t1);
    			append_dev(sl_tab_group, t2);
    			append_dev(sl_tab_group, sl_tab1);
    			append_dev(sl_tab1, sl_tooltip1);
    			append_dev(sl_tooltip1, div1);
    			div1.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t3);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(sl_tab1, t4);
    			if_block0.m(sl_tab1, null);
    			append_dev(sl_tab_group, t5);
    			append_dev(sl_tab_group, sl_tab2);
    			append_dev(sl_tab2, sl_tooltip2);
    			append_dev(sl_tooltip2, div2);
    			div2.innerHTML = raw2_value;
    			append_dev(sl_tooltip2, t6);
    			append_dev(sl_tooltip2, a2);
    			append_dev(a2, i2);
    			append_dev(sl_tab2, t7);
    			if_block1.m(sl_tab2, null);
    			append_dev(sl_tab_group, t8);
    			append_dev(sl_tab_group, sl_tab_panel0);
    			append_dev(sl_tab_panel0, div7);
    			append_dev(div7, p0);
    			append_dev(p0, a3);
    			append_dev(a3, t9);
    			append_dev(p0, t10);
    			if (if_block2) if_block2.m(p0, null);
    			append_dev(p0, t11);
    			append_dev(div7, t12);
    			append_dev(div7, ul);
    			append_dev(ul, li0);
    			append_dev(li0, sl_tooltip3);
    			append_dev(sl_tooltip3, div3);
    			div3.innerHTML = raw3_value;
    			append_dev(sl_tooltip3, t13);
    			append_dev(sl_tooltip3, a4);
    			append_dev(a4, i3);
    			append_dev(li0, t14);
    			append_dev(ul, t15);
    			append_dev(ul, li1);
    			append_dev(li1, sl_tooltip4);
    			append_dev(sl_tooltip4, div4);
    			div4.innerHTML = raw4_value;
    			append_dev(sl_tooltip4, t16);
    			append_dev(sl_tooltip4, a5);
    			append_dev(a5, i4);
    			append_dev(li1, t17);
    			append_dev(ul, t18);
    			append_dev(ul, li2);
    			append_dev(li2, sl_tooltip5);
    			append_dev(sl_tooltip5, div5);
    			div5.innerHTML = raw5_value;
    			append_dev(sl_tooltip5, t19);
    			append_dev(sl_tooltip5, a6);
    			append_dev(a6, i5);
    			append_dev(li2, t20);
    			append_dev(div7, t21);
    			append_dev(div7, div6);
    			append_dev(div6, sl_button0);
    			append_dev(div6, t23);
    			append_dev(div6, sl_button1);
    			append_dev(div6, t25);
    			append_dev(div6, sl_button2);
    			append_dev(sl_tab_panel0, t27);
    			append_dev(sl_tab_panel0, p1);
    			append_dev(sl_tab_group, t28);
    			append_dev(sl_tab_group, sl_tab_panel1);
    			mount_component(importmodules, sl_tab_panel1, null);
    			append_dev(sl_tab_group, t29);
    			append_dev(sl_tab_group, sl_tab_panel2);
    			mount_component(importimages, sl_tab_panel2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(sl_button0, "click", /*click_handler*/ ctx[8], false, false, false),
    					listen_dev(sl_button0, "keydown", /*keydown_handler*/ ctx[9], false, false, false),
    					listen_dev(sl_button1, "click", /*click_handler_1*/ ctx[10], false, false, false),
    					listen_dev(sl_button1, "keydown", /*keydown_handler_1*/ ctx[11], false, false, false),
    					listen_dev(sl_button2, "click", /*click_handler_2*/ ctx[12], false, false, false),
    					listen_dev(sl_button2, "keydown", /*keydown_handler_2*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(sl_tab1, null);
    				}
    			}

    			if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(sl_tab2, null);
    				}
    			}

    			if (/*importCourseDetails*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$5(ctx);
    					if_block2.c();
    					if_block2.m(p0, t11);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			const importmodules_changes = {};
    			if (dirty & /*collectionsDetails*/ 1) importmodules_changes.collectionsDetails = /*collectionsDetails*/ ctx[0];

    			if (!updating_modulesCompleteStatus && dirty & /*modulesCompleteStatus*/ 2) {
    				updating_modulesCompleteStatus = true;
    				importmodules_changes.modulesCompleteStatus = /*modulesCompleteStatus*/ ctx[1];
    				add_flush_callback(() => updating_modulesCompleteStatus = false);
    			}

    			importmodules.$set(importmodules_changes);
    			const importimages_changes = {};
    			if (dirty & /*collectionsDetails*/ 1) importimages_changes.collectionsDetails = /*collectionsDetails*/ ctx[0];

    			if (!updating_imagesCompleteStatus && dirty & /*imagesCompleteStatus*/ 4) {
    				updating_imagesCompleteStatus = true;
    				importimages_changes.imagesCompleteStatus = /*imagesCompleteStatus*/ ctx[2];
    				add_flush_callback(() => updating_imagesCompleteStatus = false);
    			}

    			importimages.$set(importimages_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(importmodules.$$.fragment, local);
    			transition_in(importimages.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(importmodules.$$.fragment, local);
    			transition_out(importimages.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_dialog);
    			if_block0.d();
    			if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_component(importmodules);
    			destroy_component(importimages);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $configStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(17, $configStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ProcessImportedCollections', slots, []);
    	let { collectionsDetails } = $$props;
    	const currentHostName = document.location.hostname;
    	const baseApiUrl = `https://${currentHostName}/api/v1`;

    	// status placeholders for sub-component completion
    	let modulesCompleteStatus;

    	let imagesCompleteStatus;
    	let currentCourseId = $configStore["courseId"];
    	let importCourseId = collectionsDetails.getImportedCourseId();
    	let currentCourseDetails = null;
    	let importCourseDetails = null;

    	wf_fetchData(`${baseApiUrl}/courses/${currentCourseId}`).then(msg => {
    		if (msg.status === 200) {
    			currentCourseDetails = msg.body;
    		}
    	});

    	wf_fetchData(`${baseApiUrl}/courses/${importCourseId}`).then(msg => {
    		if (msg.status === 200) {
    			$$invalidate(3, importCourseDetails = msg.body);
    		}
    	});

    	/**
     * @function proceedChoice
     * @param choice
     * @description Handle the user's choice to proceed with the import
     * and then close the dialog
     */
    	function proceedChoice(choice) {
    		const dialog = document.querySelector(".cc-dialog");
    		dialog.remove();
    		set_store_value(configStore, $configStore["migrationOutcome"] = choice, $configStore);
    	}

    	const HELP = {
    		copy: {
    			tooltip: `<p>Collections configuration copied from another course will need to be modified.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/"
    		},
    		summary: {
    			tooltip: `<p>What was found? What might you do next?`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/"
    		},
    		modules: {
    			tooltip: `<p>Changes required for module configuration in Collections</p>`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/#modules"
    		},
    		images: {
    			tooltip: `<p>Status of any course-based module module images in Collections configuration</p>`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/#images"
    		},
    		proceed: {
    			tooltip: `<p>Collections will update its configuration and you can proceed using Canvas Collections</p>`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/#proceed"
    		},
    		cancel: {
    			tooltip: `<p>Cancel the import, return to the course make any changes, and then recommence the import.</p>
	  <p><sl-icon name="info-circle"></sl-icon> You cannot use Collections in this courses until the migration process
		is complete.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/#cancel"
    		},
    		refresh: {
    			tooltip: `<p>Refresh Collections configuration to a blank state. Allowing you to start fresh 
			and use the Collections interface to customise design for the new course.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/walk-throughs/course-copy/process/#refresh"
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (collectionsDetails === undefined && !('collectionsDetails' in $$props || $$self.$$.bound[$$self.$$.props['collectionsDetails']])) {
    			console.warn("<ProcessImportedCollections> was created without expected prop 'collectionsDetails'");
    		}
    	});

    	const writable_props = ['collectionsDetails'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ProcessImportedCollections> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => proceedChoice("proceed");
    	const keydown_handler = () => proceedChoice("proceed");
    	const click_handler_1 = () => proceedChoice("cancel");
    	const keydown_handler_1 = () => proceedChoice("cancel");
    	const click_handler_2 = () => proceedChoice("refresh");
    	const keydown_handler_2 = () => proceedChoice("refresh");

    	function importmodules_modulesCompleteStatus_binding(value) {
    		modulesCompleteStatus = value;
    		$$invalidate(1, modulesCompleteStatus);
    	}

    	function importimages_imagesCompleteStatus_binding(value) {
    		imagesCompleteStatus = value;
    		$$invalidate(2, imagesCompleteStatus);
    	}

    	$$self.$$set = $$props => {
    		if ('collectionsDetails' in $$props) $$invalidate(0, collectionsDetails = $$props.collectionsDetails);
    	};

    	$$self.$capture_state = () => ({
    		configStore,
    		wf_fetchData,
    		ImportModules,
    		ImportImages,
    		collectionsDetails,
    		currentHostName,
    		baseApiUrl,
    		modulesCompleteStatus,
    		imagesCompleteStatus,
    		currentCourseId,
    		importCourseId,
    		currentCourseDetails,
    		importCourseDetails,
    		proceedChoice,
    		HELP,
    		$configStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collectionsDetails' in $$props) $$invalidate(0, collectionsDetails = $$props.collectionsDetails);
    		if ('modulesCompleteStatus' in $$props) $$invalidate(1, modulesCompleteStatus = $$props.modulesCompleteStatus);
    		if ('imagesCompleteStatus' in $$props) $$invalidate(2, imagesCompleteStatus = $$props.imagesCompleteStatus);
    		if ('currentCourseId' in $$props) $$invalidate(4, currentCourseId = $$props.currentCourseId);
    		if ('importCourseId' in $$props) $$invalidate(5, importCourseId = $$props.importCourseId);
    		if ('currentCourseDetails' in $$props) currentCourseDetails = $$props.currentCourseDetails;
    		if ('importCourseDetails' in $$props) $$invalidate(3, importCourseDetails = $$props.importCourseDetails);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		collectionsDetails,
    		modulesCompleteStatus,
    		imagesCompleteStatus,
    		importCourseDetails,
    		currentCourseId,
    		importCourseId,
    		proceedChoice,
    		HELP,
    		click_handler,
    		keydown_handler,
    		click_handler_1,
    		keydown_handler_1,
    		click_handler_2,
    		keydown_handler_2,
    		importmodules_modulesCompleteStatus_binding,
    		importimages_imagesCompleteStatus_binding
    	];
    }

    class ProcessImportedCollections extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { collectionsDetails: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProcessImportedCollections",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get collectionsDetails() {
    		throw new Error("<ProcessImportedCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collectionsDetails(value) {
    		throw new Error("<ProcessImportedCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CollectionsNavigation.svelte generated by Svelte v3.55.0 */
    const file$7 = "src\\components\\CollectionsNavigation.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (33:6) {#if !($collectionsStore["COLLECTIONS"][collectionName].hide && !$configStore["editMode"])}
    function create_if_block$4(ctx) {
    	let li;
    	let a;
    	let t0_value = /*collectionName*/ ctx[7] + "";
    	let t0;
    	let t1;
    	let t2;
    	let li_class_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*collectionName*/ ctx[7]);
    	}

    	let if_block = /*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*collectionName*/ ctx[7]].hide && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			attr_dev(a, "href", "#cc-collection-" + /*i*/ ctx[9]);
    			attr_dev(a, "class", "svelte-1oz84ff");
    			add_location(a, file$7, 34, 10, 1343);
    			attr_dev(li, "class", li_class_value = "cc-nav " + /*activeCollection*/ ctx[2][/*collectionName*/ ctx[7]] + " svelte-1oz84ff");
    			add_location(li, file$7, 33, 8, 1277);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    			if (if_block) if_block.m(li, null);
    			append_dev(li, t2);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", stop_propagation(click_handler), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*collectionNames*/ 1 && t0_value !== (t0_value = /*collectionName*/ ctx[7] + "")) set_data_dev(t0, t0_value);

    			if (/*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*collectionName*/ ctx[7]].hide) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					if_block.m(li, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*activeCollection, collectionNames*/ 5 && li_class_value !== (li_class_value = "cc-nav " + /*activeCollection*/ ctx[2][/*collectionName*/ ctx[7]] + " svelte-1oz84ff")) {
    				attr_dev(li, "class", li_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(33:6) {#if !($collectionsStore[\\\"COLLECTIONS\\\"][collectionName].hide && !$configStore[\\\"editMode\\\"])}",
    		ctx
    	});

    	return block;
    }

    // (40:10) {#if $collectionsStore["COLLECTIONS"][collectionName].hide}
    function create_if_block_1$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Hidden";
    			attr_dev(div, "class", "cc-collection-hidden svelte-1oz84ff");
    			add_location(div, file$7, 40, 12, 1598);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(40:10) {#if $collectionsStore[\\\"COLLECTIONS\\\"][collectionName].hide}",
    		ctx
    	});

    	return block;
    }

    // (32:4) {#each collectionNames as collectionName, i}
    function create_each_block$4(ctx) {
    	let if_block_anchor;
    	let if_block = !(/*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*collectionName*/ ctx[7]].hide && !/*$configStore*/ ctx[3]["editMode"]) && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!(/*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*collectionName*/ ctx[7]].hide && !/*$configStore*/ ctx[3]["editMode"])) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(32:4) {#each collectionNames as collectionName, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div;
    	let ul;
    	let each_value = /*collectionNames*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-1oz84ff");
    			add_location(ul, file$7, 30, 2, 1114);
    			attr_dev(div, "class", "cc-nav svelte-1oz84ff");
    			add_location(div, file$7, 29, 0, 1090);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeCollection, collectionNames, $collectionsStore, navigateCollections, $configStore*/ 31) {
    				each_value = /*collectionNames*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(3, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(1, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionsNavigation', slots, []);
    	let { activeCollectionName } = $$props;
    	let collectionNames = [];
    	let activeCollection = {};

    	// create activeCollection dict keyed on collection name
    	// with value "cc-active" if the collection is the current collection,
    	// "" otherwise
    	/**
     * @function navigateCollections
     * @param collectionName
     * @description navigate to a new collection
     */
    	function navigateCollections(clickedCollectionName) {
    		//activeCollection[$configStore["currentCollection"]] = "";
    		$$invalidate(2, activeCollection[activeCollectionName] = "", activeCollection);

    		set_store_value(configStore, $configStore["currentCollection"] = clickedCollectionName, $configStore);
    		$$invalidate(2, activeCollection[clickedCollectionName] = "cc-active", activeCollection);
    		$$invalidate(5, activeCollectionName = clickedCollectionName);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (activeCollectionName === undefined && !('activeCollectionName' in $$props || $$self.$$.bound[$$self.$$.props['activeCollectionName']])) {
    			console.warn("<CollectionsNavigation> was created without expected prop 'activeCollectionName'");
    		}
    	});

    	const writable_props = ['activeCollectionName'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollectionsNavigation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = collectionName => navigateCollections(collectionName);

    	$$self.$$set = $$props => {
    		if ('activeCollectionName' in $$props) $$invalidate(5, activeCollectionName = $$props.activeCollectionName);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		activeCollectionName,
    		collectionNames,
    		activeCollection,
    		navigateCollections,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('activeCollectionName' in $$props) $$invalidate(5, activeCollectionName = $$props.activeCollectionName);
    		if ('collectionNames' in $$props) $$invalidate(0, collectionNames = $$props.collectionNames);
    		if ('activeCollection' in $$props) $$invalidate(2, activeCollection = $$props.activeCollection);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$collectionsStore, collectionNames, activeCollectionName*/ 35) {
    			{
    				$$invalidate(0, collectionNames = $collectionsStore["COLLECTIONS_ORDER"]);

    				collectionNames.forEach(collectionName => {
    					$$invalidate(
    						2,
    						activeCollection[collectionName] = collectionName === activeCollectionName
    						? "cc-active"
    						: "",
    						activeCollection
    					);
    				});

    				(($$invalidate(5, activeCollectionName), $$invalidate(1, $collectionsStore)), $$invalidate(0, collectionNames));
    			}
    		}
    	};

    	return [
    		collectionNames,
    		$collectionsStore,
    		activeCollection,
    		$configStore,
    		navigateCollections,
    		activeCollectionName,
    		click_handler
    	];
    }

    class CollectionsNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { activeCollectionName: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionsNavigation",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get activeCollectionName() {
    		throw new Error("<CollectionsNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeCollectionName(value) {
    		throw new Error("<CollectionsNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CollectionRepresentation.svelte generated by Svelte v3.55.0 */

    const { Error: Error_1 } = globals;

    function create_fragment$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*representationComponent*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				collection: /*$configStore*/ ctx[1]["currentCollection"],
    				claytons: /*claytons*/ ctx[0]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*$configStore*/ 2) switch_instance_changes.collection = /*$configStore*/ ctx[1]["currentCollection"];
    			if (dirty & /*claytons*/ 1) switch_instance_changes.claytons = /*claytons*/ ctx[0];

    			if (switch_value !== (switch_value = /*representationComponent*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	let $representationsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(1, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(4, $collectionsStore = $$value));
    	validate_store(representationsStore, 'representationsStore');
    	component_subscribe($$self, representationsStore, $$value => $$invalidate(5, $representationsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionRepresentation', slots, []);
    	let { collectionName } = $$props;
    	let { claytons } = $$props;
    	let complete = false;

    	if (!claytons) {
    		claytons = false;
    	}

    	let representationComponent;

    	if (!collectionName) {
    		// TODO better error handling
    		throw new Error("CollectionRepresentation component requires a collection prop");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (collectionName === undefined && !('collectionName' in $$props || $$self.$$.bound[$$self.$$.props['collectionName']])) {
    			console.warn("<CollectionRepresentation> was created without expected prop 'collectionName'");
    		}

    		if (claytons === undefined && !('claytons' in $$props || $$self.$$.bound[$$self.$$.props['claytons']])) {
    			console.warn("<CollectionRepresentation> was created without expected prop 'claytons'");
    		}
    	});

    	const writable_props = ['collectionName', 'claytons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollectionRepresentation> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('collectionName' in $$props) $$invalidate(3, collectionName = $$props.collectionName);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		modulesStore,
    		representationsStore,
    		afterUpdate,
    		modifyCanvasModulesList,
    		collectionName,
    		claytons,
    		complete,
    		representationComponent,
    		$configStore,
    		$collectionsStore,
    		$representationsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collectionName' in $$props) $$invalidate(3, collectionName = $$props.collectionName);
    		if ('claytons' in $$props) $$invalidate(0, claytons = $$props.claytons);
    		if ('complete' in $$props) complete = $$props.complete;
    		if ('representationComponent' in $$props) $$invalidate(2, representationComponent = $$props.representationComponent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$collectionsStore, collectionName, $representationsStore, $configStore*/ 58) {
    			{
    				const localRep = $collectionsStore["COLLECTIONS"][collectionName]["representation"];

    				if (!$representationsStore.hasOwnProperty(localRep)) {
    					alert(`CollectionRepresentation component requires a valid representation prop. ${localRep} is not valid`);
    				}

    				$$invalidate(2, representationComponent = $representationsStore[localRep]);

    				// don't modify canvas modules if
    				// - collections is one
    				// - the current collection's representation is CollectionsTable
    				if ($configStore["ccOn"] && $collectionsStore["COLLECTIONS"][$configStore["currentCollection"]]["representation"] !== "CollectionsTable") {
    					modifyCanvasModulesList($configStore["currentCollection"], $collectionsStore["COLLECTIONS"][$configStore["currentCollection"]]["unallocated"]);
    				}
    			}
    		}
    	};

    	return [
    		claytons,
    		$configStore,
    		representationComponent,
    		collectionName,
    		$collectionsStore,
    		$representationsStore
    	];
    }

    class CollectionRepresentation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { collectionName: 3, claytons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionRepresentation",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get collectionName() {
    		throw new Error_1("<CollectionRepresentation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collectionName(value) {
    		throw new Error_1("<CollectionRepresentation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get claytons() {
    		throw new Error_1("<CollectionRepresentation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set claytons(value) {
    		throw new Error_1("<CollectionRepresentation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\IncludePage.svelte generated by Svelte v3.55.0 */
    const file$6 = "src\\components\\IncludePage.svelte";

    function create_fragment$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "cc-include-page");
    			attr_dev(div, "id", "cc-include-page");
    			add_location(div, file$6, 44, 0, 1611);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = /*pageContent*/ ctx[0];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*pageContent*/ 1) div.innerHTML = /*pageContent*/ ctx[0];		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(3, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(4, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IncludePage', slots, []);
    	let { collectionName = "" } = $$props;
    	let pageName = "";
    	let pageContent = "";

    	/**
     * @function addIncludePage
     * @param pageName
     * @param pageObject
     * @description Call back for the attempt to get the content of the includePage
     * If it succeeds set pageContent to the body of the pageObject. If not, set pageContent to ""
     */
    	function addIncludePage(pageName, pageObject) {
    		if (pageObject) {
    			$$invalidate(0, pageContent = pageObject.body || "");
    		} else {
    			$$invalidate(0, pageContent = "");
    		}
    	}

    	const writable_props = ['collectionName'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IncludePage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('collectionName' in $$props) $$invalidate(1, collectionName = $$props.collectionName);
    	};

    	$$self.$capture_state = () => ({
    		getPageName,
    		toastAlert,
    		collectionsStore,
    		configStore,
    		collectionName,
    		pageName,
    		pageContent,
    		addIncludePage,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collectionName' in $$props) $$invalidate(1, collectionName = $$props.collectionName);
    		if ('pageName' in $$props) $$invalidate(2, pageName = $$props.pageName);
    		if ('pageContent' in $$props) $$invalidate(0, pageContent = $$props.pageContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$collectionsStore, collectionName, pageName, $configStore*/ 30) {
    			// reactively update the page as the collection's includePage changes
    			{
    				$$invalidate(2, pageName = $collectionsStore["COLLECTIONS"][collectionName].includePage);

    				if (pageName !== "") {
    					getPageName(pageName, $configStore["courseId"], addIncludePage);
    				} else {
    					$$invalidate(0, pageContent = "");
    				}
    			}
    		}
    	};

    	return [pageContent, collectionName, pageName, $configStore, $collectionsStore];
    }

    class IncludePage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { collectionName: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IncludePage",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get collectionName() {
    		throw new Error("<IncludePage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collectionName(value) {
    		throw new Error("<IncludePage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CanvasCollectionsRepresentation.svelte generated by Svelte v3.55.0 */

    // (71:0) {#if $collectionsStore["COLLECTIONS_ORDER"].length > 0}
    function create_if_block$3(ctx) {
    	let collectionsnavigation;
    	let t0;
    	let t1;
    	let collectionrepresentation;
    	let updating_collectionName;
    	let t2;
    	let if_block1_anchor;
    	let current;

    	collectionsnavigation = new CollectionsNavigation({
    			props: {
    				activeCollectionName: /*$configStore*/ ctx[0]["currentCollection"]
    			},
    			$$inline: true
    		});

    	let if_block0 = !/*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*$configStore*/ ctx[0]["currentCollection"]].includeAfter && create_if_block_2$2(ctx);

    	function collectionrepresentation_collectionName_binding(value) {
    		/*collectionrepresentation_collectionName_binding*/ ctx[2](value);
    	}

    	let collectionrepresentation_props = { claytons: false };

    	if (/*$configStore*/ ctx[0]["currentCollection"] !== void 0) {
    		collectionrepresentation_props.collectionName = /*$configStore*/ ctx[0]["currentCollection"];
    	}

    	collectionrepresentation = new CollectionRepresentation({
    			props: collectionrepresentation_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(collectionrepresentation, 'collectionName', collectionrepresentation_collectionName_binding, /*$configStore*/ ctx[0]["currentCollection"]));
    	let if_block1 = /*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*$configStore*/ ctx[0]["currentCollection"]].includeAfter && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			create_component(collectionsnavigation.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			create_component(collectionrepresentation.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(collectionsnavigation, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(collectionrepresentation, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const collectionsnavigation_changes = {};
    			if (dirty & /*$configStore*/ 1) collectionsnavigation_changes.activeCollectionName = /*$configStore*/ ctx[0]["currentCollection"];
    			collectionsnavigation.$set(collectionsnavigation_changes);

    			if (!/*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*$configStore*/ ctx[0]["currentCollection"]].includeAfter) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$collectionsStore, $configStore*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const collectionrepresentation_changes = {};

    			if (!updating_collectionName && dirty & /*$configStore*/ 1) {
    				updating_collectionName = true;
    				collectionrepresentation_changes.collectionName = /*$configStore*/ ctx[0]["currentCollection"];
    				add_flush_callback(() => updating_collectionName = false);
    			}

    			collectionrepresentation.$set(collectionrepresentation_changes);

    			if (/*$collectionsStore*/ ctx[1]["COLLECTIONS"][/*$configStore*/ ctx[0]["currentCollection"]].includeAfter) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$collectionsStore, $configStore*/ 3) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collectionsnavigation.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(collectionrepresentation.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collectionsnavigation.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(collectionrepresentation.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(collectionsnavigation, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(collectionrepresentation, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(71:0) {#if $collectionsStore[\\\"COLLECTIONS_ORDER\\\"].length > 0}",
    		ctx
    	});

    	return block;
    }

    // (75:2) {#if !$collectionsStore["COLLECTIONS"][$configStore["currentCollection"]].includeAfter}
    function create_if_block_2$2(ctx) {
    	let includepage;
    	let current;

    	includepage = new IncludePage({
    			props: {
    				collectionName: /*$configStore*/ ctx[0]["currentCollection"]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(includepage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(includepage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const includepage_changes = {};
    			if (dirty & /*$configStore*/ 1) includepage_changes.collectionName = /*$configStore*/ ctx[0]["currentCollection"];
    			includepage.$set(includepage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(includepage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(includepage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(includepage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(75:2) {#if !$collectionsStore[\\\"COLLECTIONS\\\"][$configStore[\\\"currentCollection\\\"]].includeAfter}",
    		ctx
    	});

    	return block;
    }

    // (82:2) {#if $collectionsStore["COLLECTIONS"][$configStore["currentCollection"]].includeAfter}
    function create_if_block_1$2(ctx) {
    	let includepage;
    	let current;

    	includepage = new IncludePage({
    			props: {
    				collectionName: /*$configStore*/ ctx[0]["currentCollection"]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(includepage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(includepage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const includepage_changes = {};
    			if (dirty & /*$configStore*/ 1) includepage_changes.collectionName = /*$configStore*/ ctx[0]["currentCollection"];
    			includepage.$set(includepage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(includepage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(includepage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(includepage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(82:2) {#if $collectionsStore[\\\"COLLECTIONS\\\"][$configStore[\\\"currentCollection\\\"]].includeAfter}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$collectionsStore*/ ctx[1]["COLLECTIONS_ORDER"].length > 0 && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$collectionsStore*/ ctx[1]["COLLECTIONS_ORDER"].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$collectionsStore*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(0, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(1, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CanvasCollectionsRepresentation', slots, []);
    	let complete = false;

    	/**
     * @function checkModuleScrollTo()
     * @description When the representation has finished update
     * If the url hash === module_<moduleId>
     * - if the module is in another collection, change to that collection
     *   This will generate another update which will eventually end up back here
     * - attempt to scrollTo the module
     * - set complete=true so we don't come back again
     */
    	function checkModuleScrollTo() {
    		// check to see if url.hash === module_<moduleId>
    		const hash = window.location.hash;

    		const regex = /^#module_(\d+)$/;
    		const match = hash.match(regex);

    		if (match) {
    			const moduleId = match[1];

    			// does the currentCollection match the module's collection
    			const moduleCollectionName = $collectionsStore["MODULES"][moduleId].collection;

    			if (moduleCollectionName !== $configStore["currentCollection"]) {
    				set_store_value(configStore, $configStore["currentCollection"] = moduleCollectionName, $configStore);
    				return;
    			}

    			const module = document.getElementById(moduleId);

    			if (module) {
    				// check to see if the module is visible (e.g. collection is visible)
    				if (module.style.display !== "none") {
    					module.scrollIntoView();
    				}
    			}
    		}

    		complete = true;
    	}

    	/**
     * @function afterUpdate()
     * @description Called after the component is updated
     * For the first time, check if the URL hash contains module_<moduleId>
     * If it does, try to scroll to that module with collections display
     */
    	afterUpdate(() => {
    		if (!complete) {
    			checkModuleScrollTo();
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CanvasCollectionsRepresentation> was created with unknown prop '${key}'`);
    	});

    	function collectionrepresentation_collectionName_binding(value) {
    		if ($$self.$$.not_equal($configStore["currentCollection"], value)) {
    			$configStore["currentCollection"] = value;
    			configStore.set($configStore);
    		}
    	}

    	$$self.$capture_state = () => ({
    		configStore,
    		collectionsStore,
    		CollectionsNavigation,
    		CollectionRepresentation,
    		IncludePage,
    		afterUpdate,
    		complete,
    		checkModuleScrollTo,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('complete' in $$props) complete = $$props.complete;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$configStore, $collectionsStore*/ 3) {
    			//let localCollectionName : string = "";
    			{
    				if (!$configStore["currentCollection"]) {
    					// if no current collection, set it to the first element in COLLECTIONS_ORDER
    					// if it exists
    					if ($collectionsStore["COLLECTIONS_ORDER"].length > 0) {
    						set_store_value(configStore, $configStore["currentCollection"] = $collectionsStore["COLLECTIONS_ORDER"][0], $configStore);
    					}
    				}
    			}
    		}
    	};

    	return [
    		$configStore,
    		$collectionsStore,
    		collectionrepresentation_collectionName_binding
    	];
    }

    class CanvasCollectionsRepresentation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CanvasCollectionsRepresentation",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /**
     * @file updatePageController.ts
     * @description updatePageController manages the process of updating one or more pages
     * for the claytons version of Collections
     *
     * Will construct a task list based on the parameters, two types of tasks
     * - Collection representation - update page with the rep of a collection
     * - (maybe) add tab interface for each page with multiple collections
     *
     * Each task goes through a cycle of functions, including async APIs, basically
     * - check if task list is empty, if so finish, maybe do a callback
     * - if collection && includePage get the include page
     * - get the canvas object for the output page
     * - perform the necessary update
     * - write the changes back to canvas
     * - modify the task list to represent outcome
     * - go to the top of the list
     */
    class updatePageController {
        /**
         * @method constructor
         * @param {string} singleCollectionName - used for update output page, which collection
         * @param {Function} completedCallback - function to call on completion
         * @param {number} navOption - used for Full Claytons, which nav option
         */
        constructor(singleCollectionName = undefined, completedCallback = undefined, navOption = undefined) {
            this.navOption = navOption;
            this.singleCollectionName = singleCollectionName;
            this.completedCallback = completedCallback;
            this.configStore = get_store_value(configStore);
            this.collectionsStore = get_store_value(collectionsStore);
            this.tasks = [];
            this.completedTasks = [];
            this.errors = [];
            this.createTaskLists();
            this.checkTaskList();
        }
        /**
         * @method getNumErrors
         * @returns {number} - number of errors generated by controller
         * @description getter for the number of errors
         */
        getNumErrors() {
            // loop through the completed tasks and generate this.errors anew
            this.errors = [];
            for (let task of this.completedTasks) {
                if (task.error) {
                    this.errors = this.errors.concat(task.errors);
                }
            }
            return this.errors.length;
        }
        execute() {
            if (this.errors.length !== 0) {
                this.complete();
            }
            else {
                this.startUpdate();
            }
        }
        /**
         * @method complete
         * @description Check if there's a call back and call if there is
         */
        complete() {
            if (this.completedCallback) {
                this.completedCallback(this);
            }
        }
        /**
         * @method getCollectionNamesUpdates
         * @returns {Array} - array of collection names that were modified
         * @description Called to get summary of completed tasks where collections
         * were updated
         */
        getCollectionNamesUpdated() {
            let collectionNames = [];
            for (let task of this.completedTasks) {
                if (task.collection) {
                    collectionNames.push(task.collection);
                }
            }
            return collectionNames;
        }
        /**
         * @method getPageNamesUpdated
         * @returns {Array} - array of page names that were modified
         * @description Called to get summary of complete updated page
         */
        getPageNamesUpdated() {
            let pageNames = {};
            for (let task of this.completedTasks) {
                if (task.outputPage) {
                    pageNames[task.outputPage] = task.outputPage;
                }
            }
            return Object.keys(pageNames);
        }
        /**
         * @method createTaskLists
         * @description Populates the tasks array with an initial set of tasks
         * for the controller's pipeline
         *
         * TODO - implement the full claytons population
         */
        createTaskLists() {
            /* singleCollection is defined */
            // Create a single task for singleCollection, and its outputPage
            if (this.singleCollectionName) {
                const theCollection = this.collectionsStore["COLLECTIONS"][this.singleCollectionName];
                const outputPageName = theCollection.outputPage;
                const representationName = theCollection.representation;
                const outputPageUrl = outputPageName.toLowerCase().replace(/ /g, "-");
                // set the nav option to the "None" choice
                this.navOption = 1;
                this.tasks.push({
                    collection: this.singleCollectionName,
                    outputPage: outputPageName,
                    outputPageUrl: outputPageUrl,
                    representation: representationName,
                    pageObject: null,
                    completed: false,
                    error: false,
                    errors: [],
                });
                return;
            }
            /* Standard task list - update each collection's output page */
            // for each collection, create task Object
            // - collection
            // - outputPage and outputPageUrl
            // - representation
            // - completed/error/errors
            const collections = this.collectionsStore["COLLECTIONS_ORDER"].filter((collectionName) => {
                if (this.collectionsStore["COLLECTIONS"][collectionName].hasOwnProperty("outputPage") &&
                    this.collectionsStore["COLLECTIONS"][collectionName].outputPage !== "") {
                    return collectionName;
                }
            });
            for (let collection of collections) {
                const collectionConfig = this.collectionsStore["COLLECTIONS"][collection];
                const outputPageName = collectionConfig.outputPage;
                const representationName = collectionConfig.representation;
                const outputPageUrl = outputPageName.toLowerCase().replace(/ /g, "-");
                this.tasks.push({
                    collection: collection,
                    outputPage: outputPageName,
                    outputPageUrl: outputPageUrl,
                    representation: representationName,
                    completed: false,
                    error: false,
                    errors: [],
                });
            }
            // Only go further for the tab nav option
            if (this.navOption !== 3) {
                return;
            }
            /* add the "tab" task list as it's navOption===3 i.e. tabs */
            // One task for each page with multiple collections
            // For each page, create task object
            // - collections **this is the check in updateContent**
            // - outputPage and outputPageUrl
            // - representation
            // - completed/error/errors
            const pagesWithMultipleCollections = this.getPagesWithMultipleCollections();
            // loop through dictionary of pages with multiple collections
            for (let pageName in pagesWithMultipleCollections) {
                const collections = pagesWithMultipleCollections[pageName];
                const outputPageUrl = pageName.toLowerCase().replace(/ /g, "-");
                this.tasks.push({
                    collections: collections,
                    outputPage: pageName,
                    outputPageUrl: outputPageUrl,
                    completed: false,
                    error: false,
                    errors: [],
                });
            }
        }
        getPagesWithMultipleCollections() {
            const collectionNames = this.collectionsStore["COLLECTIONS_ORDER"];
            const collections = this.collectionsStore["COLLECTIONS"];
            const pages = {};
            collectionNames.forEach((collectionName) => {
                // if there's an output page
                if (collections[collectionName].hasOwnProperty("outputPage") &&
                    collections[collectionName].outputPage !== "") {
                    // if the page is not in the pages dictionary
                    if (!pages.hasOwnProperty(collections[collectionName].outputPage)) {
                        // add it with an array containing the collection name
                        pages[collections[collectionName].outputPage] = [collectionName];
                    }
                    else {
                        // otherwise add the collection name to the array
                        pages[collections[collectionName].outputPage].push(collectionName);
                    }
                }
            });
            for (let pageName in pages) {
                if (pages[pageName].length < 2) {
                    delete pages[pageName];
                }
            }
            return pages;
        }
        /**
         * @method checkTaskList
         * @description if navOption is 2 (full claytons) modify the task list
         * so there are no collections with the same output page
         */
        checkTaskList() {
            // if navOption=2 there should be no collections with the same output page
            if (this.navOption === 2 && this.tasks.length > 1) {
                // check for duplicates
                const outputPages = this.tasks.map((task) => task.outputPage);
                const uniqueOutputPages = [...new Set(outputPages)];
                if (outputPages.length !== uniqueOutputPages.length) {
                    this.errors.push(`"Pages" nav option doesn't work with pages used by multiple collections\nPage(s) used multiple times include: ${uniqueOutputPages.toString()}`);
                    // this is a fatal error - no point in continuing
                    this.completedTasks = this.tasks;
                    this.tasks = [];
                }
            }
        }
        /**
         * @method startUpdate
         * @description The start and end of the task processing pipline
         * - if there are no more tasks, then finish up
         * - otherwise, get the include page if necessary
         * - else get the output page
         */
        startUpdate() {
            if (this.tasks.length === 0) {
                this.complete();
                return;
            }
            // only get include page if
            // - this task has a "collection" field (the nav bar update won't)
            // - the collection has an includePage
            // - that includePage has a value
            if (this.tasks[0].hasOwnProperty("collection") &&
                this.collectionsStore["COLLECTIONS"][this.tasks[0].collection].hasOwnProperty("includePage") &&
                this.collectionsStore["COLLECTIONS"][this.tasks[0].collection]["includePage"] !== "") {
                let includePageName = this.collectionsStore["COLLECTIONS"][this.tasks[0].collection]["includePage"];
                // get the include page content
                // a chain that eventually starts getOutputPage
                includePageName = includePageName.toLowerCase().replace(/ /g, "-");
                this.getIncludePageContent(includePageName);
            }
            else {
                this.getOutputPage();
            }
        }
        /**
         * @function errorFirstTask
         * @desc Accept an error string that needs to be applied to the first task
         * Which is then removed from the tasks array and added to to completed
         * Start the next task
         * @param {*} error
         */
        errorFirstTask(error) {
            let errorTask = this.tasks.shift();
            errorTask.error = true;
            errorTask.errors.push(error);
            this.completedTasks.push(errorTask);
            // Originall was this
            // this.getOutputPage();
            // But I think this should go back to start update to handle the include page
            this.startUpdate();
        }
        /**
         * @method generateOutcomesString
         * @param {String} preamble - a string to add to the start of the summary
         * @returns {String}
         * @desc Generate a string summarising outcomes
         */
        generateOutcomesString(preamble) {
            // how many completedTasks?
            let completedTasks = this.completedTasks.length;
            // how many completed tasks with completed === true
            let completed = this.completedTasks.filter((task) => task.completed === true).length;
            // how many completed tasks with error === true
            let errors = this.completedTasks.filter((task) => task.error === true).length;
            let endSummary = "";
            if (errors > 0) {
                endSummary = ` with ${errors} errors`;
            }
            let summary = `${preamble} completed ${completed} of ${completedTasks} tasks${endSummary}.`;
            if (this.completedTasks.length > 0) {
                summary += "<ul>";
            }
            for (let task of this.completedTasks) {
                if (task.error) {
                    summary += `<li> ${task.collection} - ${task.outputPageUrl} - errors - ${task.errors.join("\n     ")} </li>`;
                }
                else if (task.completed) {
                    if (task.hasOwnProperty("collection")) {
                        summary += `<li> <em>${task.collection}</em> - 
		  <a href="/courses/${this.configStore["courseId"]}/pages/${task.outputPageUrl}" 
		  target="_blank" rel="noreferrer">${task.outputPage}</a> - 
		  <span style="color:rgb(1,101,1);">success</span>
		  </li>`;
                    }
                    else if (task.hasOwnProperty("collections")) {
                        summary += `<li> Tab navigation -
		  <a href="/courses/${this.configStore["courseId"]}/pages/${task.outputPageUrl}" 
		  target="_blank" rel="noreferrer">${task.outputPage}</a> - 
		  <span style="color:rgb(1,101,1);">success</span></li>`;
                    }
                }
            }
            if (this.completedTasks.length > 0) {
                summary += "</ul>";
            }
            if (this.errors.length > 0) {
                //     summary += `<p>Errors:</p>${this.errors.join("\n")}`;
                // add to summary as a list
                summary += '<p style="color: red">Errors:</p><ul>';
                for (let error of this.errors) {
                    summary += `<li>${error}</li>`;
                }
                summary += "</ul>";
            }
            return summary;
        }
        /**
         * @method getIncludePageContent
         * @param {string} pageName - the name of the include page
         * @description Use the Canvas API to get the full details of the page (pageObject)
         * And add the contents of the include page into the task for later use
         */
        async getIncludePageContent(pageName) {
            let callUrl = `/api/v1/courses/${this.configStore["courseId"]}/pages/${pageName}`;
            const response = await fetch(callUrl, {
                method: "GET",
                credentials: "include",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "X-CSRF-Token": this.configStore["csrfToken"],
                },
            });
            if (!response.ok) {
                // TODO if in edit mode, display some error
                return;
            }
            const newPageObject = await response.json();
            // save the include page content for this task for latter use in the pipeline
            this.tasks[0].includePageContent = `
		<div id="cc-${this.tasks[0].collection}-includePage" class="cc-includePage">
		  ${newPageObject.body}
		</div>`;
            this.getOutputPage();
        }
        /**
         * @method getOutputPage
         * @description Use Canvas API to get the pageObject for the output page
         * for the current task
         */
        async getOutputPage() {
            // check if there's an object in this.tasks
            const courseId = this.configStore["courseId"];
            const outputPageUrl = this.tasks[0].outputPageUrl;
            let callUrl = `/api/v1/courses/${courseId}/pages/${outputPageUrl}`;
            let response = await fetch(callUrl, {
                method: "GET",
                credentials: "include",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "X-CSRF-Token": this.configStore["csrfToken"],
                },
            });
            /*    if (!response.ok) {
              this.errorFirstTask(`Unable to get page ${outputPageUrl} from Canvas`);
              if (response.status === 404) {
                // page doesn't exist, so create it
                // actually, this should make mods to task[0] indicating an empty page
                // and call updateOutputContent
                // shouldn't be "collection" as the page should have been created earlier in the
                // task list
                // pageObject will not be set correctly as expected,
                this.tasks[0].pageObject = { status: 404};
                this.updateOutputContent()
                //this.createOutputPage();
        
              }
              return;
            } */
            if (response.status === 200 || response.status === 404) {
                const data = await response.json();
                this.tasks[0].pageObject = data;
                if (this.tasks[0].hasOwnProperty("collection")) {
                    this.updateOutputContent();
                }
                else {
                    // just adding the tab interface
                    this.updateTabContent();
                }
            }
        }
        /**
         * @function updateTabContent
         * @descr Task is focused on a page with multiple collections. Aiming to wrap
         * a new "tab" interface around the collection divs. Once complete call writeOutputPage
         *
         * Self generate the tab interface based on the collection names
         *
         * Two options:
         * 1. tab interface already there - div#cc-nav exists
         *    - the collections should be there
         *    - extract them and their content from the existing page
         *    - remove them all from the page (this includes some recently added)
         *    - insert them into new div#cc-nav
         *    - delete the existing div#cc-nav
         * 2. tab interface not there - div#cc-nav does not exist
         *    - tab interface will be appended at the end of the page
         *    - any existing collection divs will be removed from the page
         *    - inserted into the new tab interface (in order of collections)
         */
        updateTabContent() {
            // updating a tabbed page
            if (!this.tasks[0].hasOwnProperty("pageObject")) {
                this.errorFirstTask(`No pageObject for ${this.tasks[0].outputPageUrl}`);
                return;
            }
            const pageObject = this.tasks[0].pageObject;
            const collectionNames = this.tasks[0].collections;
            const escCollectionNames = collectionNames.map((collectionName) => collectionName.replace(/ /g, "-"));
            const originalContent = pageObject.body;
            // start parsing what's in the existing content
            const parser = new DOMParser();
            const doc = parser.parseFromString(originalContent, "text/html");
            // remove (and save) all the divs for the collections
            let collectionDivHTML = "";
            for (let i = 0; i < escCollectionNames.length; i++) {
                const divId = `cc-output-${escCollectionNames[i]}`;
                const collectionDiv = doc.getElementById(divId);
                if (collectionDiv) {
                    // save the div
                    collectionDivHTML += collectionDiv.outerHTML;
                    // remove the old collection div
                    collectionDiv.remove();
                }
            }
            // remove all .cc-includePage divs
            const includePageDivs = doc.getElementsByClassName("cc-includePage");
            for (let i = 0; i < includePageDivs.length; i++) {
                includePageDivs[i].remove();
            }
            // get the tab interface HTML from navView
            let tabInterfaceHtml = this.generateTabHtml(collectionNames, collectionDivHTML);
            // check if there's a tab interface already there
            const navDiv = doc.getElementById("cc-nav");
            if (navDiv) {
                // replace the existing navDiv with tabInterfaceHTML
                navDiv.innerHTML = tabInterfaceHtml;
            }
            else {
                doc.body.insertAdjacentHTML("beforeend", tabInterfaceHtml);
            }
            // update the new page content and write the output page
            this.tasks[0].newContent = doc.body.innerHTML;
            this.writeOutputPage();
        }
        /**
         * @method generateTabHtml
         * @desc Generate the HTML for the tabs based on collection names
         * @param {Array} collectionNames
         * @returns {String} Canvas tab html
         * TODO - move to using more svelte components for this
         */
        generateTabHtml(collectionNames, collectionDivHTML) {
            let navBarHTML = "";
            for (let collectionName of collectionNames) {
                // remove spaces from collectionName
                let escCollectionName = collectionName.replace(/ /g, "-");
                navBarHTML = `${navBarHTML}
<li style="display: table-cell; width: 100%; float: none;">
    <a style="float: none;text-decoration: none; display: block; text-align: center; padding: 1.5em 1em; font-size: 1.3em;white-space:break-spaces;" 
        href="#cc-output-${escCollectionName}">${collectionName}</a></li>`;
            }
            return `
<div id="cc-nav" class="enhanceable_content tabs" style="font-size: small;">
  <ul class="cc-nav" style="list-style-type: none; margin: 0; padding: 0; overflow: hidden; background-color: #eeeeee; display: table; table-layout: fixed; width: 100%;">
    ${navBarHTML}
  </ul>

  ${collectionDivHTML}
</div>`;
        }
        /**
         * @function updateOutputContent
         * @descr Have the old content from the page, need to update that content
         * with the output we're generating.  Focus is on updating whatever the
         * current ask is telling us - it will be a single collection
         */
        updateOutputContent() {
            if (!this.tasks[0].hasOwnProperty("pageObject")) {
                this.errorFirstTask(`No pageObject for ${this.tasks[0].outputPageUrl}`);
                return;
            }
            /** Two broad possibilities at this stage
             *  1. There was no existing page
             *     pageObject.status is 404,
             *  1. There was an existing page
             *     pageObject will have a body property (and all the other nice
             *     Canvas page object properties)
             */
            let originalContent = "";
            if (!this.tasks[0].pageObject.hasOwnProperty("message") &&
                this.tasks[0].pageObject.message !== "page not found") {
                // if the page was found, use the existing content
                originalContent = this.tasks[0].pageObject.body;
            }
            let collectionName = this.tasks[0].collection;
            const escCollectionName = collectionName.replace(/ /g, "-");
            //----------------------------------------------
            // generate the Claytons HTML
            const insertContentHtml = this.generateClaytons(collectionName);
            //----------------------------------------------
            // update the original content
            // check content for an existing div#cc-output-<collection-name>
            const divId = `cc-output-${escCollectionName}`;
            // convert content into a DOM object
            const parser = new DOMParser();
            const doc = parser.parseFromString(originalContent, "text/html");
            const div = doc.getElementById(divId);
            if (div) {
                // replace the content
                div.innerHTML = insertContentHtml;
            }
            else {
                // add a new div
                const newDiv = doc.createElement("div");
                newDiv.id = divId;
                newDiv.innerHTML = insertContentHtml;
                doc.body.appendChild(newDiv);
            }
            // at this stage, doc will contain the new div for the collection
            // if there's an include page, insert it into that div
            if (this.tasks[0].hasOwnProperty("includePageContent") &&
                this.tasks[0].includePageContent) {
                // there's content from an includePage - add it
                const newDiv = doc.getElementById(divId);
                // remove any existing cc-includePage divs in newDiv
                const includePageDivs = newDiv.getElementsByClassName("cc-includePage");
                for (let i = 0; i < includePageDivs.length; i++) {
                    includePageDivs[i].remove();
                }
                // insert the new includePageContent at the beginning of the div
                //const includeAfter = this.getCollectionIncludeAfter(collectionName);
                let includeAfter = false;
                if (this.collectionsStore["COLLECTIONS"][collectionName].hasOwnProperty("includeAfter")) {
                    includeAfter =
                        this.collectionsStore["COLLECTIONS"][collectionName]["includeAfter"];
                }
                if (!includeAfter) {
                    newDiv.insertAdjacentHTML("afterbegin", this.tasks[0].includePageContent);
                }
                else {
                    newDiv.insertAdjacentHTML("beforeend", this.tasks[0].includePageContent);
                }
            }
            // remove any .cc-includePage
            // don't need this as the includePage stuff should be within the collection div
            /*const includePages = doc.getElementsByClassName('cc-includePage');
                for (let i=0; i<includePages.length; i++) {
                    includePages[i].remove();
                } */
            // remove the nav bar stuff if we're none navOption
            if (this.navOption === 1) {
                // remove any ul.cc-nav
                const navUl = doc.querySelector("ul.cc-nav");
                if (navUl) {
                    navUl.remove();
                }
                // unwrap any div#cc-nav
                const navDiv = doc.getElementById("cc-nav");
                if (navDiv) {
                    navDiv.outerHTML = navDiv.innerHTML;
                }
            }
            let newContent = doc.body.innerHTML;
            this.tasks[0].newContent = newContent;
            this.writeOutputPage();
        }
        /**
         * @method generateClaytons
         * @param {string} collectionName
         * @description Generate HTML string for Claytons representation of the collection
         * named "collectionName"
         * - create a div element
         * - create a new CollectionRepresentation object with claytons true add to div
         * - return the innerHTML
         */
        generateClaytons(collectionName) {
            const div = document.createElement("div");
            // set up the props to pass to component
            // use ColelctionRepresentation and add to div
            new CollectionRepresentation({
                target: div,
                props: {
                    collectionName: collectionName,
                    claytons: true,
                },
            });
            // TODO error checking?
            return div.innerHTML;
        }
        /**
         * @method writeOutputPage
         * @description Write the new content for the first task in the list to the
         * appropriate Canvas page via the Canvas API
         */
        async writeOutputPage() {
            if (!this.tasks[0].hasOwnProperty("newContent")) {
                this.errorFirstTask(`No newContent for ${this.tasks[0].outputPageUrl}`);
                return;
            }
            let newContent = this.tasks[0].newContent;
            const courseId = this.configStore["courseId"];
            const outputPageUrl = this.tasks[0].outputPageUrl;
            // need this to be an id or empty
            // for an existing page, the pageObject should have the id and can use the URL
            // otherwise a new page, needs the URL
            let callUrl = `/api/v1/courses/${courseId}/pages`;
            if (this.tasks[0].hasOwnProperty("pageObject") &&
                this.tasks[0].pageObject.hasOwnProperty("page_id")) {
                // this is an existing page
                callUrl = `${callUrl}/${this.tasks[0].pageObject.page_id}`;
            }
            else {
                callUrl = `${callUrl}/${this.tasks[0].outputPageUrl}`;
            }
            // add in the CIDI labs custom CSS requirement
            // just in case we have it-- TODO remove reliance on this
            const CIDI_LABS_CUSTOM_CSS = `
		<div id="kl_custom_css">&nbsp;</div>
		`;
            // check if newContent already contains CIDI_LABS_CUSTOM_CSS
            if (newContent.indexOf(CIDI_LABS_CUSTOM_CSS) === -1) {
                newContent = newContent + CIDI_LABS_CUSTOM_CSS;
            }
            let _body = {
                wiki_page: {
                    body: newContent,
                    title: this.tasks[0].outputPage,
                },
            };
            const bodyString = JSON.stringify(_body);
            let method = "put";
            let response = await fetch(callUrl, {
                method: method,
                credentials: "include",
                headers: {
                    "Content-type": "application/json; charset=UTF-8",
                    Accept: "application/json; charset=UTF-8",
                    "X-CSRF-Token": this.configStore["csrfToken"],
                },
                body: bodyString,
            });
            if (!response.ok) {
                this.errorFirstTask(`Unable to update page ${outputPageUrl} in Canvas`);
                return;
            }
            let data = await response.json();
            if (data.length === 0) {
                this.errorFirstTask(`No data provided for page ${outputPageUrl}`);
                return;
            }
            else {
                if (this.tasks[0].hasOwnProperty("collection")) {
                    // we're updating a single page for a collection
                    const updateMsg = `<p>Updated 
		<a href="/courses/${this.configStore["courseId"]}/pages/${outputPageUrl}" target="_blank" rel="noreferrer">
		<em>${this.tasks[0].outputPage}</em></a>
		for the collection <em>${this.tasks[0].collection}</em></p>`;
                    toastAlert(updateMsg, "success");
                }
                else if (this.navOption === 3 &&
                    this.tasks[0].hasOwnProperty("collections")) {
                    // we've been adding a tab interface
                    const updateMsg = `<p>Added tab navigation to 
		<a href="/courses/${this.configStore["courseId"]}/pages/${outputPageUrl}" target="_blank" rel="noreferrer">
		<em>${this.tasks[0].outputPage}</em></a></p>`;
                    toastAlert(updateMsg, "success");
                }
                // finish up a successful task by moving it to completed
                let finishedTask = this.tasks.shift();
                finishedTask.completed = true;
                this.completedTasks.push(finishedTask);
                // start the next task
                this.startUpdate();
            }
        }
    }

    /* src\components\Configuration\CollectionConfiguration.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1$2 } = globals;
    const file$5 = "src\\components\\Configuration\\CollectionConfiguration.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	return child_ctx;
    }

    // (347:6) {#if order > 0}
    function create_if_block_3$1(ctx) {
    	let i;
    	let i_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon-arrow-up cc-move-collection svelte-15ntxpt");
    			attr_dev(i, "id", i_id_value = "cc-collection-$" + /*collectionName*/ ctx[0] + "-up");
    			add_location(i, file$5, 347, 8, 15815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "click", /*moveCollectionUp*/ ctx[12], false, false, false),
    					listen_dev(i, "keydown", /*moveCollectionUp*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && i_id_value !== (i_id_value = "cc-collection-$" + /*collectionName*/ ctx[0] + "-up")) {
    				attr_dev(i, "id", i_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(347:6) {#if order > 0}",
    		ctx
    	});

    	return block;
    }

    // (355:6) {#if order < numCollections - 1}
    function create_if_block_2$1(ctx) {
    	let i;
    	let i_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon-arrow-down cc-move-collection svelte-15ntxpt");
    			attr_dev(i, "id", i_id_value = "cc-collection-$" + /*collectionName*/ ctx[0] + "-down");
    			add_location(i, file$5, 355, 8, 16075);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "click", /*moveCollectionDown*/ ctx[13], false, false, false),
    					listen_dev(i, "keydown", /*moveCollectionDown*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && i_id_value !== (i_id_value = "cc-collection-$" + /*collectionName*/ ctx[0] + "-down")) {
    				attr_dev(i, "id", i_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(355:6) {#if order < numCollections - 1}",
    		ctx
    	});

    	return block;
    }

    // (424:8) {#each availableRepresentations as representation}
    function create_each_block$3(ctx) {
    	let option;
    	let t_value = /*representation*/ ctx[32] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*representation*/ ctx[32];
    			option.value = option.__value;
    			add_location(option, file$5, 424, 10, 18251);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(424:8) {#each availableRepresentations as representation}",
    		ctx
    	});

    	return block;
    }

    // (556:4) {#if !includePageExists && $collectionsStore["COLLECTIONS"][collectionName].includePage}
    function create_if_block_1$1(ctx) {
    	let div;
    	let t0;
    	let strong;
    	let t1_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includePage + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Page ");
    			strong = element("strong");
    			t1 = text(t1_value);
    			t2 = text(" does not exist");
    			add_location(strong, file$5, 557, 13, 22738);
    			attr_dev(div, "class", "cc-collection-two-line-error svelte-15ntxpt");
    			add_location(div, file$5, 556, 6, 22681);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, strong);
    			append_dev(strong, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$collectionsStore, collectionName*/ 65 && t1_value !== (t1_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includePage + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(556:4) {#if !includePageExists && $collectionsStore[\\\"COLLECTIONS\\\"][collectionName].includePage}",
    		ctx
    	});

    	return block;
    }

    // (602:4) {#if !outputPageExists && $collectionsStore["COLLECTIONS"][collectionName].outputPage !== ""}
    function create_if_block$2(ctx) {
    	let div;
    	let t0;
    	let strong;
    	let t1_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Will create a new page named ");
    			strong = element("strong");
    			t1 = text(t1_value);
    			add_location(strong, file$5, 603, 37, 24273);
    			attr_dev(div, "class", "cc-collection-two-line-warning svelte-15ntxpt");
    			add_location(div, file$5, 602, 6, 24190);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, strong);
    			append_dev(strong, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$collectionsStore, collectionName*/ 65 && t1_value !== (t1_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(602:4) {#if !outputPageExists && $collectionsStore[\\\"COLLECTIONS\\\"][collectionName].outputPage !== \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div22;
    	let p;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let span0;
    	let t6;
    	let t7;
    	let i0;
    	let i0_id_value;
    	let t8;
    	let div1;
    	let span1;
    	let label0;
    	let t9;
    	let label0_for_value;
    	let t10;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[17].configName.tooltip + "";
    	let t11;
    	let a0;
    	let i1;
    	let t12;
    	let span2;
    	let input0;
    	let input0_id_value;
    	let t13;
    	let div3;
    	let span3;
    	let label1;
    	let t14;
    	let label1_for_value;
    	let t15;
    	let sl_tooltip1;
    	let div2;
    	let raw1_value = /*HELP*/ ctx[17].configRepresentation.tooltip + "";
    	let t16;
    	let a1;
    	let i2;
    	let t17;
    	let span4;
    	let select;
    	let t18;
    	let select_id_value;
    	let t19;
    	let div10;
    	let div5;
    	let label2;
    	let t20;
    	let label2_for_value;
    	let t21;
    	let sl_tooltip2;
    	let div4;
    	let raw2_value = /*HELP*/ ctx[17].configDefault.tooltip + "";
    	let t22;
    	let a2;
    	let i3;
    	let t23;
    	let input1;
    	let input1_id_value;
    	let input1_checked_value;
    	let t24;
    	let div7;
    	let label3;
    	let t25;
    	let label3_for_value;
    	let t26;
    	let sl_tooltip3;
    	let div6;
    	let raw3_value = /*HELP*/ ctx[17].configHide.tooltip + "";
    	let t27;
    	let a3;
    	let i4;
    	let t28;
    	let input2;
    	let input2_disabled_value;
    	let t29;
    	let div9;
    	let label4;
    	let t30;
    	let label4_for_value;
    	let t31;
    	let sl_tooltip4;
    	let div8;
    	let raw4_value = /*HELP*/ ctx[17].configUnallocated.tooltip + "";
    	let t32;
    	let a4;
    	let i5;
    	let t33;
    	let input3;
    	let input3_id_value;
    	let t34;
    	let div16;
    	let div12;
    	let label5;
    	let t35;
    	let label5_for_value;
    	let t36;
    	let sl_tooltip5;
    	let div11;
    	let raw5_value = /*HELP*/ ctx[17].configIncludePage.tooltip + "";
    	let t37;
    	let a5;
    	let i6;
    	let t38;
    	let div13;
    	let t40;
    	let div15;
    	let input4;
    	let input4_id_value;
    	let input4_value_value;
    	let t41;
    	let span5;
    	let label6;
    	let t42;
    	let label6_for_value;
    	let t43;
    	let sl_tooltip6;
    	let div14;
    	let raw6_value = /*HELP*/ ctx[17].configIncludePageAfter.tooltip + "";
    	let t44;
    	let a6;
    	let i7;
    	let t45;
    	let input5;
    	let input5_id_value;
    	let t46;
    	let t47;
    	let div21;
    	let div18;
    	let label7;
    	let t48;
    	let label7_for_value;
    	let t49;
    	let sl_tooltip7;
    	let div17;
    	let raw7_value = /*HELP*/ ctx[17].configOutputPage.tooltip + "";
    	let t50;
    	let a7;
    	let i8;
    	let t51;
    	let div19;
    	let t53;
    	let div20;
    	let input6;
    	let input6_id_value;
    	let input6_value_value;
    	let t54;
    	let button;
    	let t55;
    	let button_id_value;
    	let button_disabled_value;
    	let t56;
    	let div22_id_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*order*/ ctx[3] > 0 && create_if_block_3$1(ctx);
    	let if_block1 = /*order*/ ctx[3] < /*numCollections*/ ctx[4] - 1 && create_if_block_2$1(ctx);
    	let each_value = /*availableRepresentations*/ ctx[9];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	let if_block2 = !/*includePageExists*/ ctx[1] && /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includePage && create_if_block_1$1(ctx);
    	let if_block3 = !/*outputPageExists*/ ctx[2] && /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage !== "" && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div22 = element("div");
    			p = element("p");
    			t0 = text(/*collectionName*/ ctx[0]);
    			t1 = text(" - (");
    			t2 = text(/*moduleCount*/ ctx[7]);
    			t3 = space();
    			t4 = text(/*moduleName*/ ctx[8]);
    			t5 = text(")\r\n    ");
    			span0 = element("span");
    			if (if_block0) if_block0.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			i0 = element("i");
    			t8 = space();
    			div1 = element("div");
    			span1 = element("span");
    			label0 = element("label");
    			t9 = text("Name");
    			t10 = space();
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t11 = space();
    			a0 = element("a");
    			i1 = element("i");
    			t12 = space();
    			span2 = element("span");
    			input0 = element("input");
    			t13 = space();
    			div3 = element("div");
    			span3 = element("span");
    			label1 = element("label");
    			t14 = text("Representation");
    			t15 = space();
    			sl_tooltip1 = element("sl-tooltip");
    			div2 = element("div");
    			t16 = space();
    			a1 = element("a");
    			i2 = element("i");
    			t17 = space();
    			span4 = element("span");
    			select = element("select");
    			t18 = text(">\r\n        ");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t19 = space();
    			div10 = element("div");
    			div5 = element("div");
    			label2 = element("label");
    			t20 = text("Default");
    			t21 = space();
    			sl_tooltip2 = element("sl-tooltip");
    			div4 = element("div");
    			t22 = space();
    			a2 = element("a");
    			i3 = element("i");
    			t23 = space();
    			input1 = element("input");
    			t24 = space();
    			div7 = element("div");
    			label3 = element("label");
    			t25 = text("Hide");
    			t26 = space();
    			sl_tooltip3 = element("sl-tooltip");
    			div6 = element("div");
    			t27 = space();
    			a3 = element("a");
    			i4 = element("i");
    			t28 = space();
    			input2 = element("input");
    			t29 = space();
    			div9 = element("div");
    			label4 = element("label");
    			t30 = text("Add unallocated");
    			t31 = space();
    			sl_tooltip4 = element("sl-tooltip");
    			div8 = element("div");
    			t32 = space();
    			a4 = element("a");
    			i5 = element("i");
    			t33 = space();
    			input3 = element("input");
    			t34 = space();
    			div16 = element("div");
    			div12 = element("div");
    			label5 = element("label");
    			t35 = text("Include page");
    			t36 = space();
    			sl_tooltip5 = element("sl-tooltip");
    			div11 = element("div");
    			t37 = space();
    			a5 = element("a");
    			i6 = element("i");
    			t38 = space();
    			div13 = element("div");
    			div13.textContent = "";
    			t40 = space();
    			div15 = element("div");
    			input4 = element("input");
    			t41 = space();
    			span5 = element("span");
    			label6 = element("label");
    			t42 = text("After?");
    			t43 = space();
    			sl_tooltip6 = element("sl-tooltip");
    			div14 = element("div");
    			t44 = space();
    			a6 = element("a");
    			i7 = element("i");
    			t45 = space();
    			input5 = element("input");
    			t46 = space();
    			if (if_block2) if_block2.c();
    			t47 = space();
    			div21 = element("div");
    			div18 = element("div");
    			label7 = element("label");
    			t48 = text("Output page");
    			t49 = space();
    			sl_tooltip7 = element("sl-tooltip");
    			div17 = element("div");
    			t50 = space();
    			a7 = element("a");
    			i8 = element("i");
    			t51 = space();
    			div19 = element("div");
    			div19.textContent = "";
    			t53 = space();
    			div20 = element("div");
    			input6 = element("input");
    			t54 = space();
    			button = element("button");
    			t55 = text("Update");
    			t56 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(i0, "class", "icon-trash cc-delete-collection svelte-15ntxpt");
    			attr_dev(i0, "id", i0_id_value = "cc-collection-$" + /*collectionName*/ ctx[0] + "-delete");
    			add_location(i0, file$5, 362, 6, 16301);
    			attr_dev(span0, "class", "cc-collection-move svelte-15ntxpt");
    			add_location(span0, file$5, 345, 4, 15749);
    			attr_dev(p, "class", "svelte-15ntxpt");
    			add_location(p, file$5, 342, 2, 15682);
    			attr_dev(label0, "for", label0_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-collectionName");
    			attr_dev(label0, "class", "svelte-15ntxpt");
    			add_location(label0, file$5, 377, 6, 16706);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$5, 379, 8, 16807);
    			attr_dev(i1, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i1, file$5, 381, 10, 16949);
    			attr_dev(a0, "href", /*HELP*/ ctx[17].configName.url);
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$5, 380, 8, 16874);
    			set_custom_element_data(sl_tooltip0, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip0, file$5, 378, 6, 16785);
    			attr_dev(span1, "class", "cc-collection-label svelte-15ntxpt");
    			add_location(span1, file$5, 376, 4, 16664);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "id", input0_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-collectionName");
    			input0.value = /*collectionName*/ ctx[0];
    			attr_dev(input0, "class", "svelte-15ntxpt");
    			add_location(input0, file$5, 386, 6, 17087);
    			attr_dev(span2, "class", "cc-collection-input svelte-15ntxpt");
    			add_location(span2, file$5, 385, 4, 17045);
    			attr_dev(div1, "class", "cc-collection-form svelte-15ntxpt");
    			add_location(div1, file$5, 375, 2, 16626);
    			attr_dev(label1, "for", label1_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-representation");
    			attr_dev(label1, "class", "svelte-15ntxpt");
    			add_location(label1, file$5, 397, 6, 17367);
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$5, 401, 8, 17496);
    			attr_dev(i2, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i2, file$5, 409, 10, 17723);
    			attr_dev(a1, "href", /*HELP*/ ctx[17].configRepresentation.url);
    			attr_dev(a1, "rel", "noreferrer");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$5, 404, 8, 17595);
    			set_custom_element_data(sl_tooltip1, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip1, file$5, 400, 6, 17474);
    			attr_dev(span3, "class", "cc-collection-label svelte-15ntxpt");
    			add_location(span3, file$5, 396, 4, 17325);
    			attr_dev(select, "id", select_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-representation");
    			attr_dev(select, "class", "cc-collection-representation svelte-15ntxpt");
    			if (/*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["representation"] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[18].call(select));
    			add_location(select, file$5, 414, 6, 17861);
    			attr_dev(span4, "class", "cc-collection-input svelte-15ntxpt");
    			add_location(span4, file$5, 413, 4, 17819);
    			attr_dev(div3, "class", "cc-collection-form svelte-15ntxpt");
    			add_location(div3, file$5, 395, 2, 17287);
    			attr_dev(label2, "for", label2_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-default");
    			attr_dev(label2, "class", "svelte-15ntxpt");
    			add_location(label2, file$5, 432, 6, 18423);
    			attr_dev(div4, "slot", "content");
    			add_location(div4, file$5, 436, 8, 18545);
    			attr_dev(i3, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i3, file$5, 440, 10, 18715);
    			attr_dev(a2, "href", /*HELP*/ ctx[17].configDefault.url);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noreferrer");
    			add_location(a2, file$5, 439, 8, 18637);
    			set_custom_element_data(sl_tooltip2, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip2, file$5, 435, 6, 18523);
    			attr_dev(input1, "type", "checkbox");
    			attr_dev(input1, "id", input1_id_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-default");
    			input1.checked = input1_checked_value = /*$collectionsStore*/ ctx[6]["DEFAULT_ACTIVE_COLLECTION"] === /*collectionName*/ ctx[0];
    			attr_dev(input1, "class", "svelte-15ntxpt");
    			add_location(input1, file$5, 443, 6, 18800);
    			add_location(div5, file$5, 431, 4, 18410);
    			attr_dev(label3, "for", label3_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-hide");
    			attr_dev(label3, "class", "svelte-15ntxpt");
    			add_location(label3, file$5, 452, 6, 19108);
    			attr_dev(div6, "slot", "content");
    			add_location(div6, file$5, 454, 8, 19208);
    			attr_dev(i4, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i4, file$5, 458, 10, 19372);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "href", /*HELP*/ ctx[17].configHide.url);
    			attr_dev(a3, "rel", "noreferrer");
    			add_location(a3, file$5, 457, 8, 19297);
    			set_custom_element_data(sl_tooltip3, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip3, file$5, 453, 6, 19186);
    			attr_dev(input2, "type", "checkbox");
    			attr_dev(input2, "class", "cc-config-collection-hide svelte-15ntxpt");
    			input2.disabled = input2_disabled_value = /*$collectionsStore*/ ctx[6]["DEFAULT_ACTIVE_COLLECTION"] === /*collectionName*/ ctx[0];
    			add_location(input2, file$5, 461, 6, 19457);
    			attr_dev(div7, "class", "cc-collection-double-center svelte-15ntxpt");
    			add_location(div7, file$5, 451, 4, 19059);
    			attr_dev(label4, "for", label4_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-unallocated");
    			attr_dev(label4, "class", "svelte-15ntxpt");
    			add_location(label4, file$5, 471, 6, 19824);
    			attr_dev(div8, "slot", "content");
    			add_location(div8, file$5, 475, 8, 19958);
    			attr_dev(i5, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i5, file$5, 479, 10, 20136);
    			attr_dev(a4, "href", /*HELP*/ ctx[17].configUnallocated.url);
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "rel", "noreferrer");
    			add_location(a4, file$5, 478, 8, 20054);
    			set_custom_element_data(sl_tooltip4, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip4, file$5, 474, 6, 19936);
    			attr_dev(input3, "type", "checkbox");
    			attr_dev(input3, "id", input3_id_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-unallocated");
    			attr_dev(input3, "class", "svelte-15ntxpt");
    			add_location(input3, file$5, 482, 6, 20221);
    			add_location(div9, file$5, 470, 4, 19811);
    			attr_dev(div10, "class", "cc-collection-double svelte-15ntxpt");
    			add_location(div10, file$5, 430, 2, 18370);
    			attr_dev(label5, "for", label5_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-include-page");
    			attr_dev(label5, "class", "svelte-15ntxpt");
    			add_location(label5, file$5, 503, 6, 20833);
    			attr_dev(div11, "slot", "content");
    			add_location(div11, file$5, 507, 8, 20958);
    			attr_dev(i6, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i6, file$5, 515, 11, 21207);
    			attr_dev(a5, "id", "cc-about-include-page");
    			attr_dev(a5, "rel", "noreferrer");
    			attr_dev(a5, "target", "_blank");
    			attr_dev(a5, "href", /*HELP*/ ctx[17].configIncludePage.url);
    			add_location(a5, file$5, 510, 8, 21054);
    			set_custom_element_data(sl_tooltip5, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip5, file$5, 506, 6, 20936);
    			attr_dev(div12, "class", "cc-collection-two-line-header svelte-15ntxpt");
    			add_location(div12, file$5, 502, 4, 20782);
    			add_location(div13, file$5, 519, 4, 21302);
    			attr_dev(input4, "id", input4_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-includePage");
    			input4.value = input4_value_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includePage;
    			attr_dev(input4, "class", "svelte-15ntxpt");
    			add_location(input4, file$5, 521, 6, 21374);
    			attr_dev(label6, "for", label6_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-include-after");
    			attr_dev(label6, "class", "svelte-15ntxpt");
    			add_location(label6, file$5, 528, 8, 21617);
    			attr_dev(div14, "slot", "content");
    			add_location(div14, file$5, 532, 10, 21752);
    			attr_dev(i7, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i7, file$5, 541, 12, 22040);
    			attr_dev(a6, "id", "cc-about-include-after");
    			attr_dev(a6, "href", /*HELP*/ ctx[17].configIncludePageAfter.url);
    			attr_dev(a6, "target", "_blank");
    			attr_dev(a6, "rel", "noreferrer");
    			add_location(a6, file$5, 535, 10, 21859);
    			set_custom_element_data(sl_tooltip6, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip6, file$5, 531, 8, 21728);
    			attr_dev(input5, "type", "checkbox");
    			attr_dev(input5, "id", input5_id_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-include-after");
    			attr_dev(input5, "class", "cc-config-collection-include-after svelte-15ntxpt");
    			add_location(input5, file$5, 544, 8, 22131);
    			attr_dev(span5, "class", "cc-collection-label svelte-15ntxpt");
    			add_location(span5, file$5, 527, 6, 21573);
    			attr_dev(div15, "class", "cc-collection-two-line-body svelte-15ntxpt");
    			add_location(div15, file$5, 520, 4, 21325);
    			attr_dev(div16, "class", "cc-collection-two-line svelte-15ntxpt");
    			add_location(div16, file$5, 501, 2, 20740);
    			attr_dev(label7, "for", label7_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-output-page");
    			attr_dev(label7, "class", "svelte-15ntxpt");
    			add_location(label7, file$5, 567, 6, 23024);
    			attr_dev(div17, "slot", "content");
    			add_location(div17, file$5, 571, 8, 23147);
    			attr_dev(i8, "class", "icon-question cc-module-icon svelte-15ntxpt");
    			add_location(i8, file$5, 580, 10, 23410);
    			attr_dev(a7, "id", "cc-about-update-output-page");
    			attr_dev(a7, "target", "_blank");
    			attr_dev(a7, "href", /*HELP*/ ctx[17].configOutputPage.url);
    			attr_dev(a7, "rel", "noreferrer");
    			add_location(a7, file$5, 574, 8, 23242);
    			set_custom_element_data(sl_tooltip7, "class", "svelte-15ntxpt");
    			add_location(sl_tooltip7, file$5, 570, 6, 23125);
    			attr_dev(div18, "class", "cc-collection-two-line-header svelte-15ntxpt");
    			add_location(div18, file$5, 566, 4, 22973);
    			add_location(div19, file$5, 584, 4, 23505);
    			attr_dev(input6, "id", input6_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-outputPage");
    			input6.value = input6_value_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage;
    			attr_dev(input6, "class", "svelte-15ntxpt");
    			add_location(input6, file$5, 586, 6, 23577);
    			attr_dev(button, "id", button_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-output-page-update");
    			attr_dev(button, "class", "btn svelte-15ntxpt");
    			button.disabled = button_disabled_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage === "";
    			add_location(button, file$5, 591, 6, 23772);
    			attr_dev(div20, "class", "cc-collection-two-line-body svelte-15ntxpt");
    			add_location(div20, file$5, 585, 4, 23528);
    			attr_dev(div21, "class", "cc-collection-two-line svelte-15ntxpt");
    			add_location(div21, file$5, 565, 2, 22931);
    			attr_dev(div22, "class", "cc-existing-collection border border-trbl svelte-15ntxpt");
    			attr_dev(div22, "id", div22_id_value = "cc-collection-" + /*collectionName*/ ctx[0]);
    			add_location(div22, file$5, 338, 0, 15579);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div22, anchor);
    			append_dev(div22, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(p, t4);
    			append_dev(p, t5);
    			append_dev(p, span0);
    			if (if_block0) if_block0.m(span0, null);
    			append_dev(span0, t6);
    			if (if_block1) if_block1.m(span0, null);
    			append_dev(span0, t7);
    			append_dev(span0, i0);
    			append_dev(div22, t8);
    			append_dev(div22, div1);
    			append_dev(div1, span1);
    			append_dev(span1, label0);
    			append_dev(label0, t9);
    			append_dev(span1, t10);
    			append_dev(span1, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t11);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i1);
    			append_dev(div1, t12);
    			append_dev(div1, span2);
    			append_dev(span2, input0);
    			append_dev(div22, t13);
    			append_dev(div22, div3);
    			append_dev(div3, span3);
    			append_dev(span3, label1);
    			append_dev(label1, t14);
    			append_dev(span3, t15);
    			append_dev(span3, sl_tooltip1);
    			append_dev(sl_tooltip1, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t16);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i2);
    			append_dev(div3, t17);
    			append_dev(div3, span4);
    			append_dev(span4, select);
    			append_dev(select, t18);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["representation"]);
    			append_dev(div22, t19);
    			append_dev(div22, div10);
    			append_dev(div10, div5);
    			append_dev(div5, label2);
    			append_dev(label2, t20);
    			append_dev(div5, t21);
    			append_dev(div5, sl_tooltip2);
    			append_dev(sl_tooltip2, div4);
    			div4.innerHTML = raw2_value;
    			append_dev(sl_tooltip2, t22);
    			append_dev(sl_tooltip2, a2);
    			append_dev(a2, i3);
    			append_dev(div5, t23);
    			append_dev(div5, input1);
    			append_dev(div10, t24);
    			append_dev(div10, div7);
    			append_dev(div7, label3);
    			append_dev(label3, t25);
    			append_dev(div7, t26);
    			append_dev(div7, sl_tooltip3);
    			append_dev(sl_tooltip3, div6);
    			div6.innerHTML = raw3_value;
    			append_dev(sl_tooltip3, t27);
    			append_dev(sl_tooltip3, a3);
    			append_dev(a3, i4);
    			append_dev(div7, t28);
    			append_dev(div7, input2);
    			input2.checked = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["hide"];
    			append_dev(div10, t29);
    			append_dev(div10, div9);
    			append_dev(div9, label4);
    			append_dev(label4, t30);
    			append_dev(div9, t31);
    			append_dev(div9, sl_tooltip4);
    			append_dev(sl_tooltip4, div8);
    			div8.innerHTML = raw4_value;
    			append_dev(sl_tooltip4, t32);
    			append_dev(sl_tooltip4, a4);
    			append_dev(a4, i5);
    			append_dev(div9, t33);
    			append_dev(div9, input3);
    			input3.checked = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["unallocated"];
    			append_dev(div22, t34);
    			append_dev(div22, div16);
    			append_dev(div16, div12);
    			append_dev(div12, label5);
    			append_dev(label5, t35);
    			append_dev(div12, t36);
    			append_dev(div12, sl_tooltip5);
    			append_dev(sl_tooltip5, div11);
    			div11.innerHTML = raw5_value;
    			append_dev(sl_tooltip5, t37);
    			append_dev(sl_tooltip5, a5);
    			append_dev(a5, i6);
    			append_dev(div16, t38);
    			append_dev(div16, div13);
    			append_dev(div16, t40);
    			append_dev(div16, div15);
    			append_dev(div15, input4);
    			append_dev(div15, t41);
    			append_dev(div15, span5);
    			append_dev(span5, label6);
    			append_dev(label6, t42);
    			append_dev(span5, t43);
    			append_dev(span5, sl_tooltip6);
    			append_dev(sl_tooltip6, div14);
    			div14.innerHTML = raw6_value;
    			append_dev(sl_tooltip6, t44);
    			append_dev(sl_tooltip6, a6);
    			append_dev(a6, i7);
    			append_dev(span5, t45);
    			append_dev(span5, input5);
    			input5.checked = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includeAfter;
    			append_dev(div16, t46);
    			if (if_block2) if_block2.m(div16, null);
    			append_dev(div22, t47);
    			append_dev(div22, div21);
    			append_dev(div21, div18);
    			append_dev(div18, label7);
    			append_dev(label7, t48);
    			append_dev(div18, t49);
    			append_dev(div18, sl_tooltip7);
    			append_dev(sl_tooltip7, div17);
    			div17.innerHTML = raw7_value;
    			append_dev(sl_tooltip7, t50);
    			append_dev(sl_tooltip7, a7);
    			append_dev(a7, i8);
    			append_dev(div21, t51);
    			append_dev(div21, div19);
    			append_dev(div21, t53);
    			append_dev(div21, div20);
    			append_dev(div20, input6);
    			append_dev(div20, t54);
    			append_dev(div20, button);
    			append_dev(button, t55);
    			append_dev(div21, t56);
    			if (if_block3) if_block3.m(div21, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i0, "click", /*deleteCollection*/ ctx[14], false, false, false),
    					listen_dev(i0, "keydown", /*deleteCollection*/ ctx[14], false, false, false),
    					listen_dev(input0, "change", /*changeCollectionName*/ ctx[15], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[18]),
    					listen_dev(select, "change", /*change_handler*/ ctx[19], false, false, false),
    					listen_dev(input1, "click", /*changeDefaultCollection*/ ctx[11], false, false, false),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[20]),
    					listen_dev(input2, "change", /*change_handler_1*/ ctx[21], false, false, false),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[22]),
    					listen_dev(input3, "change", /*change_handler_2*/ ctx[23], false, false, false),
    					listen_dev(input4, "focusout", /*updatePageName*/ ctx[10], false, false, false),
    					listen_dev(input5, "click", /*click_handler*/ ctx[24], false, false, false),
    					listen_dev(input5, "keydown", /*keydown_handler*/ ctx[25], false, false, false),
    					listen_dev(input5, "change", /*input5_change_handler*/ ctx[26]),
    					listen_dev(input6, "focusout", /*updatePageName*/ ctx[10], false, false, false),
    					listen_dev(button, "click", /*click_handler_1*/ ctx[27], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*collectionName*/ 1) set_data_dev(t0, /*collectionName*/ ctx[0]);

    			if (/*order*/ ctx[3] > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(span0, t6);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*order*/ ctx[3] < /*numCollections*/ ctx[4] - 1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					if_block1.m(span0, t7);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && i0_id_value !== (i0_id_value = "cc-collection-$" + /*collectionName*/ ctx[0] + "-delete")) {
    				attr_dev(i0, "id", i0_id_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label0_for_value !== (label0_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-collectionName")) {
    				attr_dev(label0, "for", label0_for_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input0_id_value !== (input0_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-collectionName")) {
    				attr_dev(input0, "id", input0_id_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input0.value !== /*collectionName*/ ctx[0]) {
    				prop_dev(input0, "value", /*collectionName*/ ctx[0]);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label1_for_value !== (label1_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-representation")) {
    				attr_dev(label1, "for", label1_for_value);
    			}

    			if (dirty[0] & /*availableRepresentations*/ 512) {
    				each_value = /*availableRepresentations*/ ctx[9];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && select_id_value !== (select_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-representation")) {
    				attr_dev(select, "id", select_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577) {
    				select_option(select, /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["representation"]);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label2_for_value !== (label2_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-default")) {
    				attr_dev(label2, "for", label2_for_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input1_id_value !== (input1_id_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-default")) {
    				attr_dev(input1, "id", input1_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577 && input1_checked_value !== (input1_checked_value = /*$collectionsStore*/ ctx[6]["DEFAULT_ACTIVE_COLLECTION"] === /*collectionName*/ ctx[0])) {
    				prop_dev(input1, "checked", input1_checked_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label3_for_value !== (label3_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-hide")) {
    				attr_dev(label3, "for", label3_for_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577 && input2_disabled_value !== (input2_disabled_value = /*$collectionsStore*/ ctx[6]["DEFAULT_ACTIVE_COLLECTION"] === /*collectionName*/ ctx[0])) {
    				prop_dev(input2, "disabled", input2_disabled_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577) {
    				input2.checked = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["hide"];
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label4_for_value !== (label4_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-unallocated")) {
    				attr_dev(label4, "for", label4_for_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input3_id_value !== (input3_id_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-unallocated")) {
    				attr_dev(input3, "id", input3_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577) {
    				input3.checked = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]]["unallocated"];
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label5_for_value !== (label5_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-include-page")) {
    				attr_dev(label5, "for", label5_for_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input4_id_value !== (input4_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-includePage")) {
    				attr_dev(input4, "id", input4_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577 && input4_value_value !== (input4_value_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includePage) && input4.value !== input4_value_value) {
    				prop_dev(input4, "value", input4_value_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label6_for_value !== (label6_for_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-include-after")) {
    				attr_dev(label6, "for", label6_for_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input5_id_value !== (input5_id_value = "cc-config-collection-" + /*collectionName*/ ctx[0] + "-include-after")) {
    				attr_dev(input5, "id", input5_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577) {
    				input5.checked = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includeAfter;
    			}

    			if (!/*includePageExists*/ ctx[1] && /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].includePage) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$1(ctx);
    					if_block2.c();
    					if_block2.m(div16, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && label7_for_value !== (label7_for_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-output-page")) {
    				attr_dev(label7, "for", label7_for_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && input6_id_value !== (input6_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-outputPage")) {
    				attr_dev(input6, "id", input6_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577 && input6_value_value !== (input6_value_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage) && input6.value !== input6_value_value) {
    				prop_dev(input6, "value", input6_value_value);
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && button_id_value !== (button_id_value = "cc-collection-" + /*collectionName*/ ctx[0] + "-output-page-update")) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty[0] & /*$collectionsStore, collectionName, availableRepresentations*/ 577 && button_disabled_value !== (button_disabled_value = /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage === "")) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (!/*outputPageExists*/ ctx[2] && /*$collectionsStore*/ ctx[6]["COLLECTIONS"][/*collectionName*/ ctx[0]].outputPage !== "") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block$2(ctx);
    					if_block3.c();
    					if_block3.m(div21, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty[0] & /*collectionName, availableRepresentations*/ 513 && div22_id_value !== (div22_id_value = "cc-collection-" + /*collectionName*/ ctx[0])) {
    				attr_dev(div22, "id", div22_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div22);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	let $representationsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(5, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(6, $collectionsStore = $$value));
    	validate_store(representationsStore, 'representationsStore');
    	component_subscribe($$self, representationsStore, $$value => $$invalidate(28, $representationsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionConfiguration', slots, []);
    	let { collectionName } = $$props;
    	let { includePageExists } = $$props;
    	let { outputPageExists } = $$props;
    	let { order } = $$props;
    	let { numCollections } = $$props;
    	const dispatch = createEventDispatcher();

    	// Assume includePage and outputPage exist
    	/*  export let
      outputPageExists = true; */
    	["includePage", "outputPage"].forEach(pageType => {
    		if (!$collectionsStore["COLLECTIONS"][collectionName].hasOwnProperty(pageType)) {
    			set_store_value(collectionsStore, $collectionsStore["COLLECTIONS"][collectionName][pageType] = "", $collectionsStore);
    		}
    	});

    	const modules = getCollectionCanvasModules(collectionName);
    	let moduleCount = modules.length;
    	let moduleName = moduleCount === 1 ? "module" : "modules";
    	let availableRepresentations = Object.getOwnPropertyNames($representationsStore);

    	//  let defaultCollection = false
    	//  $: defaultCollection = $collectionsStore["DEFAULT_COLLECTION"] === collectionName
    	/**
     * @function updateIncludePageName
     * @param e
     * @description Called when user focuses out of the include page name input
     * element. Updates the value and the needToSave
     * The change in includePage should reactively set off checks for if the page
     * exists
     */
    	function updatePageName(e) {
    		// get the value of event.target.value
    		const value = e.target.value;

    		let id = e.target.id;

    		// id of the form cc-.*-<pageType> get pageType
    		let pageType = id.split("-")[3];

    		const oldValue = $collectionsStore["COLLECTIONS"][collectionName][pageType] || "";

    		if (["includePage", "outputPage"].includes(pageType)) {
    			if (value !== oldValue) {
    				//$collectionsStore["COLLECTIONS"][collectionName][pageType] = value;
    				//   $configStore["needToSaveCollections"] = true;
    				dispatch("message", {
    					msgType: "changeName",
    					pageType,
    					collectionName,
    					pageName: value
    				});
    			}
    		} else {
    			toastAlert(`Unknown page type ${pageType}`, "error");
    		}
    	}

    	function changeDefaultCollection(event) {
    		// TODO
    		// - but only if not already the default collection - maybe stopPropagation
    		// - also check to see if it's already hidden
    		// - also check existing status?
    		if (!event.srcElement.checked) {
    			event.preventDefault();

    			toastAlert(
    				`<p>There must always be a default collection. 
        Change the default collection by selecting another collection as the new default.</p>`,
    				"warning"
    			);

    			return false;
    		}

    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    		set_store_value(collectionsStore, $collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = collectionName, $collectionsStore);
    	}

    	/**
     * @function moveCollectionUp
     * @description Move the collection earlier in the order by re-arranging
     * the collections order array
     */
    	function moveCollectionUp() {
    		// get the index of collectionName in $collectionsStore['COLLECTIONS_ORDER']
    		let index = $collectionsStore["COLLECTIONS_ORDER"].indexOf(collectionName);

    		// remove collectionName
    		$collectionsStore["COLLECTIONS_ORDER"].splice(index, 1);

    		// insert collectionName at index - 1
    		$collectionsStore["COLLECTIONS_ORDER"].splice(index - 1, 0, collectionName);

    		collectionsStore.set($collectionsStore);
    		set_store_value(collectionsStore, $collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = collectionName, $collectionsStore);
    	}

    	/**
     * @function moveCollectionDown
     * @description Move the collection later in the order by re-arranging
     * the collections order array
     */
    	function moveCollectionDown() {
    		// get the index of collectionName in $collectionsStore['COLLECTIONS_ORDER']
    		let index = $collectionsStore["COLLECTIONS_ORDER"].indexOf(collectionName);

    		// remove collectionName
    		$collectionsStore["COLLECTIONS_ORDER"].splice(index, 1);

    		// insert collectionName at index + 1
    		$collectionsStore["COLLECTIONS_ORDER"].splice(index + 1, 0, collectionName);

    		collectionsStore.set($collectionsStore);
    		set_store_value(collectionsStore, $collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = collectionName, $collectionsStore);
    	}

    	/**
     * @function deleteCollection
     * @description Delete the collection by
     * 1. Generating an alert to check user really wants to remove it
     * 2. Remove the collection from $collectionsStore["COLLECTIONS"]
     * 3. Remove the collection from $collectionsStore["COLLECTIONS_ORDER"]
     * 4. If currently the DEFAULT_ACTIVE_COLLECTION Change the DEFAULT_ACTIVE_COLLECTION to the first collection left
     * 5. Set the collection attribute for all modules in the collection to "none"
     */
    	function deleteCollection() {
    		// confirm that they actually want to delete the collection
    		ccConfirm(`<p>Are you sure you want to delete the collection <em>${collectionName}</em>?</p>`).then(ok => {
    			if (ok) {
    				// remove the collection from $collectionsStore["COLLECTIONS_ORDER"]
    				let index = $collectionsStore["COLLECTIONS_ORDER"].indexOf(collectionName);

    				$collectionsStore["COLLECTIONS_ORDER"].splice(index, 1);
    				collectionsStore.set($collectionsStore);

    				// if currently the DEFAULT_ACTIVE_COLLECTION Change the DEFAULT_ACTIVE_COLLECTION to the first collection left
    				if ($collectionsStore["DEFAULT_ACTIVE_COLLECTION"] === collectionName) {
    					set_store_value(collectionsStore, $collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = $collectionsStore["COLLECTIONS_ORDER"][0], $collectionsStore);
    				}

    				// change the currentCollection
    				if ($configStore["currentCollection"] === collectionName) {
    					set_store_value(configStore, $configStore["currentCollection"] = $collectionsStore["DEFAULT_ACTIVE_COLLECTION"], $configStore);
    				}

    				// set the collection attribute for all modules in the collection to "none"
    				for (const moduleId in $collectionsStore["MODULES"]) {
    					if ($collectionsStore["MODULES"][moduleId].collection === collectionName) {
    						set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].collection = null, $collectionsStore);
    					}
    				}

    				// remove the collection from $collectionsStore["COLLECTIONS"]
    				delete $collectionsStore["COLLECTIONS"][collectionName];
    			} //$collectionsStore = $collectionsStore;
    			// TODO is this really needed?
    		}); //$collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = collectionName;
    	}

    	/**
     * @function changeCollectionName
     * @description Called when a collection name has been changed, need to
     * 1. Generating an alert to check user really wants to change the name
     * 2. Remove the collection from $collectionsStore["COLLECTIONS"]
     * 3. Remove the collection from $collectionsStore["COLLECTIONS_ORDER"]
     * 4. If currently the DEFAULT_ACTIVE_COLLECTION Change the DEFAULT_ACTIVE_COLLECTION to the first collection left
     * 5. Set the collection attribute for all modules in the collection to "none"
     *
     */
    	function changeCollectionName(event) {
    		const newCollectionName = event.target.value;

    		// confirm that they actually want to delete the collection
    		ccConfirm(`<p>Are you sure you want to change the collection's name from 
          <em>${collectionName}</em> to <em>${newCollectionName}</em></p>`).then(ok => {
    			if (!ok) {
    				event.target.value = collectionName;
    			} else {
    				// modify collectionName in array $collectionsStore["COLLECTIONS_ORDER"] to newCollectionName
    				let index = $collectionsStore["COLLECTIONS_ORDER"].indexOf(collectionName);

    				set_store_value(collectionsStore, $collectionsStore["COLLECTIONS_ORDER"][index] = newCollectionName, $collectionsStore);

    				// if currently the DEFAULT_ACTIVE_COLLECTION Change the DEFAULT_ACTIVE_COLLECTION to the first collection left
    				if ($collectionsStore["DEFAULT_ACTIVE_COLLECTION"] === collectionName) {
    					set_store_value(collectionsStore, $collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = newCollectionName, $collectionsStore);
    				}

    				// change the currentCollection
    				if ($configStore["currentCollection"] === collectionName) {
    					set_store_value(configStore, $configStore["currentCollection"] = $collectionsStore["DEFAULT_ACTIVE_COLLECTION"], $configStore);
    				}

    				// set the collection attribute for all modules in the collection to newCollectionName
    				for (const moduleId in $collectionsStore["MODULES"]) {
    					if ($collectionsStore["MODULES"][moduleId].collection === collectionName) {
    						set_store_value(collectionsStore, $collectionsStore["MODULES"][moduleId].collection = newCollectionName, $collectionsStore);
    					}
    				}

    				// rename the collectionName key in $collectionsStore["COLLECTIONS"] to newCollectionName
    				set_store_value(collectionsStore, $collectionsStore["COLLECTIONS"][newCollectionName] = $collectionsStore["COLLECTIONS"][collectionName], $collectionsStore);

    				delete $collectionsStore["COLLECTIONS"][collectionName];
    				set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    			}
    		});
    	}

    	/**
     * @function doesIncludePageExists
     * @param pageName - name of the page to tried to retrive
     * @param msg - message back from canvas API { status: res: body }
     * @description Call back after trying to get the page object for an include
     * page
     * If not turn give an alert
     */
    	/*  function doesIncludePageExist(pageName, msg) {
      const pageObject = msg.body;

      includePageName[collectionName] = pageName;

      if (!pageObject) {
        toastAlert(
          `<p>Unable to retrieve the include page</p>
    <p style="margin-left: 1em">${pageName}</p>
    <p>for the collection</p>
    <p style="margin-left: 1em">${collectionName}</p>`,
          "danger",
          3000
        );
        includePageExists[collectionName] = false;
      } else {
        includePageExists[collectionName] = true;
      }
    } */
    	/**
     * @function doesOutputPageExists
     * @param pageName
     * @param msg
     * @description Called after Canvas API call returns a page Object. Set
     * outputPageExists and other variables appropriately
     * No alerts for this (unlike include page) because if the output page
     * doesn't exist it will be created
     */
    	/*  function doesOutputPageExist(pageName, msg) {
      const pageObject = msg.body;
      outputPageName[collectionName] = pageName;
      if (!pageObject) {
        outputPageExists[collectionName] = false;
      } else {
        outputPageExists[collectionName] = true;
      }
    } */
    	/**
     * @function updateOutputPage
     * @param outputPageName
     * @param collectionName
     * @description Should update the specified Canvas page with the representation
     * of a specific collection
     */
    	function updateOutputPage(collectionName) {
    		const updateController = new updatePageController(collectionName, checkOutputPageExists);
    		updateController.execute();
    	}

    	/**
     * @function checkOutputPageExists
     * @param updateController
     * @description Need to dispatch a updatePage msg
     * for every page updated
     */
    	function checkOutputPageExists(updateController) {
    		// get the name of the collection modified (will only be one)
    		//const collectionNames = updateController.getCollectionNamesUpdated();
    		const pageNames = updateController.getPageNamesUpdated();

    		pageNames.forEach(pageName => {
    			dispatch("message", {
    				msgType: "updatePage",
    				pageType: "outputPage",
    				pageName
    			});
    		});

    		toastAlert(`<p>Updating the following pages</p>
      ${pageNames.map(pageName => `<p style="margin-left: 1em">${pageName}</p>`).join("")}`);
    	}

    	/**
     * @function applyModuleLabels
     * @param collectionName
     * @description Call the moduleLabelApplicator to update the names for
     * all Canvas modules in the collection based on their labels
     *
     * TODO on hold for version 1 for revision about if/how it might be more
     * useful
     */
    	/*  function applyModuleLabels(collectionName : string) {
      const labelApplicator = new moduleLabelApplicator(collectionName);
      labelApplicator.execute();
    } */
    	const HELP = {
    		configName: {
    			tooltip: `A collection's name will be used to navigate between collections`,
    			url: "https://djplaner.github.io/canvas-collections/getting-started/configure/collections/#collection-properties"
    		},
    		configRepresentation: {
    			tooltip: `Specify how the collection will be displayed by choosing one of the available representations. Representations can be changed at any time.`,
    			url: "https://djplaner.github.io/canvas-collections/reference/representations/overview/"
    		},
    		configDefault: {
    			tooltip: `The default collection will be the first people see when the visit for the first time.`,
    			url: "https://djplaner.github.io/canvas-collections/getting-started/configure/collections/#collection-properties"
    		},
    		configHide: {
    			tooltip: `<p>Make collection invisible to students. 
		(Note: can't hide the default collection)</p>
		<p><i class="icon-warning"></i> Also unpublish all the collection's modules to be ensure they are hidden.`,
    			url: "https://djplaner.github.io/canvas-collections/getting-started/configure/collections/#collection-properties"
    		},
    		configUnallocated: {
    			tooltip: `<p>When students view this collection, include modules not allocated to any collection.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#hide-a-collection"
    		},
    		configIncludePage: {
    			tooltip: `Specify the name of an existing Canvas page and the content of that page
		will be displayed before the current collection's representation 
		(it is <strong>included</strong>)`,
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#include-page"
    		},
    		configIncludePageAfter: {
    			tooltip: `<p>By default, include page contents placed <em>before</em> the collection. When selected
		will place the include page contents <em>after</em> the collection.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#include-page"
    		},
    		configOutputPage: {
    			tooltip: `Update the <em>output page</em> with the collection's current representation.
		<p><strong>Note:</strong> This is how you can use Collections with students without it being
		installed by your institution.</p>
		`,
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#output-page"
    		},
    		configApplyLabels: {
    			tooltip: `<p> <strong>Warning:</strong> This feature is experimental, under construction, and
		potentially destructive. Only use as suggested and if you're certain.</p>
		<p>Modify the names of Canvas modules by apply the Collection's label/number</p>
		`,
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#apply-module-labels"
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (collectionName === undefined && !('collectionName' in $$props || $$self.$$.bound[$$self.$$.props['collectionName']])) {
    			console.warn("<CollectionConfiguration> was created without expected prop 'collectionName'");
    		}

    		if (includePageExists === undefined && !('includePageExists' in $$props || $$self.$$.bound[$$self.$$.props['includePageExists']])) {
    			console.warn("<CollectionConfiguration> was created without expected prop 'includePageExists'");
    		}

    		if (outputPageExists === undefined && !('outputPageExists' in $$props || $$self.$$.bound[$$self.$$.props['outputPageExists']])) {
    			console.warn("<CollectionConfiguration> was created without expected prop 'outputPageExists'");
    		}

    		if (order === undefined && !('order' in $$props || $$self.$$.bound[$$self.$$.props['order']])) {
    			console.warn("<CollectionConfiguration> was created without expected prop 'order'");
    		}

    		if (numCollections === undefined && !('numCollections' in $$props || $$self.$$.bound[$$self.$$.props['numCollections']])) {
    			console.warn("<CollectionConfiguration> was created without expected prop 'numCollections'");
    		}
    	});

    	const writable_props = [
    		'collectionName',
    		'includePageExists',
    		'outputPageExists',
    		'order',
    		'numCollections'
    	];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollectionConfiguration> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		$collectionsStore["COLLECTIONS"][collectionName]["representation"] = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(9, availableRepresentations);
    	}

    	const change_handler = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input2_change_handler() {
    		$collectionsStore["COLLECTIONS"][collectionName]["hide"] = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(9, availableRepresentations);
    	}

    	const change_handler_1 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input3_change_handler() {
    		$collectionsStore["COLLECTIONS"][collectionName]["unallocated"] = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(9, availableRepresentations);
    	}

    	const change_handler_2 = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const click_handler = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	const keydown_handler = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function input5_change_handler() {
    		$collectionsStore["COLLECTIONS"][collectionName].includeAfter = this.checked;
    		collectionsStore.set($collectionsStore);
    		$$invalidate(9, availableRepresentations);
    	}

    	const click_handler_1 = () => {
    		updateOutputPage(collectionName);
    	};

    	$$self.$$set = $$props => {
    		if ('collectionName' in $$props) $$invalidate(0, collectionName = $$props.collectionName);
    		if ('includePageExists' in $$props) $$invalidate(1, includePageExists = $$props.includePageExists);
    		if ('outputPageExists' in $$props) $$invalidate(2, outputPageExists = $$props.outputPageExists);
    		if ('order' in $$props) $$invalidate(3, order = $$props.order);
    		if ('numCollections' in $$props) $$invalidate(4, numCollections = $$props.numCollections);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		representationsStore,
    		updatePageController,
    		getCollectionCanvasModules,
    		getPageName,
    		toastAlert,
    		ccConfirm,
    		createEventDispatcher,
    		collectionName,
    		includePageExists,
    		outputPageExists,
    		order,
    		numCollections,
    		dispatch,
    		modules,
    		moduleCount,
    		moduleName,
    		availableRepresentations,
    		updatePageName,
    		changeDefaultCollection,
    		moveCollectionUp,
    		moveCollectionDown,
    		deleteCollection,
    		changeCollectionName,
    		updateOutputPage,
    		checkOutputPageExists,
    		HELP,
    		$configStore,
    		$collectionsStore,
    		$representationsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collectionName' in $$props) $$invalidate(0, collectionName = $$props.collectionName);
    		if ('includePageExists' in $$props) $$invalidate(1, includePageExists = $$props.includePageExists);
    		if ('outputPageExists' in $$props) $$invalidate(2, outputPageExists = $$props.outputPageExists);
    		if ('order' in $$props) $$invalidate(3, order = $$props.order);
    		if ('numCollections' in $$props) $$invalidate(4, numCollections = $$props.numCollections);
    		if ('moduleCount' in $$props) $$invalidate(7, moduleCount = $$props.moduleCount);
    		if ('moduleName' in $$props) $$invalidate(8, moduleName = $$props.moduleName);
    		if ('availableRepresentations' in $$props) $$invalidate(9, availableRepresentations = $$props.availableRepresentations);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		collectionName,
    		includePageExists,
    		outputPageExists,
    		order,
    		numCollections,
    		$configStore,
    		$collectionsStore,
    		moduleCount,
    		moduleName,
    		availableRepresentations,
    		updatePageName,
    		changeDefaultCollection,
    		moveCollectionUp,
    		moveCollectionDown,
    		deleteCollection,
    		changeCollectionName,
    		updateOutputPage,
    		HELP,
    		select_change_handler,
    		change_handler,
    		input2_change_handler,
    		change_handler_1,
    		input3_change_handler,
    		change_handler_2,
    		click_handler,
    		keydown_handler,
    		input5_change_handler,
    		click_handler_1
    	];
    }

    class CollectionConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$5,
    			create_fragment$5,
    			safe_not_equal,
    			{
    				collectionName: 0,
    				includePageExists: 1,
    				outputPageExists: 2,
    				order: 3,
    				numCollections: 4
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionConfiguration",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get collectionName() {
    		throw new Error("<CollectionConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collectionName(value) {
    		throw new Error("<CollectionConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get includePageExists() {
    		throw new Error("<CollectionConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set includePageExists(value) {
    		throw new Error("<CollectionConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outputPageExists() {
    		throw new Error("<CollectionConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outputPageExists(value) {
    		throw new Error("<CollectionConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get order() {
    		throw new Error("<CollectionConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set order(value) {
    		throw new Error("<CollectionConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get numCollections() {
    		throw new Error("<CollectionConfiguration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set numCollections(value) {
    		throw new Error("<CollectionConfiguration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Configuration\ExistingCollections.svelte generated by Svelte v3.55.0 */
    const file$4 = "src\\components\\Configuration\\ExistingCollections.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[8] = list;
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (28:2) {#if $collectionsStore["COLLECTIONS_ORDER"].length === 0}
    function create_if_block$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No collections have been defined";
    			attr_dev(p, "class", "svelte-15u04t7");
    			add_location(p, file$4, 28, 4, 932);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(28:2) {#if $collectionsStore[\\\"COLLECTIONS_ORDER\\\"].length === 0}",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#each $collectionsStore["COLLECTIONS_ORDER"] as collectionName, i}
    function create_each_block$2(ctx) {
    	let collectionconfiguration;
    	let updating_includePageExists;
    	let updating_outputPageExists;
    	let current;

    	function collectionconfiguration_includePageExists_binding(value) {
    		/*collectionconfiguration_includePageExists_binding*/ ctx[4](value, /*collectionName*/ ctx[7]);
    	}

    	function collectionconfiguration_outputPageExists_binding(value) {
    		/*collectionconfiguration_outputPageExists_binding*/ ctx[5](value, /*collectionName*/ ctx[7]);
    	}

    	let collectionconfiguration_props = {
    		collectionName: /*collectionName*/ ctx[7],
    		order: /*i*/ ctx[9],
    		numCollections: /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"].length
    	};

    	if (/*includePageExists*/ ctx[0][/*collectionName*/ ctx[7]] !== void 0) {
    		collectionconfiguration_props.includePageExists = /*includePageExists*/ ctx[0][/*collectionName*/ ctx[7]];
    	}

    	if (/*outputPageExists*/ ctx[1][/*collectionName*/ ctx[7]] !== void 0) {
    		collectionconfiguration_props.outputPageExists = /*outputPageExists*/ ctx[1][/*collectionName*/ ctx[7]];
    	}

    	collectionconfiguration = new CollectionConfiguration({
    			props: collectionconfiguration_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(collectionconfiguration, 'includePageExists', collectionconfiguration_includePageExists_binding, /*includePageExists*/ ctx[0][/*collectionName*/ ctx[7]]));
    	binding_callbacks.push(() => bind(collectionconfiguration, 'outputPageExists', collectionconfiguration_outputPageExists_binding, /*outputPageExists*/ ctx[1][/*collectionName*/ ctx[7]]));
    	collectionconfiguration.$on("message", /*message_handler*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(collectionconfiguration.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(collectionconfiguration, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const collectionconfiguration_changes = {};
    			if (dirty & /*$collectionsStore*/ 4) collectionconfiguration_changes.collectionName = /*collectionName*/ ctx[7];
    			if (dirty & /*$collectionsStore*/ 4) collectionconfiguration_changes.numCollections = /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"].length;

    			if (!updating_includePageExists && dirty & /*includePageExists, $collectionsStore*/ 5) {
    				updating_includePageExists = true;
    				collectionconfiguration_changes.includePageExists = /*includePageExists*/ ctx[0][/*collectionName*/ ctx[7]];
    				add_flush_callback(() => updating_includePageExists = false);
    			}

    			if (!updating_outputPageExists && dirty & /*outputPageExists, $collectionsStore*/ 6) {
    				updating_outputPageExists = true;
    				collectionconfiguration_changes.outputPageExists = /*outputPageExists*/ ctx[1][/*collectionName*/ ctx[7]];
    				add_flush_callback(() => updating_outputPageExists = false);
    			}

    			collectionconfiguration.$set(collectionconfiguration_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collectionconfiguration.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collectionconfiguration.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(collectionconfiguration, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(31:2) {#each $collectionsStore[\\\"COLLECTIONS_ORDER\\\"] as collectionName, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let strong;
    	let t1;
    	let sl_tooltip;
    	let div;
    	let raw_value = /*HELP*/ ctx[3].existing.tooltip + "";
    	let t2;
    	let a;
    	let i;
    	let t3;
    	let t4;
    	let each_1_anchor;
    	let current;
    	let if_block = /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"].length === 0 && create_if_block$1(ctx);
    	let each_value = /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			strong = element("strong");
    			strong.textContent = "Existing Collections";
    			t1 = space();
    			sl_tooltip = element("sl-tooltip");
    			div = element("div");
    			t2 = space();
    			a = element("a");
    			i = element("i");
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			add_location(strong, file$4, 13, 2, 515);
    			attr_dev(div, "slot", "content");
    			add_location(div, file$4, 15, 8, 583);
    			attr_dev(i, "class", "icon-question cc-module-icon");
    			add_location(i, file$4, 23, 10, 786);
    			attr_dev(a, "href", /*HELP*/ ctx[3].existing.url);
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$4, 18, 8, 670);
    			add_location(sl_tooltip, file$4, 14, 7, 561);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, sl_tooltip, anchor);
    			append_dev(sl_tooltip, div);
    			div.innerHTML = raw_value;
    			append_dev(sl_tooltip, t2);
    			append_dev(sl_tooltip, a);
    			append_dev(a, i);
    			insert_dev(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t4, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"].length === 0) {
    				if (if_block) ; else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(t4.parentNode, t4);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$collectionsStore, includePageExists, outputPageExists*/ 7) {
    				each_value = /*$collectionsStore*/ ctx[2]["COLLECTIONS_ORDER"];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(sl_tooltip);
    			if (detaching) detach_dev(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t4);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $collectionsStore;
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(2, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ExistingCollections', slots, []);
    	let { includePageExists = {} } = $$props;
    	let { outputPageExists = {} } = $$props;

    	const HELP = {
    		existing: {
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#existing-collections",
    			tooltip: "<p>The collections already defined for this course.</p>"
    		}
    	};

    	const writable_props = ['includePageExists', 'outputPageExists'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExistingCollections> was created with unknown prop '${key}'`);
    	});

    	function collectionconfiguration_includePageExists_binding(value, collectionName) {
    		if ($$self.$$.not_equal(includePageExists[collectionName], value)) {
    			includePageExists[collectionName] = value;
    			$$invalidate(0, includePageExists);
    		}
    	}

    	function collectionconfiguration_outputPageExists_binding(value, collectionName) {
    		if ($$self.$$.not_equal(outputPageExists[collectionName], value)) {
    			outputPageExists[collectionName] = value;
    			$$invalidate(1, outputPageExists);
    		}
    	}

    	function message_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('includePageExists' in $$props) $$invalidate(0, includePageExists = $$props.includePageExists);
    		if ('outputPageExists' in $$props) $$invalidate(1, outputPageExists = $$props.outputPageExists);
    	};

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		CollectionConfiguration,
    		includePageExists,
    		outputPageExists,
    		HELP,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('includePageExists' in $$props) $$invalidate(0, includePageExists = $$props.includePageExists);
    		if ('outputPageExists' in $$props) $$invalidate(1, outputPageExists = $$props.outputPageExists);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		includePageExists,
    		outputPageExists,
    		$collectionsStore,
    		HELP,
    		collectionconfiguration_includePageExists_binding,
    		collectionconfiguration_outputPageExists_binding,
    		message_handler
    	];
    }

    class ExistingCollections extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			includePageExists: 0,
    			outputPageExists: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExistingCollections",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get includePageExists() {
    		throw new Error("<ExistingCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set includePageExists(value) {
    		throw new Error("<ExistingCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outputPageExists() {
    		throw new Error("<ExistingCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outputPageExists(value) {
    		throw new Error("<ExistingCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Configuration\NewCollection.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1$1 } = globals;
    const file$3 = "src\\components\\Configuration\\NewCollection.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (106:6) {#each availableRepresentations as representation}
    function create_each_block$1(ctx) {
    	let option;
    	let t_value = /*representation*/ ctx[1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*representation*/ ctx[1];
    			option.value = option.__value;
    			add_location(option, file$3, 106, 8, 3953);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(106:6) {#each availableRepresentations as representation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let strong;
    	let t1;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[4].newCollection.tooltip + "";
    	let t2;
    	let a0;
    	let i0;
    	let t3;
    	let div4;
    	let div1;
    	let input;
    	let t4;
    	let div3;
    	let label;
    	let t6;
    	let sl_tooltip1;
    	let div2;
    	let raw1_value = /*HELP*/ ctx[4].representation.tooltip + "";
    	let t7;
    	let a1;
    	let i1;
    	let t8;
    	let select;
    	let t9;
    	let fieldset;
    	let button;
    	let mounted;
    	let dispose;
    	let each_value = /*availableRepresentations*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			strong = element("strong");
    			strong.textContent = "Add a new Collection";
    			t1 = space();
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t2 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t3 = space();
    			div4 = element("div");
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			div3 = element("div");
    			label = element("label");
    			label.textContent = "Representation";
    			t6 = space();
    			sl_tooltip1 = element("sl-tooltip");
    			div2 = element("div");
    			t7 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t8 = space();
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			fieldset = element("fieldset");
    			button = element("button");
    			button.textContent = "Add";
    			add_location(strong, file$3, 69, 0, 2795);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$3, 71, 2, 2850);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$3, 73, 4, 2986);
    			attr_dev(a0, "href", /*HELP*/ ctx[4].newCollection.url);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			add_location(a0, file$3, 72, 2, 2914);
    			add_location(sl_tooltip0, file$3, 70, 0, 2834);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", "cc-config-new-collection-name");
    			attr_dev(input, "placeholder", "Name for new collection");
    			attr_dev(input, "class", "svelte-5ctvi");
    			add_location(input, file$3, 79, 4, 3174);
    			attr_dev(div1, "class", "ic-Form-control");
    			set_style(div1, "margin-bottom", "0px");
    			add_location(div1, file$3, 78, 2, 3112);
    			attr_dev(label, "for", "cc-config-new-collection-representation");
    			attr_dev(label, "class", "svelte-5ctvi");
    			add_location(label, file$3, 88, 4, 3393);
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$3, 90, 4, 3492);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$3, 96, 6, 3661);
    			attr_dev(a1, "href", /*HELP*/ ctx[4].representation.url);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			add_location(a1, file$3, 91, 4, 3559);
    			add_location(sl_tooltip1, file$3, 89, 4, 3474);
    			attr_dev(select, "id", "cc-config-new-collection-representation");
    			attr_dev(select, "class", "cc-collection-representation svelte-5ctvi");
    			if (/*representation*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[6].call(select));
    			add_location(select, file$3, 100, 4, 3740);
    			attr_dev(div3, "class", "cc-collection-representation svelte-5ctvi");
    			add_location(div3, file$3, 87, 2, 3345);
    			attr_dev(button, "class", "btn btn-primary svelte-5ctvi");
    			attr_dev(button, "id", "cc-config-new-collection-button");
    			add_location(button, file$3, 112, 4, 4119);
    			attr_dev(fieldset, "class", "ic-Fieldset ic-Fieldset--radio-checkbox");
    			add_location(fieldset, file$3, 111, 2, 4055);
    			attr_dev(div4, "class", "cc-config-collection border border-trbl svelte-5ctvi");
    			add_location(div4, file$3, 77, 0, 3055);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, sl_tooltip0, anchor);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t2);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*collectionName*/ ctx[0]);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, label);
    			append_dev(div3, t6);
    			append_dev(div3, sl_tooltip1);
    			append_dev(sl_tooltip1, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t7);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(div3, t8);
    			append_dev(div3, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*representation*/ ctx[1]);
    			append_dev(div4, t9);
    			append_dev(div4, fieldset);
    			append_dev(fieldset, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[5]),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[6]),
    					listen_dev(button, "click", stop_propagation(/*addCollection*/ ctx[3]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*collectionName*/ 1 && input.value !== /*collectionName*/ ctx[0]) {
    				set_input_value(input, /*collectionName*/ ctx[0]);
    			}

    			if (dirty & /*availableRepresentations*/ 4) {
    				each_value = /*availableRepresentations*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*representation, availableRepresentations*/ 6) {
    				select_option(select, /*representation*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(sl_tooltip0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function createNewCollection() {
    } // loop through all fields in DEFAULT_NEW_COLLECTION and 

    function instance$3($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	let $representationsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(7, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(8, $collectionsStore = $$value));
    	validate_store(representationsStore, 'representationsStore');
    	component_subscribe($$self, representationsStore, $$value => $$invalidate(9, $representationsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NewCollection', slots, []);
    	let collectionName = "";
    	let representation = "";
    	let availableRepresentations = Object.getOwnPropertyNames($representationsStore);

    	const DEFAULT_NEW_COLLECTION = {
    		name: "",
    		representation: "",
    		outputPage: "",
    		hide: false,
    		includePage: "",
    		includeAfter: false
    	};

    	/**
     * @function addCollection
     * @description Add a new collection to Collections, including
     * - check first that collectionName and representation are not empty
     * - add collectionName to COLLECTIONS_ORDER (at the end)
     * - create new collection in COLLECTIONS
     * - set needToSaveCollections to true
     */
    	function addCollection() {
    		if (collectionName === "" || representation === "") {
    			if (collectionName === "") {
    				toastAlert(`<p>Please enter a name for the new collection</p>`, "danger");
    			}

    			if (representation === "") {
    				toastAlert("<p>Please select a representation for the new collection</p>", "danger");
    			}

    			return;
    		}

    		// make sure collectionName doesn't match one of the existing collections
    		if ($collectionsStore["COLLECTIONS"][collectionName]) {
    			toastAlert(`<p>Collection name <strong>${collectionName}</strong> already exists</p>`, "danger");
    			return;
    		}

    		// create new collection in COLLECTIONS
    		//let newCollection = createNewCollection()
    		let newCollection = Object.assign({}, DEFAULT_NEW_COLLECTION);

    		newCollection.name = collectionName;
    		newCollection.representation = representation;
    		set_store_value(collectionsStore, $collectionsStore["COLLECTIONS"][collectionName] = newCollection, $collectionsStore);

    		// add collectionName to COLLECTIONS_ORDER (at the end)
    		if ($collectionsStore["DEFAULT_ACTIVE_COLLECTION"] === "") {
    			set_store_value(collectionsStore, $collectionsStore["DEFAULT_ACTIVE_COLLECTION"] = collectionName, $collectionsStore);
    		}

    		$collectionsStore["COLLECTIONS_ORDER"].push(collectionName);

    		// reset the value of the input/select
    		$$invalidate(0, collectionName = "");

    		$$invalidate(1, representation = "");

    		// set needToSaveCollections to true
    		set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);
    	}

    	const HELP = {
    		newCollection: {
    			url: "https://djplaner.github.io/canvas-collections/reference/collections/overview/#add-a-new-collection",
    			tooltip: "<p>Create a new collection</p>"
    		},
    		representation: {
    			url: "https://djplaner.github.io/canvas-collections/reference/representations/overview/",
    			tooltip: "<p>Choose an initial representation. Can be changed later.</p>"
    		}
    	};

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NewCollection> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		collectionName = this.value;
    		$$invalidate(0, collectionName);
    	}

    	function select_change_handler() {
    		representation = select_value(this);
    		$$invalidate(1, representation);
    		$$invalidate(2, availableRepresentations);
    	}

    	$$self.$capture_state = () => ({
    		representationsStore,
    		collectionsStore,
    		configStore,
    		toastAlert,
    		collectionName,
    		representation,
    		availableRepresentations,
    		DEFAULT_NEW_COLLECTION,
    		addCollection,
    		createNewCollection,
    		HELP,
    		$configStore,
    		$collectionsStore,
    		$representationsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collectionName' in $$props) $$invalidate(0, collectionName = $$props.collectionName);
    		if ('representation' in $$props) $$invalidate(1, representation = $$props.representation);
    		if ('availableRepresentations' in $$props) $$invalidate(2, availableRepresentations = $$props.availableRepresentations);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		collectionName,
    		representation,
    		availableRepresentations,
    		addCollection,
    		HELP,
    		input_input_handler,
    		select_change_handler
    	];
    }

    class NewCollection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewCollection",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\components\Configuration\FullClaytons.svelte generated by Svelte v3.55.0 */
    const file$2 = "src\\components\\Configuration\\FullClaytons.svelte";

    function create_fragment$2(ctx) {
    	let div5;
    	let div1;
    	let strong;
    	let t1;
    	let sl_tooltip0;
    	let div0;
    	let raw0_value = /*HELP*/ ctx[1].fullClaytons.tooltip + "";
    	let t2;
    	let a0;
    	let i0;
    	let t3;
    	let div4;
    	let label;
    	let t5;
    	let sl_tooltip1;
    	let div2;
    	let raw1_value = /*HELP*/ ctx[1].navBarOptions.tooltip + "";
    	let t6;
    	let a1;
    	let i1;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div1 = element("div");
    			strong = element("strong");
    			strong.textContent = "Full \"Claytons\"";
    			t1 = space();
    			sl_tooltip0 = element("sl-tooltip");
    			div0 = element("div");
    			t2 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t3 = space();
    			div4 = element("div");
    			label = element("label");
    			label.textContent = "Navigation Bar Options";
    			t5 = space();
    			sl_tooltip1 = element("sl-tooltip");
    			div2 = element("div");
    			t6 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "None";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Pages";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Tabs";
    			add_location(strong, file$2, 63, 4, 2573);
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file$2, 65, 6, 2631);
    			attr_dev(i0, "class", "icon-question cc-module-icon");
    			add_location(i0, file$2, 67, 9, 2773);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "href", /*HELP*/ ctx[1].fullClaytons.url);
    			add_location(a0, file$2, 66, 6, 2698);
    			add_location(sl_tooltip0, file$2, 64, 4, 2611);
    			add_location(div1, file$2, 62, 2, 2562);
    			attr_dev(label, "for", "cc-config-full-claytons-navigation-option");
    			add_location(label, file$2, 73, 4, 2922);
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$2, 77, 6, 3047);
    			attr_dev(i1, "class", "icon-question cc-module-icon");
    			add_location(i1, file$2, 79, 9, 3191);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			attr_dev(a1, "href", /*HELP*/ ctx[1].navBarOptions.url);
    			add_location(a1, file$2, 78, 6, 3115);
    			add_location(sl_tooltip1, file$2, 76, 4, 3027);
    			attr_dev(button0, "class", "btn svelte-dui1vd");
    			add_location(button0, file$2, 83, 6, 3333);
    			attr_dev(button1, "class", "btn svelte-dui1vd");
    			add_location(button1, file$2, 86, 6, 3435);
    			attr_dev(button2, "class", "btn svelte-dui1vd");
    			add_location(button2, file$2, 89, 6, 3539);
    			attr_dev(div3, "class", "cc-config-full-claytons-navigation-option svelte-dui1vd");
    			add_location(div3, file$2, 82, 4, 3270);
    			attr_dev(div4, "class", "border border-trbl");
    			set_style(div4, "padding", "0.5em");
    			add_location(div4, file$2, 72, 2, 2862);
    			set_style(div5, "margin-top", "0.5em");
    			add_location(div5, file$2, 61, 0, 2528);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div1);
    			append_dev(div1, strong);
    			append_dev(div1, t1);
    			append_dev(div1, sl_tooltip0);
    			append_dev(sl_tooltip0, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(sl_tooltip0, t2);
    			append_dev(sl_tooltip0, a0);
    			append_dev(a0, i0);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, label);
    			append_dev(div4, t5);
    			append_dev(div4, sl_tooltip1);
    			append_dev(sl_tooltip1, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(sl_tooltip1, t6);
    			append_dev(sl_tooltip1, a1);
    			append_dev(a1, i1);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FullClaytons', slots, []);
    	const dispatch = createEventDispatcher();

    	/**
     * @function updateOutputPage
     * @param {string} navOption
     * @description  Implement full claytons using the provided nav option
     */
    	function startFullClaytons(navOption) {
    		const convertNavOption = ["none", "pages", "tabs"].indexOf(navOption) + 1; /*, "table"*/
    		const updateController = new updatePageController(undefined, fullClaytonsCompleted, convertNavOption);
    		updateController.execute();
    	}

    	/**
     * @function fullClaytonsCompleted
     * @param pageController
     * @description called to perform any necessary steps after claytons completion
     * - display outcome alerts to the user
     * - dispatch messages with details of the pages that were created
     */
    	function fullClaytonsCompleted(pageController) {
    		let outcomes = pageController.generateOutcomesString("Full Claytons update");

    		// send message to collections configuration component
    		const pageNames = pageController.getPageNamesUpdated();

    		pageNames.forEach(pageName => {
    			dispatch("message", {
    				msgType: "updatePage",
    				pageType: "outputPage",
    				pageName
    			});
    		});

    		// provide details
    		if (!pageController.singleCollection) {
    			const numErrors = pageController.getNumErrors();

    			if (numErrors > 0) {
    				toastAlert(outcomes, "danger");
    			} else {
    				toastAlert(outcomes, "success");
    			}
    		}
    	}

    	const HELP = {
    		fullClaytons: {
    			tooltip: "<p>Update all the specified output pages with static representations of each collection using the selected navigation options.</p>",
    			url: "https://djplaner.github.io/canvas-collections/reference/representations/claytons/overview"
    		},
    		navBarOptions: {
    			tooltip: `<p>There are three navigation bar options:</p>
		<ol>
		  <li> None - no navigation between pages/collections. </li>
		  <li> Pages - collections on separate pages with navigation between. </li>
		  <li> Tabs - multiple collections on a page with tab navigation. </li>
		</ol>`,
    			/*<li>  Table - multiple collections joined into a single table. </li> */
    			url: "https://djplaner.github.io/canvas-collections/reference/representations/claytons/overview/#navigation-bar-options"
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FullClaytons> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => startFullClaytons("none");
    	const click_handler_1 = () => startFullClaytons("pages");
    	const click_handler_2 = () => startFullClaytons("tabs");

    	$$self.$capture_state = () => ({
    		updatePageController,
    		toastAlert,
    		createEventDispatcher,
    		dispatch,
    		startFullClaytons,
    		fullClaytonsCompleted,
    		HELP
    	});

    	return [startFullClaytons, HELP, click_handler, click_handler_1, click_handler_2];
    }

    class FullClaytons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FullClaytons",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\components\CollectionsConfiguration.svelte generated by Svelte v3.55.0 */

    const { Object: Object_1 } = globals;
    const file$1 = "src\\components\\CollectionsConfiguration.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (127:6) {#each visibilityOptions as visibilityOption}
    function create_each_block(ctx) {
    	let option;
    	let t_value = /*visibilityOption*/ ctx[15] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*visibilityOption*/ ctx[15];
    			option.value = option.__value;
    			add_location(option, file$1, 127, 8, 5248);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(127:6) {#each visibilityOptions as visibilityOption}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div3;
    	let div0;
    	let p;
    	let t0;
    	let span;
    	let t2;
    	let div2;
    	let small;
    	let t4;
    	let sl_tooltip;
    	let div1;
    	let raw_value = /*HELP*/ ctx[7].visibility.tooltip + "";
    	let t5;
    	let a;
    	let i;
    	let t6;
    	let select;
    	let t7;
    	let div7;
    	let div6;
    	let div4;
    	let existingcollections;
    	let updating_includePageExists;
    	let updating_outputPageExists;
    	let updating_pageNamesCollections;
    	let t8;
    	let div5;
    	let newcollection;
    	let t9;
    	let fullclaytons;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visibilityOptions*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	function existingcollections_includePageExists_binding(value) {
    		/*existingcollections_includePageExists_binding*/ ctx[10](value);
    	}

    	function existingcollections_outputPageExists_binding(value) {
    		/*existingcollections_outputPageExists_binding*/ ctx[11](value);
    	}

    	function existingcollections_pageNamesCollections_binding(value) {
    		/*existingcollections_pageNamesCollections_binding*/ ctx[12](value);
    	}

    	let existingcollections_props = {};

    	if (/*includePageExists*/ ctx[0] !== void 0) {
    		existingcollections_props.includePageExists = /*includePageExists*/ ctx[0];
    	}

    	if (/*outputPageExists*/ ctx[1] !== void 0) {
    		existingcollections_props.outputPageExists = /*outputPageExists*/ ctx[1];
    	}

    	if (/*pageNamesCollections*/ ctx[2] !== void 0) {
    		existingcollections_props.pageNamesCollections = /*pageNamesCollections*/ ctx[2];
    	}

    	existingcollections = new ExistingCollections({
    			props: existingcollections_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(existingcollections, 'includePageExists', existingcollections_includePageExists_binding, /*includePageExists*/ ctx[0]));
    	binding_callbacks.push(() => bind(existingcollections, 'outputPageExists', existingcollections_outputPageExists_binding, /*outputPageExists*/ ctx[1]));
    	binding_callbacks.push(() => bind(existingcollections, 'pageNamesCollections', existingcollections_pageNamesCollections_binding, /*pageNamesCollections*/ ctx[2]));
    	existingcollections.$on("message", /*handleMessage*/ ctx[6]);
    	newcollection = new NewCollection({ $$inline: true });
    	fullclaytons = new FullClaytons({ $$inline: true });
    	fullclaytons.$on("message", /*handleMessage*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t0 = text("Configure Canvas Collections\r\n      ");
    			span = element("span");
    			span.textContent = `${CC_VERSION}`;
    			t2 = space();
    			div2 = element("div");
    			small = element("small");
    			small.textContent = "Visibility";
    			t4 = space();
    			sl_tooltip = element("sl-tooltip");
    			div1 = element("div");
    			t5 = space();
    			a = element("a");
    			i = element("i");
    			t6 = space();
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div4 = element("div");
    			create_component(existingcollections.$$.fragment);
    			t8 = space();
    			div5 = element("div");
    			create_component(newcollection.$$.fragment);
    			t9 = space();
    			create_component(fullclaytons.$$.fragment);
    			attr_dev(span, "class", "cc-version svelte-5recs2");
    			add_location(span, file$1, 109, 6, 4590);
    			attr_dev(p, "class", "svelte-5recs2");
    			add_location(p, file$1, 108, 4, 4551);
    			attr_dev(div0, "class", "cc-header cc-collections-label svelte-5recs2");
    			add_location(div0, file$1, 107, 2, 4501);
    			add_location(small, file$1, 113, 4, 4698);
    			attr_dev(div1, "slot", "content");
    			add_location(div1, file$1, 115, 6, 4749);
    			attr_dev(i, "class", "icon-question cc-module-icon");
    			add_location(i, file$1, 117, 9, 4887);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "href", /*HELP*/ ctx[7].visibility.url);
    			add_location(a, file$1, 116, 6, 4814);
    			add_location(sl_tooltip, file$1, 114, 4, 4729);
    			attr_dev(select, "id", "cc-collection-visibility");
    			attr_dev(select, "class", "cc-collection-representation svelte-5recs2");
    			if (/*$collectionsStore*/ ctx[4]["VISIBILITY"] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[8].call(select));
    			add_location(select, file$1, 120, 4, 4966);
    			attr_dev(div2, "class", "cc-collections-input");
    			add_location(div2, file$1, 112, 2, 4658);
    			attr_dev(div3, "class", "cc-header-grid svelte-5recs2");
    			add_location(div3, file$1, 106, 0, 4469);
    			attr_dev(div4, "id", "cc-config-existing-collections");
    			add_location(div4, file$1, 134, 4, 5418);
    			attr_dev(div5, "id", "cc-config-new-collection");
    			add_location(div5, file$1, 142, 4, 5649);
    			attr_dev(div6, "id", "cc-config-body");
    			attr_dev(div6, "class", "svelte-5recs2");
    			add_location(div6, file$1, 133, 2, 5387);
    			attr_dev(div7, "class", "cc-box-body svelte-5recs2");
    			add_location(div7, file$1, 132, 0, 5358);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, p);
    			append_dev(p, t0);
    			append_dev(p, span);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, small);
    			append_dev(div2, t4);
    			append_dev(div2, sl_tooltip);
    			append_dev(sl_tooltip, div1);
    			div1.innerHTML = raw_value;
    			append_dev(sl_tooltip, t5);
    			append_dev(sl_tooltip, a);
    			append_dev(a, i);
    			append_dev(div2, t6);
    			append_dev(div2, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$collectionsStore*/ ctx[4]["VISIBILITY"]);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div4);
    			mount_component(existingcollections, div4, null);
    			append_dev(div6, t8);
    			append_dev(div6, div5);
    			mount_component(newcollection, div5, null);
    			append_dev(div5, t9);
    			mount_component(fullclaytons, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[8]),
    					listen_dev(select, "change", /*change_handler*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*visibilityOptions*/ 32) {
    				each_value = /*visibilityOptions*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$collectionsStore, visibilityOptions*/ 48) {
    				select_option(select, /*$collectionsStore*/ ctx[4]["VISIBILITY"]);
    			}

    			const existingcollections_changes = {};

    			if (!updating_includePageExists && dirty & /*includePageExists*/ 1) {
    				updating_includePageExists = true;
    				existingcollections_changes.includePageExists = /*includePageExists*/ ctx[0];
    				add_flush_callback(() => updating_includePageExists = false);
    			}

    			if (!updating_outputPageExists && dirty & /*outputPageExists*/ 2) {
    				updating_outputPageExists = true;
    				existingcollections_changes.outputPageExists = /*outputPageExists*/ ctx[1];
    				add_flush_callback(() => updating_outputPageExists = false);
    			}

    			if (!updating_pageNamesCollections && dirty & /*pageNamesCollections*/ 4) {
    				updating_pageNamesCollections = true;
    				existingcollections_changes.pageNamesCollections = /*pageNamesCollections*/ ctx[2];
    				add_flush_callback(() => updating_pageNamesCollections = false);
    			}

    			existingcollections.$set(existingcollections_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(existingcollections.$$.fragment, local);
    			transition_in(newcollection.$$.fragment, local);
    			transition_in(fullclaytons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(existingcollections.$$.fragment, local);
    			transition_out(newcollection.$$.fragment, local);
    			transition_out(fullclaytons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div7);
    			destroy_component(existingcollections);
    			destroy_component(newcollection);
    			destroy_component(fullclaytons);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const CC_VERSION = "1.0.1b";

    function instance$1($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(3, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(4, $collectionsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollectionsConfiguration', slots, []);
    	const visibilityOptions = ["no-one", "students", "teachers", "all"];

    	/**
     * Declare and populate variables to track whether includePage and outputPage
     * for each collection actually exist
     * - These are hashes keyed on collection name
     */
    	let includePageExists = {}, outputPageExists = {};

    	$collectionsStore["COLLECTIONS_ORDER"].forEach(collectionName => {
    		$$invalidate(0, includePageExists[collectionName] = true, includePageExists);
    		$$invalidate(1, outputPageExists[collectionName] = true, outputPageExists);
    	});

    	let pageNamesCollections = updatePageNamesCollections();

    	// see if the existing pages exist
    	Object.keys(pageNamesCollections).forEach(pageName => {
    		getPageName(pageName, $configStore["courseId"], doesPageExist);
    	});

    	/**
     * @function updatePageNamesCollections
     * @description create a new pageNamesCollections
     * hash of arrays, keyed on pageName with a list of collections
     * that use that pageName, values are a hash
     * { pageType: includePage|outputPage, collectionName: collectionName}
     * used to ensure only one check for exists is done
     */
    	function updatePageNamesCollections() {
    		let newPageNamesCollections = {};

    		// Assume they are true to start with and allow getPageName result to override
    		$collectionsStore["COLLECTIONS_ORDER"].forEach(collectionName => {
    			//includePageExists[collectionName] = true;
    			//outputPageExists[collectionName] = true;
    			["includePage", "outputPage"].forEach(pageType => {
    				const pageName = $collectionsStore["COLLECTIONS"][collectionName][pageType];
    				const value = { pageType, collectionName };

    				if (pageName && pageName !== "") {
    					if (!newPageNamesCollections.hasOwnProperty(pageName)) {
    						newPageNamesCollections[pageName] = [];
    					}

    					newPageNamesCollections[pageName].push(value);
    				}
    			});
    		});

    		return newPageNamesCollections;
    	}

    	// Reactive check the getPageName
    	// Perhaps should be a message
    	function handleMessage(event) {
    		const msgType = event.detail.msgType;

    		if (msgType === "changeName") {
    			// change the value in collectionsStore if names have changed
    			set_store_value(collectionsStore, $collectionsStore["COLLECTIONS"][event.detail.collectionName][event.detail.pageType] = event.detail.pageName, $collectionsStore);

    			set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    			// modify page names collections
    			$$invalidate(2, pageNamesCollections = updatePageNamesCollections());
    		}

    		// need to check if the page exists & thus modify the warning
    		getPageName(event.detail.pageName, $configStore["courseId"], doesPageExist);
    	}

    	/**
     * @function doesPageExists
     * @param pageName - name of the page to tried to retrive
     * @param msg - message back from canvas API { status: res: body }
     * @description Call back after trying to get the page object for a page
     * will modify the "exists" for all collections using the page
     */
    	function doesPageExist(pageName, msg) {
    		const pageObject = msg.body;
    		let pageExists = false;

    		if (pageObject) {
    			pageExists = true;
    		}

    		// modify "exists" setting for all the collections that have this page
    		// to whatever was found
    		pageNamesCollections[pageName].forEach(value => {
    			const pageType = value.pageType;
    			const collectionName = value.collectionName;

    			if (pageType === "includePage") {
    				$$invalidate(0, includePageExists[collectionName] = pageExists, includePageExists);
    			} else {
    				$$invalidate(1, outputPageExists[collectionName] = pageExists, outputPageExists);
    			}
    		});
    	}

    	const HELP = {
    		visibility: {
    			tooltip: "<p>Who can see Collections modification of the modules page.</p>",
    			url: "https://djplaner.github.io/canvas-collections/reference/visibility/"
    		}
    	};

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollectionsConfiguration> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		$collectionsStore["VISIBILITY"] = select_value(this);
    		collectionsStore.set($collectionsStore);
    		$$invalidate(5, visibilityOptions);
    	}

    	const change_handler = () => set_store_value(configStore, $configStore["needToSaveCollections"] = true, $configStore);

    	function existingcollections_includePageExists_binding(value) {
    		includePageExists = value;
    		$$invalidate(0, includePageExists);
    	}

    	function existingcollections_outputPageExists_binding(value) {
    		outputPageExists = value;
    		$$invalidate(1, outputPageExists);
    	}

    	function existingcollections_pageNamesCollections_binding(value) {
    		pageNamesCollections = value;
    		$$invalidate(2, pageNamesCollections);
    	}

    	$$self.$capture_state = () => ({
    		collectionsStore,
    		configStore,
    		getPageName,
    		ExistingCollections,
    		NewCollection,
    		FullClaytons,
    		visibilityOptions,
    		CC_VERSION,
    		includePageExists,
    		outputPageExists,
    		pageNamesCollections,
    		updatePageNamesCollections,
    		handleMessage,
    		doesPageExist,
    		HELP,
    		$configStore,
    		$collectionsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('includePageExists' in $$props) $$invalidate(0, includePageExists = $$props.includePageExists);
    		if ('outputPageExists' in $$props) $$invalidate(1, outputPageExists = $$props.outputPageExists);
    		if ('pageNamesCollections' in $$props) $$invalidate(2, pageNamesCollections = $$props.pageNamesCollections);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		includePageExists,
    		outputPageExists,
    		pageNamesCollections,
    		$configStore,
    		$collectionsStore,
    		visibilityOptions,
    		handleMessage,
    		HELP,
    		select_change_handler,
    		change_handler,
    		existingcollections_includePageExists_binding,
    		existingcollections_outputPageExists_binding,
    		existingcollections_pageNamesCollections_binding
    	];
    }

    class CollectionsConfiguration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollectionsConfiguration",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /**
     * @class CanvasDetails
     * @description Given a course Id retrieve the info Collections requires
     * about the course and its modules via Canvas API calls
     */
    class CanvasDetails {
        /**
         * Set up the object and request from Canvas details on the user and their current enrollments
         * @callBack finishedCallBack - function to change the state of the parent component
         * @param {Object} config - configuration object
         */
        constructor(finishedCallBack, config) {
            this.finishedCallBack = finishedCallBack;
            this.config = config;
            //    this.csrfToken = this.CONFIG.csrfToken;
            //    this.courseId = this.CONFIG.courseId;
            this.currentHostName = document.location.hostname;
            this.baseApiUrl = `https://${this.currentHostName}/api/v1`;
            // convert courseId to integer
            this["config"]["courseId"] = parseInt(this["config"]["courseId"]);
            this.requestCourseObject();
        }
        /**
         * @method refreshCanvasDetails
         * @param {Function} callBack
         */
        refreshCanvasDetails(callBack) {
            this.finishedCallBack = callBack;
            this.requestCourseObject();
        }
        /**
         * @function requestCourseObject
         *
         */
        requestCourseObject() {
            wf_fetchData(`${this.baseApiUrl}/courses/${this.config.courseId}`).then((msg) => {
                if (msg.status === 200) {
                    this.courseObject = msg.body;
                    this.generateSTRM();
                    this.requestModuleInformation();
                }
            });
        }
        /**
         * @descr Examine Canvas course object's course_code attribute in an attempt
         * to extract the STRM and subsequently calculate the year, period and
         * other data
         *
         * Production sites:
         *    Organisational Communication (COM31_2226)
         *
         * DEV sites:
         *    DEV_2515LHS_3228
         *
         * ORG sites:
         *     AEL_SHOW1
         *
         * TODO rejig based on scapeLib/parseCourseInstanceId (ael-automation)
         * In particular to handle the "YP" course ids
         */
        generateSTRM() {
            if (!this.hasOwnProperty("calendar")) {
                this.calendar = new UniversityDateCalendar();
            }
            // TODO this is where we might check if there is an existing default
            // study period already set and thus bypass getCurrentPeriod
            // we pass course_code to calendar because it's the main object that is
            // available to all users. the sis_course_id might be better but students
            // don't see it
            this.studyPeriod = this.calendar.getCurrentPeriod(this.courseObject.course_code);
            this.calendar.setStudyPeriod(this.studyPeriod);
            // aboutStudyPeriod is an object with human readable information about the
            // study period - typically strings for
            // - year - full year
            // - period - descriptive name for the period
            // - type - string specifying the type of study period
            //		this.aboutStudyPeriod = this.calendar.parseStudyPeriod(this.studyPeriod);
            this.parseStrm();
        }
        /**
         * @descr Parse the STRM and set the type, year, period
         * Based on Griffith STRM definition
         * https://intranet.secure.griffith.edu.au/computing/using-learning-at-griffith/staff/administration/course-ID
         */
        parseStrm() {
            this.type = undefined;
            this.year = undefined;
            this.period = undefined;
            // return if this.strm undefined
            if (this.strm === undefined) {
                return;
            }
            // break up this.strm into individual characters
            const strm = this.strm.split("");
            // if more than four chars then return
            if (strm.length > 4) {
                console.error(`cc_Controller: parseStrm: strm too long: ${this.strm}`);
                return;
            }
            // check all chars are numeric
            for (let i = 0; i < strm.length; i++) {
                if (isNaN(strm[i])) {
                    console.error(`cc_Controller: parseStrm: strm not numeric: ${this.strm}`);
                    return;
                }
            }
            this.type = strm[0];
            // this.year is the middle two characters prepended by 20
            this.year = `20${strm[1]}${strm[2]}`;
            // this.period (initially) is that last char
            this.period = strm[3];
            // period value needs translation based on type
            // default is Griffith trimester
            let translate = { 1: 1, 5: 2, 8: 3 };
            if (this.type === 2) {
                translate = { 1: 1, 2: 1, 3: 2, 4: 2, 5: 3, 6: 3, 7: 4 };
            }
            this.period = translate[this.period];
        }
        requestModuleInformation() {
            wf_fetchData(`${this.baseApiUrl}/courses/${this.config.courseId}/modules?include=content_details&per_page=500`).then((msg) => {
                if (msg.status === 200) {
                    this.courseModules = msg.body;
                    this.finishedCallBack();
                }
            });
        }
    }

    // src/internal/event.ts
    function waitForEvent(el, eventName) {
      return new Promise((resolve) => {
        function done(event) {
          if (event.target === el) {
            el.removeEventListener(eventName, done);
            resolve();
          }
        }
        el.addEventListener(eventName, done);
      });
    }

    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __decorateClass = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp(target, key, result);
      return result;
    };

    // src/internal/animate.ts
    function animateTo(el, keyframes, options) {
      return new Promise((resolve) => {
        if ((options == null ? void 0 : options.duration) === Infinity) {
          throw new Error("Promise-based animations must be finite.");
        }
        const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
          duration: prefersReducedMotion() ? 0 : options.duration
        }));
        animation.addEventListener("cancel", resolve, { once: true });
        animation.addEventListener("finish", resolve, { once: true });
      });
    }
    function parseDuration(delay) {
      delay = delay.toString().toLowerCase();
      if (delay.indexOf("ms") > -1) {
        return parseFloat(delay);
      }
      if (delay.indexOf("s") > -1) {
        return parseFloat(delay) * 1e3;
      }
      return parseFloat(delay);
    }
    function prefersReducedMotion() {
      const query = window.matchMedia("(prefers-reduced-motion: reduce)");
      return query.matches;
    }
    function stopAnimations(el) {
      return Promise.all(
        el.getAnimations().map((animation) => {
          return new Promise((resolve) => {
            const handleAnimationEvent = requestAnimationFrame(resolve);
            animation.addEventListener("cancel", () => handleAnimationEvent, { once: true });
            animation.addEventListener("finish", () => handleAnimationEvent, { once: true });
            animation.cancel();
          });
        })
      );
    }

    // src/utilities/animation-registry.ts
    var defaultAnimationRegistry = /* @__PURE__ */ new Map();
    var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
    function ensureAnimation(animation) {
      return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
    }
    function getLogicalAnimation(animation, dir) {
      if (dir.toLowerCase() === "rtl") {
        return {
          keyframes: animation.rtlKeyframes || animation.keyframes,
          options: animation.options
        };
      }
      return animation;
    }
    function setDefaultAnimation(animationName, animation) {
      defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
    }
    function getAnimation(el, animationName, options) {
      const customAnimation = customAnimationRegistry.get(el);
      if (customAnimation == null ? void 0 : customAnimation[animationName]) {
        return getLogicalAnimation(customAnimation[animationName], options.dir);
      }
      const defaultAnimation = defaultAnimationRegistry.get(animationName);
      if (defaultAnimation) {
        return getLogicalAnimation(defaultAnimation, options.dir);
      }
      return {
        keyframes: [],
        options: { duration: 0 }
      };
    }

    // node_modules/@shoelace-style/localize/dist/index.js
    var connectedElements = /* @__PURE__ */ new Set();
    var documentElementObserver = new MutationObserver(update);
    var translations = /* @__PURE__ */ new Map();
    var documentDirection = document.documentElement.dir || "ltr";
    var documentLanguage = document.documentElement.lang || navigator.language;
    var fallback;
    documentElementObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["dir", "lang"]
    });
    function registerTranslation(...translation2) {
      translation2.map((t) => {
        const code = t.$code.toLowerCase();
        if (translations.has(code)) {
          translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t));
        } else {
          translations.set(code, t);
        }
        if (!fallback) {
          fallback = t;
        }
      });
      update();
    }
    function update() {
      documentDirection = document.documentElement.dir || "ltr";
      documentLanguage = document.documentElement.lang || navigator.language;
      [...connectedElements.keys()].map((el) => {
        if (typeof el.requestUpdate === "function") {
          el.requestUpdate();
        }
      });
    }
    var LocalizeController = class {
      constructor(host) {
        this.host = host;
        this.host.addController(this);
      }
      hostConnected() {
        connectedElements.add(this.host);
      }
      hostDisconnected() {
        connectedElements.delete(this.host);
      }
      dir() {
        return `${this.host.dir || documentDirection}`.toLowerCase();
      }
      lang() {
        return `${this.host.lang || documentLanguage}`.toLowerCase();
      }
      term(key, ...args) {
        var _a, _b;
        const locale = new Intl.Locale(this.lang());
        const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
        const region = (_b = (_a = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
        const primary = translations.get(`${language}-${region}`);
        const secondary = translations.get(language);
        let term;
        if (primary && primary[key]) {
          term = primary[key];
        } else if (secondary && secondary[key]) {
          term = secondary[key];
        } else if (fallback && fallback[key]) {
          term = fallback[key];
        } else {
          console.error(`No translation found for: ${String(key)}`);
          return String(key);
        }
        if (typeof term === "function") {
          return term(...args);
        }
        return term;
      }
      date(dateToFormat, options) {
        dateToFormat = new Date(dateToFormat);
        return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
      }
      number(numberToFormat, options) {
        numberToFormat = Number(numberToFormat);
        return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
      }
      relativeTime(value, unit, options) {
        return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
      }
    };

    // src/utilities/localize.ts
    var LocalizeController2 = class extends LocalizeController {
    };

    // src/translations/en.ts
    var translation = {
      $code: "en",
      $name: "English",
      $dir: "ltr",
      clearEntry: "Clear entry",
      close: "Close",
      copy: "Copy",
      numOptionsSelected: (num) => {
        if (num === 0)
          return "No options selected";
        if (num === 1)
          return "1 option selected";
        return `${num} options selected`;
      },
      currentValue: "Current value",
      hidePassword: "Hide password",
      loading: "Loading",
      progress: "Progress",
      remove: "Remove",
      resize: "Resize",
      scrollToEnd: "Scroll to end",
      scrollToStart: "Scroll to start",
      selectAColorFromTheScreen: "Select a color from the screen",
      showPassword: "Show password",
      toggleColorFormat: "Toggle color format"
    };
    registerTranslation(translation);

    // src/internal/slot.ts
    var HasSlotController = class {
      constructor(host, ...slotNames) {
        this.slotNames = [];
        (this.host = host).addController(this);
        this.slotNames = slotNames;
        this.handleSlotChange = this.handleSlotChange.bind(this);
      }
      hasDefaultSlot() {
        return [...this.host.childNodes].some((node) => {
          if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
            return true;
          }
          if (node.nodeType === node.ELEMENT_NODE) {
            const el = node;
            const tagName = el.tagName.toLowerCase();
            if (tagName === "sl-visually-hidden") {
              return false;
            }
            if (!el.hasAttribute("slot")) {
              return true;
            }
          }
          return false;
        });
      }
      hasNamedSlot(name) {
        return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
      }
      test(slotName) {
        return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
      }
      hostConnected() {
        this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
      }
      hostDisconnected() {
        this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
      }
      handleSlotChange(event) {
        const slot = event.target;
        if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
          this.host.requestUpdate();
        }
      }
    };

    // src/internal/watch.ts
    function watch(propertyName, options) {
      const resolvedOptions = __spreadValues({
        waitUntilFirstUpdate: false
      }, options);
      return (proto, decoratedFnName) => {
        const { update } = proto;
        const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
        proto.update = function(changedProps) {
          watchedProperties.forEach((property) => {
            const key = property;
            if (changedProps.has(key)) {
              const oldValue = changedProps.get(key);
              const newValue = this[key];
              if (oldValue !== newValue) {
                if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
                  this[decoratedFnName](oldValue, newValue);
                }
              }
            }
          });
          update.call(this, changedProps);
        };
      };
    }

    // node_modules/@lit/reactive-element/css-tag.js
    var t$3 = window;
    var e$3 = t$3.ShadowRoot && (void 0 === t$3.ShadyCSS || t$3.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
    var s$3 = Symbol();
    var n$3 = /* @__PURE__ */ new WeakMap();
    var o$2 = class {
      constructor(t3, e4, n5) {
        if (this._$cssResult$ = true, n5 !== s$3)
          throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t3, this.t = e4;
      }
      get styleSheet() {
        let t3 = this.o;
        const s5 = this.t;
        if (e$3 && void 0 === t3) {
          const e4 = void 0 !== s5 && 1 === s5.length;
          e4 && (t3 = n$3.get(s5)), void 0 === t3 && ((this.o = t3 = new CSSStyleSheet()).replaceSync(this.cssText), e4 && n$3.set(s5, t3));
        }
        return t3;
      }
      toString() {
        return this.cssText;
      }
    };
    var r$1 = (t3) => new o$2("string" == typeof t3 ? t3 : t3 + "", void 0, s$3);
    var i$3 = (t3, ...e4) => {
      const n5 = 1 === t3.length ? t3[0] : e4.reduce((e5, s5, n6) => e5 + ((t4) => {
        if (true === t4._$cssResult$)
          return t4.cssText;
        if ("number" == typeof t4)
          return t4;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + t4 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
      })(s5) + t3[n6 + 1], t3[0]);
      return new o$2(n5, t3, s$3);
    };
    var S$1 = (s5, n5) => {
      e$3 ? s5.adoptedStyleSheets = n5.map((t3) => t3 instanceof CSSStyleSheet ? t3 : t3.styleSheet) : n5.forEach((e4) => {
        const n6 = document.createElement("style"), o5 = t$3.litNonce;
        void 0 !== o5 && n6.setAttribute("nonce", o5), n6.textContent = e4.cssText, s5.appendChild(n6);
      });
    };
    var c$1 = e$3 ? (t3) => t3 : (t3) => t3 instanceof CSSStyleSheet ? ((t4) => {
      let e4 = "";
      for (const s5 of t4.cssRules)
        e4 += s5.cssText;
      return r$1(e4);
    })(t3) : t3;

    // node_modules/@lit/reactive-element/reactive-element.js
    var s2$1;
    var e2$2 = window;
    var r2$1 = e2$2.trustedTypes;
    var h$1 = r2$1 ? r2$1.emptyScript : "";
    var o2$2 = e2$2.reactiveElementPolyfillSupport;
    var n2$1 = { toAttribute(t3, i3) {
      switch (i3) {
        case Boolean:
          t3 = t3 ? h$1 : null;
          break;
        case Object:
        case Array:
          t3 = null == t3 ? t3 : JSON.stringify(t3);
      }
      return t3;
    }, fromAttribute(t3, i3) {
      let s5 = t3;
      switch (i3) {
        case Boolean:
          s5 = null !== t3;
          break;
        case Number:
          s5 = null === t3 ? null : Number(t3);
          break;
        case Object:
        case Array:
          try {
            s5 = JSON.parse(t3);
          } catch (t4) {
            s5 = null;
          }
      }
      return s5;
    } };
    var a$2 = (t3, i3) => i3 !== t3 && (i3 == i3 || t3 == t3);
    var l$3 = { attribute: true, type: String, converter: n2$1, reflect: false, hasChanged: a$2 };
    var d = class extends HTMLElement {
      constructor() {
        super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
      }
      static addInitializer(t3) {
        var i3;
        this.finalize(), (null !== (i3 = this.h) && void 0 !== i3 ? i3 : this.h = []).push(t3);
      }
      static get observedAttributes() {
        this.finalize();
        const t3 = [];
        return this.elementProperties.forEach((i3, s5) => {
          const e4 = this._$Ep(s5, i3);
          void 0 !== e4 && (this._$Ev.set(e4, s5), t3.push(e4));
        }), t3;
      }
      static createProperty(t3, i3 = l$3) {
        if (i3.state && (i3.attribute = false), this.finalize(), this.elementProperties.set(t3, i3), !i3.noAccessor && !this.prototype.hasOwnProperty(t3)) {
          const s5 = "symbol" == typeof t3 ? Symbol() : "__" + t3, e4 = this.getPropertyDescriptor(t3, s5, i3);
          void 0 !== e4 && Object.defineProperty(this.prototype, t3, e4);
        }
      }
      static getPropertyDescriptor(t3, i3, s5) {
        return { get() {
          return this[i3];
        }, set(e4) {
          const r4 = this[t3];
          this[i3] = e4, this.requestUpdate(t3, r4, s5);
        }, configurable: true, enumerable: true };
      }
      static getPropertyOptions(t3) {
        return this.elementProperties.get(t3) || l$3;
      }
      static finalize() {
        if (this.hasOwnProperty("finalized"))
          return false;
        this.finalized = true;
        const t3 = Object.getPrototypeOf(this);
        if (t3.finalize(), void 0 !== t3.h && (this.h = [...t3.h]), this.elementProperties = new Map(t3.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
          const t4 = this.properties, i3 = [...Object.getOwnPropertyNames(t4), ...Object.getOwnPropertySymbols(t4)];
          for (const s5 of i3)
            this.createProperty(s5, t4[s5]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), true;
      }
      static finalizeStyles(i3) {
        const s5 = [];
        if (Array.isArray(i3)) {
          const e4 = new Set(i3.flat(1 / 0).reverse());
          for (const i4 of e4)
            s5.unshift(c$1(i4));
        } else
          void 0 !== i3 && s5.push(c$1(i3));
        return s5;
      }
      static _$Ep(t3, i3) {
        const s5 = i3.attribute;
        return false === s5 ? void 0 : "string" == typeof s5 ? s5 : "string" == typeof t3 ? t3.toLowerCase() : void 0;
      }
      u() {
        var t3;
        this._$E_ = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t3 = this.constructor.h) || void 0 === t3 || t3.forEach((t4) => t4(this));
      }
      addController(t3) {
        var i3, s5;
        (null !== (i3 = this._$ES) && void 0 !== i3 ? i3 : this._$ES = []).push(t3), void 0 !== this.renderRoot && this.isConnected && (null === (s5 = t3.hostConnected) || void 0 === s5 || s5.call(t3));
      }
      removeController(t3) {
        var i3;
        null === (i3 = this._$ES) || void 0 === i3 || i3.splice(this._$ES.indexOf(t3) >>> 0, 1);
      }
      _$Eg() {
        this.constructor.elementProperties.forEach((t3, i3) => {
          this.hasOwnProperty(i3) && (this._$Ei.set(i3, this[i3]), delete this[i3]);
        });
      }
      createRenderRoot() {
        var t3;
        const s5 = null !== (t3 = this.shadowRoot) && void 0 !== t3 ? t3 : this.attachShadow(this.constructor.shadowRootOptions);
        return S$1(s5, this.constructor.elementStyles), s5;
      }
      connectedCallback() {
        var t3;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t3 = this._$ES) || void 0 === t3 || t3.forEach((t4) => {
          var i3;
          return null === (i3 = t4.hostConnected) || void 0 === i3 ? void 0 : i3.call(t4);
        });
      }
      enableUpdating(t3) {
      }
      disconnectedCallback() {
        var t3;
        null === (t3 = this._$ES) || void 0 === t3 || t3.forEach((t4) => {
          var i3;
          return null === (i3 = t4.hostDisconnected) || void 0 === i3 ? void 0 : i3.call(t4);
        });
      }
      attributeChangedCallback(t3, i3, s5) {
        this._$AK(t3, s5);
      }
      _$EO(t3, i3, s5 = l$3) {
        var e4;
        const r4 = this.constructor._$Ep(t3, s5);
        if (void 0 !== r4 && true === s5.reflect) {
          const h3 = (void 0 !== (null === (e4 = s5.converter) || void 0 === e4 ? void 0 : e4.toAttribute) ? s5.converter : n2$1).toAttribute(i3, s5.type);
          this._$El = t3, null == h3 ? this.removeAttribute(r4) : this.setAttribute(r4, h3), this._$El = null;
        }
      }
      _$AK(t3, i3) {
        var s5;
        const e4 = this.constructor, r4 = e4._$Ev.get(t3);
        if (void 0 !== r4 && this._$El !== r4) {
          const t4 = e4.getPropertyOptions(r4), h3 = "function" == typeof t4.converter ? { fromAttribute: t4.converter } : void 0 !== (null === (s5 = t4.converter) || void 0 === s5 ? void 0 : s5.fromAttribute) ? t4.converter : n2$1;
          this._$El = r4, this[r4] = h3.fromAttribute(i3, t4.type), this._$El = null;
        }
      }
      requestUpdate(t3, i3, s5) {
        let e4 = true;
        void 0 !== t3 && (((s5 = s5 || this.constructor.getPropertyOptions(t3)).hasChanged || a$2)(this[t3], i3) ? (this._$AL.has(t3) || this._$AL.set(t3, i3), true === s5.reflect && this._$El !== t3 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t3, s5))) : e4 = false), !this.isUpdatePending && e4 && (this._$E_ = this._$Ej());
      }
      async _$Ej() {
        this.isUpdatePending = true;
        try {
          await this._$E_;
        } catch (t4) {
          Promise.reject(t4);
        }
        const t3 = this.scheduleUpdate();
        return null != t3 && await t3, !this.isUpdatePending;
      }
      scheduleUpdate() {
        return this.performUpdate();
      }
      performUpdate() {
        var t3;
        if (!this.isUpdatePending)
          return;
        this.hasUpdated, this._$Ei && (this._$Ei.forEach((t4, i4) => this[i4] = t4), this._$Ei = void 0);
        let i3 = false;
        const s5 = this._$AL;
        try {
          i3 = this.shouldUpdate(s5), i3 ? (this.willUpdate(s5), null === (t3 = this._$ES) || void 0 === t3 || t3.forEach((t4) => {
            var i4;
            return null === (i4 = t4.hostUpdate) || void 0 === i4 ? void 0 : i4.call(t4);
          }), this.update(s5)) : this._$Ek();
        } catch (t4) {
          throw i3 = false, this._$Ek(), t4;
        }
        i3 && this._$AE(s5);
      }
      willUpdate(t3) {
      }
      _$AE(t3) {
        var i3;
        null === (i3 = this._$ES) || void 0 === i3 || i3.forEach((t4) => {
          var i4;
          return null === (i4 = t4.hostUpdated) || void 0 === i4 ? void 0 : i4.call(t4);
        }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t3)), this.updated(t3);
      }
      _$Ek() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
      }
      get updateComplete() {
        return this.getUpdateComplete();
      }
      getUpdateComplete() {
        return this._$E_;
      }
      shouldUpdate(t3) {
        return true;
      }
      update(t3) {
        void 0 !== this._$EC && (this._$EC.forEach((t4, i3) => this._$EO(i3, this[i3], t4)), this._$EC = void 0), this._$Ek();
      }
      updated(t3) {
      }
      firstUpdated(t3) {
      }
    };
    d.finalized = true, d.elementProperties = /* @__PURE__ */ new Map(), d.elementStyles = [], d.shadowRootOptions = { mode: "open" }, null == o2$2 || o2$2({ ReactiveElement: d }), (null !== (s2$1 = e2$2.reactiveElementVersions) && void 0 !== s2$1 ? s2$1 : e2$2.reactiveElementVersions = []).push("1.6.1");

    // node_modules/lit-html/lit-html.js
    var t2;
    var i2$3 = window;
    var s3 = i2$3.trustedTypes;
    var e3$1 = s3 ? s3.createPolicy("lit-html", { createHTML: (t3) => t3 }) : void 0;
    var o3$1 = `lit$${(Math.random() + "").slice(9)}$`;
    var n3 = "?" + o3$1;
    var l2$2 = `<${n3}>`;
    var h2$1 = document;
    var r3 = (t3 = "") => h2$1.createComment(t3);
    var d2$1 = (t3) => null === t3 || "object" != typeof t3 && "function" != typeof t3;
    var u$1 = Array.isArray;
    var c2$1 = (t3) => u$1(t3) || "function" == typeof (null == t3 ? void 0 : t3[Symbol.iterator]);
    var v = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    var a2$1 = /-->/g;
    var f$2 = />/g;
    var _ = RegExp(`>|[ 	
\f\r](?:([^\\s"'>=/]+)([ 	
\f\r]*=[ 	
\f\r]*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
    var m$1 = /'/g;
    var p$1 = /"/g;
    var $ = /^(?:script|style|textarea|title)$/i;
    var g$1 = (t3) => (i3, ...s5) => ({ _$litType$: t3, strings: i3, values: s5 });
    var y = g$1(1);
    var x$1 = Symbol.for("lit-noChange");
    var b$1 = Symbol.for("lit-nothing");
    var T = /* @__PURE__ */ new WeakMap();
    var A$1 = h2$1.createTreeWalker(h2$1, 129, null, false);
    var E$1 = (t3, i3) => {
      const s5 = t3.length - 1, n5 = [];
      let h3, r4 = 2 === i3 ? "<svg>" : "", d3 = v;
      for (let i4 = 0; i4 < s5; i4++) {
        const s6 = t3[i4];
        let e4, u3, c3 = -1, g2 = 0;
        for (; g2 < s6.length && (d3.lastIndex = g2, u3 = d3.exec(s6), null !== u3); )
          g2 = d3.lastIndex, d3 === v ? "!--" === u3[1] ? d3 = a2$1 : void 0 !== u3[1] ? d3 = f$2 : void 0 !== u3[2] ? ($.test(u3[2]) && (h3 = RegExp("</" + u3[2], "g")), d3 = _) : void 0 !== u3[3] && (d3 = _) : d3 === _ ? ">" === u3[0] ? (d3 = null != h3 ? h3 : v, c3 = -1) : void 0 === u3[1] ? c3 = -2 : (c3 = d3.lastIndex - u3[2].length, e4 = u3[1], d3 = void 0 === u3[3] ? _ : '"' === u3[3] ? p$1 : m$1) : d3 === p$1 || d3 === m$1 ? d3 = _ : d3 === a2$1 || d3 === f$2 ? d3 = v : (d3 = _, h3 = void 0);
        const y2 = d3 === _ && t3[i4 + 1].startsWith("/>") ? " " : "";
        r4 += d3 === v ? s6 + l2$2 : c3 >= 0 ? (n5.push(e4), s6.slice(0, c3) + "$lit$" + s6.slice(c3) + o3$1 + y2) : s6 + o3$1 + (-2 === c3 ? (n5.push(void 0), i4) : y2);
      }
      const u2 = r4 + (t3[s5] || "<?>") + (2 === i3 ? "</svg>" : "");
      if (!Array.isArray(t3) || !t3.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
      return [void 0 !== e3$1 ? e3$1.createHTML(u2) : u2, n5];
    };
    var C$1 = class {
      constructor({ strings: t3, _$litType$: i3 }, e4) {
        let l4;
        this.parts = [];
        let h3 = 0, d3 = 0;
        const u2 = t3.length - 1, c3 = this.parts, [v2, a3] = E$1(t3, i3);
        if (this.el = C$1.createElement(v2, e4), A$1.currentNode = this.el.content, 2 === i3) {
          const t4 = this.el.content, i4 = t4.firstChild;
          i4.remove(), t4.append(...i4.childNodes);
        }
        for (; null !== (l4 = A$1.nextNode()) && c3.length < u2; ) {
          if (1 === l4.nodeType) {
            if (l4.hasAttributes()) {
              const t4 = [];
              for (const i4 of l4.getAttributeNames())
                if (i4.endsWith("$lit$") || i4.startsWith(o3$1)) {
                  const s5 = a3[d3++];
                  if (t4.push(i4), void 0 !== s5) {
                    const t5 = l4.getAttribute(s5.toLowerCase() + "$lit$").split(o3$1), i5 = /([.?@])?(.*)/.exec(s5);
                    c3.push({ type: 1, index: h3, name: i5[2], strings: t5, ctor: "." === i5[1] ? M : "?" === i5[1] ? k$1 : "@" === i5[1] ? H$1 : S2 });
                  } else
                    c3.push({ type: 6, index: h3 });
                }
              for (const i4 of t4)
                l4.removeAttribute(i4);
            }
            if ($.test(l4.tagName)) {
              const t4 = l4.textContent.split(o3$1), i4 = t4.length - 1;
              if (i4 > 0) {
                l4.textContent = s3 ? s3.emptyScript : "";
                for (let s5 = 0; s5 < i4; s5++)
                  l4.append(t4[s5], r3()), A$1.nextNode(), c3.push({ type: 2, index: ++h3 });
                l4.append(t4[i4], r3());
              }
            }
          } else if (8 === l4.nodeType)
            if (l4.data === n3)
              c3.push({ type: 2, index: h3 });
            else {
              let t4 = -1;
              for (; -1 !== (t4 = l4.data.indexOf(o3$1, t4 + 1)); )
                c3.push({ type: 7, index: h3 }), t4 += o3$1.length - 1;
            }
          h3++;
        }
      }
      static createElement(t3, i3) {
        const s5 = h2$1.createElement("template");
        return s5.innerHTML = t3, s5;
      }
    };
    function P(t3, i3, s5 = t3, e4) {
      var o5, n5, l4, h3;
      if (i3 === x$1)
        return i3;
      let r4 = void 0 !== e4 ? null === (o5 = s5._$Co) || void 0 === o5 ? void 0 : o5[e4] : s5._$Cl;
      const u2 = d2$1(i3) ? void 0 : i3._$litDirective$;
      return (null == r4 ? void 0 : r4.constructor) !== u2 && (null === (n5 = null == r4 ? void 0 : r4._$AO) || void 0 === n5 || n5.call(r4, false), void 0 === u2 ? r4 = void 0 : (r4 = new u2(t3), r4._$AT(t3, s5, e4)), void 0 !== e4 ? (null !== (l4 = (h3 = s5)._$Co) && void 0 !== l4 ? l4 : h3._$Co = [])[e4] = r4 : s5._$Cl = r4), void 0 !== r4 && (i3 = P(t3, r4._$AS(t3, i3.values), r4, e4)), i3;
    }
    var V$1 = class {
      constructor(t3, i3) {
        this.u = [], this._$AN = void 0, this._$AD = t3, this._$AM = i3;
      }
      get parentNode() {
        return this._$AM.parentNode;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      v(t3) {
        var i3;
        const { el: { content: s5 }, parts: e4 } = this._$AD, o5 = (null !== (i3 = null == t3 ? void 0 : t3.creationScope) && void 0 !== i3 ? i3 : h2$1).importNode(s5, true);
        A$1.currentNode = o5;
        let n5 = A$1.nextNode(), l4 = 0, r4 = 0, d3 = e4[0];
        for (; void 0 !== d3; ) {
          if (l4 === d3.index) {
            let i4;
            2 === d3.type ? i4 = new N(n5, n5.nextSibling, this, t3) : 1 === d3.type ? i4 = new d3.ctor(n5, d3.name, d3.strings, this, t3) : 6 === d3.type && (i4 = new I(n5, this, t3)), this.u.push(i4), d3 = e4[++r4];
          }
          l4 !== (null == d3 ? void 0 : d3.index) && (n5 = A$1.nextNode(), l4++);
        }
        return o5;
      }
      p(t3) {
        let i3 = 0;
        for (const s5 of this.u)
          void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t3, s5, i3), i3 += s5.strings.length - 2) : s5._$AI(t3[i3])), i3++;
      }
    };
    var N = class {
      constructor(t3, i3, s5, e4) {
        var o5;
        this.type = 2, this._$AH = b$1, this._$AN = void 0, this._$AA = t3, this._$AB = i3, this._$AM = s5, this.options = e4, this._$Cm = null === (o5 = null == e4 ? void 0 : e4.isConnected) || void 0 === o5 || o5;
      }
      get _$AU() {
        var t3, i3;
        return null !== (i3 = null === (t3 = this._$AM) || void 0 === t3 ? void 0 : t3._$AU) && void 0 !== i3 ? i3 : this._$Cm;
      }
      get parentNode() {
        let t3 = this._$AA.parentNode;
        const i3 = this._$AM;
        return void 0 !== i3 && 11 === t3.nodeType && (t3 = i3.parentNode), t3;
      }
      get startNode() {
        return this._$AA;
      }
      get endNode() {
        return this._$AB;
      }
      _$AI(t3, i3 = this) {
        t3 = P(this, t3, i3), d2$1(t3) ? t3 === b$1 || null == t3 || "" === t3 ? (this._$AH !== b$1 && this._$AR(), this._$AH = b$1) : t3 !== this._$AH && t3 !== x$1 && this.g(t3) : void 0 !== t3._$litType$ ? this.$(t3) : void 0 !== t3.nodeType ? this.T(t3) : c2$1(t3) ? this.k(t3) : this.g(t3);
      }
      O(t3, i3 = this._$AB) {
        return this._$AA.parentNode.insertBefore(t3, i3);
      }
      T(t3) {
        this._$AH !== t3 && (this._$AR(), this._$AH = this.O(t3));
      }
      g(t3) {
        this._$AH !== b$1 && d2$1(this._$AH) ? this._$AA.nextSibling.data = t3 : this.T(h2$1.createTextNode(t3)), this._$AH = t3;
      }
      $(t3) {
        var i3;
        const { values: s5, _$litType$: e4 } = t3, o5 = "number" == typeof e4 ? this._$AC(t3) : (void 0 === e4.el && (e4.el = C$1.createElement(e4.h, this.options)), e4);
        if ((null === (i3 = this._$AH) || void 0 === i3 ? void 0 : i3._$AD) === o5)
          this._$AH.p(s5);
        else {
          const t4 = new V$1(o5, this), i4 = t4.v(this.options);
          t4.p(s5), this.T(i4), this._$AH = t4;
        }
      }
      _$AC(t3) {
        let i3 = T.get(t3.strings);
        return void 0 === i3 && T.set(t3.strings, i3 = new C$1(t3)), i3;
      }
      k(t3) {
        u$1(this._$AH) || (this._$AH = [], this._$AR());
        const i3 = this._$AH;
        let s5, e4 = 0;
        for (const o5 of t3)
          e4 === i3.length ? i3.push(s5 = new N(this.O(r3()), this.O(r3()), this, this.options)) : s5 = i3[e4], s5._$AI(o5), e4++;
        e4 < i3.length && (this._$AR(s5 && s5._$AB.nextSibling, e4), i3.length = e4);
      }
      _$AR(t3 = this._$AA.nextSibling, i3) {
        var s5;
        for (null === (s5 = this._$AP) || void 0 === s5 || s5.call(this, false, true, i3); t3 && t3 !== this._$AB; ) {
          const i4 = t3.nextSibling;
          t3.remove(), t3 = i4;
        }
      }
      setConnected(t3) {
        var i3;
        void 0 === this._$AM && (this._$Cm = t3, null === (i3 = this._$AP) || void 0 === i3 || i3.call(this, t3));
      }
    };
    var S2 = class {
      constructor(t3, i3, s5, e4, o5) {
        this.type = 1, this._$AH = b$1, this._$AN = void 0, this.element = t3, this.name = i3, this._$AM = e4, this.options = o5, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = b$1;
      }
      get tagName() {
        return this.element.tagName;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t3, i3 = this, s5, e4) {
        const o5 = this.strings;
        let n5 = false;
        if (void 0 === o5)
          t3 = P(this, t3, i3, 0), n5 = !d2$1(t3) || t3 !== this._$AH && t3 !== x$1, n5 && (this._$AH = t3);
        else {
          const e5 = t3;
          let l4, h3;
          for (t3 = o5[0], l4 = 0; l4 < o5.length - 1; l4++)
            h3 = P(this, e5[s5 + l4], i3, l4), h3 === x$1 && (h3 = this._$AH[l4]), n5 || (n5 = !d2$1(h3) || h3 !== this._$AH[l4]), h3 === b$1 ? t3 = b$1 : t3 !== b$1 && (t3 += (null != h3 ? h3 : "") + o5[l4 + 1]), this._$AH[l4] = h3;
        }
        n5 && !e4 && this.j(t3);
      }
      j(t3) {
        t3 === b$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t3 ? t3 : "");
      }
    };
    var M = class extends S2 {
      constructor() {
        super(...arguments), this.type = 3;
      }
      j(t3) {
        this.element[this.name] = t3 === b$1 ? void 0 : t3;
      }
    };
    var R$1 = s3 ? s3.emptyScript : "";
    var k$1 = class extends S2 {
      constructor() {
        super(...arguments), this.type = 4;
      }
      j(t3) {
        t3 && t3 !== b$1 ? this.element.setAttribute(this.name, R$1) : this.element.removeAttribute(this.name);
      }
    };
    var H$1 = class extends S2 {
      constructor(t3, i3, s5, e4, o5) {
        super(t3, i3, s5, e4, o5), this.type = 5;
      }
      _$AI(t3, i3 = this) {
        var s5;
        if ((t3 = null !== (s5 = P(this, t3, i3, 0)) && void 0 !== s5 ? s5 : b$1) === x$1)
          return;
        const e4 = this._$AH, o5 = t3 === b$1 && e4 !== b$1 || t3.capture !== e4.capture || t3.once !== e4.once || t3.passive !== e4.passive, n5 = t3 !== b$1 && (e4 === b$1 || o5);
        o5 && this.element.removeEventListener(this.name, this, e4), n5 && this.element.addEventListener(this.name, this, t3), this._$AH = t3;
      }
      handleEvent(t3) {
        var i3, s5;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s5 = null === (i3 = this.options) || void 0 === i3 ? void 0 : i3.host) && void 0 !== s5 ? s5 : this.element, t3) : this._$AH.handleEvent(t3);
      }
    };
    var I = class {
      constructor(t3, i3, s5) {
        this.element = t3, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s5;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t3) {
        P(this, t3);
      }
    };
    var z$1 = i2$3.litHtmlPolyfillSupport;
    null == z$1 || z$1(C$1, N), (null !== (t2 = i2$3.litHtmlVersions) && void 0 !== t2 ? t2 : i2$3.litHtmlVersions = []).push("2.6.1");
    var Z = (t3, i3, s5) => {
      var e4, o5;
      const n5 = null !== (e4 = null == s5 ? void 0 : s5.renderBefore) && void 0 !== e4 ? e4 : i3;
      let l4 = n5._$litPart$;
      if (void 0 === l4) {
        const t4 = null !== (o5 = null == s5 ? void 0 : s5.renderBefore) && void 0 !== o5 ? o5 : null;
        n5._$litPart$ = l4 = new N(i3.insertBefore(r3(), t4), t4, void 0, null != s5 ? s5 : {});
      }
      return l4._$AI(t3), l4;
    };

    // node_modules/lit-element/lit-element.js
    var l3;
    var o4;
    var s4 = class extends d {
      constructor() {
        super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
      }
      createRenderRoot() {
        var t3, e4;
        const i3 = super.createRenderRoot();
        return null !== (t3 = (e4 = this.renderOptions).renderBefore) && void 0 !== t3 || (e4.renderBefore = i3.firstChild), i3;
      }
      update(t3) {
        const i3 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t3), this._$Dt = Z(i3, this.renderRoot, this.renderOptions);
      }
      connectedCallback() {
        var t3;
        super.connectedCallback(), null === (t3 = this._$Dt) || void 0 === t3 || t3.setConnected(true);
      }
      disconnectedCallback() {
        var t3;
        super.disconnectedCallback(), null === (t3 = this._$Dt) || void 0 === t3 || t3.setConnected(false);
      }
      render() {
        return x$1;
      }
    };
    s4.finalized = true, s4._$litElement$ = true, null === (l3 = globalThis.litElementHydrateSupport) || void 0 === l3 || l3.call(globalThis, { LitElement: s4 });
    var n4 = globalThis.litElementPolyfillSupport;
    null == n4 || n4({ LitElement: s4 });
    (null !== (o4 = globalThis.litElementVersions) && void 0 !== o4 ? o4 : globalThis.litElementVersions = []).push("3.2.0");
    /*! Bundled license information:

    @lit/reactive-element/css-tag.js:
      (**
       * @license
       * Copyright 2019 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/reactive-element.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    lit-html/lit-html.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    lit-element/lit-element.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    lit-html/is-server.js:
      (**
       * @license
       * Copyright 2022 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // src/styles/component.styles.ts
    var component_styles_default = i$3`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

    // src/components/alert/alert.styles.ts
    var alert_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    padding-inline-end: var(--sl-spacing-medium);
  }
`;

    // node_modules/lit-html/directive.js
    var t$2 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
    var e$2 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
    var i$2 = class {
      constructor(t2) {
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AT(t2, e2, i2) {
        this._$Ct = t2, this._$AM = e2, this._$Ci = i2;
      }
      _$AS(t2, e2) {
        return this.update(t2, e2);
      }
      update(t2, e2) {
        return this.render(...e2);
      }
    };
    /*! Bundled license information:

    lit-html/directive.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // node_modules/lit-html/directives/class-map.js
    var o$1 = e$2(class extends i$2 {
      constructor(t2) {
        var i2;
        if (super(t2), t2.type !== t$2.ATTRIBUTE || "class" !== t2.name || (null === (i2 = t2.strings) || void 0 === i2 ? void 0 : i2.length) > 2)
          throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
      }
      render(t2) {
        return " " + Object.keys(t2).filter((i2) => t2[i2]).join(" ") + " ";
      }
      update(i2, [s]) {
        var r, o2;
        if (void 0 === this.nt) {
          this.nt = /* @__PURE__ */ new Set(), void 0 !== i2.strings && (this.st = new Set(i2.strings.join(" ").split(/\s/).filter((t2) => "" !== t2)));
          for (const t2 in s)
            s[t2] && !(null === (r = this.st) || void 0 === r ? void 0 : r.has(t2)) && this.nt.add(t2);
          return this.render(s);
        }
        const e2 = i2.element.classList;
        this.nt.forEach((t2) => {
          t2 in s || (e2.remove(t2), this.nt.delete(t2));
        });
        for (const t2 in s) {
          const i3 = !!s[t2];
          i3 === this.nt.has(t2) || (null === (o2 = this.st) || void 0 === o2 ? void 0 : o2.has(t2)) || (i3 ? (e2.add(t2), this.nt.add(t2)) : (e2.remove(t2), this.nt.delete(t2)));
        }
        return x$1;
      }
    });
    /*! Bundled license information:

    lit-html/directives/class-map.js:
      (**
       * @license
       * Copyright 2018 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // node_modules/@lit/reactive-element/decorators/custom-element.js
    var e$1 = (e5) => (n2) => "function" == typeof n2 ? ((e6, n3) => (customElements.define(e6, n3), n3))(e5, n2) : ((e6, n3) => {
      const { kind: t2, elements: s2 } = n3;
      return { kind: t2, elements: s2, finisher(n4) {
        customElements.define(e6, n4);
      } };
    })(e5, n2);

    // node_modules/@lit/reactive-element/decorators/property.js
    var i$1 = (i3, e5) => "method" === e5.kind && e5.descriptor && !("value" in e5.descriptor) ? __spreadProps(__spreadValues({}, e5), { finisher(n2) {
      n2.createProperty(e5.key, i3);
    } }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e5.key, initializer() {
      "function" == typeof e5.initializer && (this[e5.key] = e5.initializer.call(this));
    }, finisher(n2) {
      n2.createProperty(e5.key, i3);
    } };
    function e2$1(e5) {
      return (n2, t2) => void 0 !== t2 ? ((i3, e6, n3) => {
        e6.constructor.createProperty(n3, i3);
      })(e5, n2, t2) : i$1(e5, n2);
    }

    // node_modules/@lit/reactive-element/decorators/state.js
    function t$1(t2) {
      return e2$1(__spreadProps(__spreadValues({}, t2), { state: true }));
    }

    // node_modules/@lit/reactive-element/decorators/base.js
    var o = ({ finisher: e5, descriptor: t2 }) => (o2, n2) => {
      var r;
      if (void 0 === n2) {
        const n3 = null !== (r = o2.originalKey) && void 0 !== r ? r : o2.key, i3 = null != t2 ? { kind: "method", placement: "prototype", key: n3, descriptor: t2(o2.key) } : __spreadProps(__spreadValues({}, o2), { key: n3 });
        return null != e5 && (i3.finisher = function(t3) {
          e5(t3, n3);
        }), i3;
      }
      {
        const r2 = o2.constructor;
        void 0 !== t2 && Object.defineProperty(o2, n2, t2(n2)), null == e5 || e5(r2, n2);
      }
    };

    // node_modules/@lit/reactive-element/decorators/query.js
    function i2$2(i3, n2) {
      return o({ descriptor: (o2) => {
        const t2 = { get() {
          var o3, n3;
          return null !== (n3 = null === (o3 = this.renderRoot) || void 0 === o3 ? void 0 : o3.querySelector(i3)) && void 0 !== n3 ? n3 : null;
        }, enumerable: true, configurable: true };
        if (n2) {
          const n3 = "symbol" == typeof o2 ? Symbol() : "__" + o2;
          t2.get = function() {
            var o3, t3;
            return void 0 === this[n3] && (this[n3] = null !== (t3 = null === (o3 = this.renderRoot) || void 0 === o3 ? void 0 : o3.querySelector(i3)) && void 0 !== t3 ? t3 : null), this[n3];
          };
        }
        return t2;
      } });
    }

    // node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
    var n$2;
    null != (null === (n$2 = window.HTMLSlotElement) || void 0 === n$2 ? void 0 : n$2.prototype.assignedElements) ? (o2, n2) => o2.assignedElements(n2) : (o2, n2) => o2.assignedNodes(n2).filter((o3) => o3.nodeType === Node.ELEMENT_NODE);

    // src/internal/shoelace-element.ts
    var ShoelaceElement = class extends s4 {
      /** Emits a custom event with more convenient defaults. */
      emit(name, options) {
        const event = new CustomEvent(name, __spreadValues({
          bubbles: true,
          cancelable: false,
          composed: true,
          detail: {}
        }, options));
        this.dispatchEvent(event);
        return event;
      }
    };
    __decorateClass([
      e2$1()
    ], ShoelaceElement.prototype, "dir", 2);
    __decorateClass([
      e2$1()
    ], ShoelaceElement.prototype, "lang", 2);
    /*! Bundled license information:

    @lit/reactive-element/decorators/custom-element.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/property.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/state.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/base.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/query.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/query-async.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/event-options.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/query-all.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/query-assigned-elements.js:
      (**
       * @license
       * Copyright 2021 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    @lit/reactive-element/decorators/query-assigned-nodes.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // src/components/alert/alert.ts
    var toastStack = Object.assign(document.createElement("div"), { className: "sl-toast-stack" });
    var SlAlert = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.hasSlotController = new HasSlotController(this, "icon", "suffix");
        this.localize = new LocalizeController2(this);
        this.open = false;
        this.closable = false;
        this.variant = "primary";
        this.duration = Infinity;
      }
      firstUpdated() {
        this.base.hidden = !this.open;
      }
      restartAutoHide() {
        clearTimeout(this.autoHideTimeout);
        if (this.open && this.duration < Infinity) {
          this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration);
        }
      }
      handleCloseClick() {
        this.hide();
      }
      handleMouseMove() {
        this.restartAutoHide();
      }
      async handleOpenChange() {
        if (this.open) {
          this.emit("sl-show");
          if (this.duration < Infinity) {
            this.restartAutoHide();
          }
          await stopAnimations(this.base);
          this.base.hidden = false;
          const { keyframes, options } = getAnimation(this, "alert.show", { dir: this.localize.dir() });
          await animateTo(this.base, keyframes, options);
          this.emit("sl-after-show");
        } else {
          this.emit("sl-hide");
          clearTimeout(this.autoHideTimeout);
          await stopAnimations(this.base);
          const { keyframes, options } = getAnimation(this, "alert.hide", { dir: this.localize.dir() });
          await animateTo(this.base, keyframes, options);
          this.base.hidden = true;
          this.emit("sl-after-hide");
        }
      }
      handleDurationChange() {
        this.restartAutoHide();
      }
      /** Shows the alert. */
      async show() {
        if (this.open) {
          return void 0;
        }
        this.open = true;
        return waitForEvent(this, "sl-after-show");
      }
      /** Hides the alert */
      async hide() {
        if (!this.open) {
          return void 0;
        }
        this.open = false;
        return waitForEvent(this, "sl-after-hide");
      }
      /**
       * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
       * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
       * calling this method again. The returned promise will resolve after the alert is hidden.
       */
      async toast() {
        return new Promise((resolve) => {
          if (toastStack.parentElement === null) {
            document.body.append(toastStack);
          }
          toastStack.appendChild(this);
          requestAnimationFrame(() => {
            this.clientWidth;
            this.show();
          });
          this.addEventListener(
            "sl-after-hide",
            () => {
              toastStack.removeChild(this);
              resolve();
              if (toastStack.querySelector("sl-alert") === null) {
                toastStack.remove();
              }
            },
            { once: true }
          );
        });
      }
      render() {
        return y`
      <div
        part="base"
        class=${o$1({
      alert: true,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mousemove=${this.handleMouseMove}
      >
        <slot name="icon" part="icon" class="alert__icon"></slot>

        <slot part="message" class="alert__message" aria-live="polite"></slot>

        ${this.closable ? y`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
      }
    };
    SlAlert.styles = alert_styles_default;
    __decorateClass([
      i2$2('[part~="base"]')
    ], SlAlert.prototype, "base", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlAlert.prototype, "open", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlAlert.prototype, "closable", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlAlert.prototype, "variant", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlAlert.prototype, "duration", 2);
    __decorateClass([
      watch("open", { waitUntilFirstUpdate: true })
    ], SlAlert.prototype, "handleOpenChange", 1);
    __decorateClass([
      watch("duration")
    ], SlAlert.prototype, "handleDurationChange", 1);
    SlAlert = __decorateClass([
      e$1("sl-alert")
    ], SlAlert);
    setDefaultAnimation("alert.show", {
      keyframes: [
        { opacity: 0, scale: 0.8 },
        { opacity: 1, scale: 1 }
      ],
      options: { duration: 250, easing: "ease" }
    });
    setDefaultAnimation("alert.hide", {
      keyframes: [
        { opacity: 1, scale: 1 },
        { opacity: 0, scale: 0.8 }
      ],
      options: { duration: 250, easing: "ease" }
    });

    // src/components/icon-button/icon-button.styles.ts
    var icon_button_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

    // node_modules/lit-html/static.js
    var e = Symbol.for("");
    var l$2 = (t) => {
      if ((null == t ? void 0 : t.r) === e)
        return null == t ? void 0 : t._$litStatic$;
    };
    var i = (t, ...r) => ({ _$litStatic$: r.reduce((r2, e2, l2) => r2 + ((t2) => {
      if (void 0 !== t2._$litStatic$)
        return t2._$litStatic$;
      throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t2}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
    })(e2) + t[l2 + 1], t[0]), r: e });
    var s$2 = /* @__PURE__ */ new Map();
    var a$1 = (t) => (r, ...e2) => {
      const o = e2.length;
      let i2, a2;
      const n2 = [], u2 = [];
      let c, $ = 0, f = false;
      for (; $ < o; ) {
        for (c = r[$]; $ < o && void 0 !== (a2 = e2[$], i2 = l$2(a2)); )
          c += i2 + r[++$], f = true;
        u2.push(a2), n2.push(c), $++;
      }
      if ($ === o && n2.push(r[o]), f) {
        const t2 = n2.join("$$lit$$");
        void 0 === (r = s$2.get(t2)) && (n2.raw = n2, s$2.set(t2, r = n2)), e2 = u2;
      }
      return t(r, ...e2);
    };
    var n$1 = a$1(y);
    /*! Bundled license information:

    lit-html/static.js:
      (**
       * @license
       * Copyright 2020 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // node_modules/lit-html/directives/if-defined.js
    var l$1 = (l2) => null != l2 ? l2 : b$1;
    /*! Bundled license information:

    lit-html/directives/if-defined.js:
      (**
       * @license
       * Copyright 2018 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // src/components/icon-button/icon-button.ts
    var SlIconButton = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.hasFocus = false;
        this.label = "";
        this.disabled = false;
      }
      handleBlur() {
        this.hasFocus = false;
        this.emit("sl-blur");
      }
      handleFocus() {
        this.hasFocus = true;
        this.emit("sl-focus");
      }
      handleClick(event) {
        if (this.disabled) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /** Simulates a click on the icon button. */
      click() {
        this.button.click();
      }
      /** Sets focus on the icon button. */
      focus(options) {
        this.button.focus(options);
      }
      /** Removes focus from the icon button. */
      blur() {
        this.button.blur();
      }
      render() {
        const isLink = this.href ? true : false;
        const tag = isLink ? i`a` : i`button`;
        return n$1`
      <${tag}
        part="base"
        class=${o$1({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${l$1(isLink ? void 0 : this.disabled)}
        type=${l$1(isLink ? void 0 : "button")}
        href=${l$1(isLink ? this.href : void 0)}
        target=${l$1(isLink ? this.target : void 0)}
        download=${l$1(isLink ? this.download : void 0)}
        rel=${l$1(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${l$1(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${l$1(this.name)}
          library=${l$1(this.library)}
          src=${l$1(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
      }
    };
    SlIconButton.styles = icon_button_styles_default;
    __decorateClass([
      i2$2(".icon-button")
    ], SlIconButton.prototype, "button", 2);
    __decorateClass([
      t$1()
    ], SlIconButton.prototype, "hasFocus", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "name", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "library", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "src", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "href", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "target", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "download", 2);
    __decorateClass([
      e2$1()
    ], SlIconButton.prototype, "label", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlIconButton.prototype, "disabled", 2);
    SlIconButton = __decorateClass([
      e$1("sl-icon-button")
    ], SlIconButton);

    // src/utilities/base-path.ts
    var basePath = "";
    function setBasePath(path) {
      basePath = path;
    }
    function getBasePath() {
      if (!basePath) {
        const scripts = [...document.getElementsByTagName("script")];
        const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
        if (configScript) {
          setBasePath(configScript.getAttribute("data-shoelace"));
        } else {
          const fallbackScript = scripts.find((s) => /shoelace(\.min)?\.js($|\?)/.test(s.src));
          let path = "";
          if (fallbackScript) {
            path = fallbackScript.getAttribute("src");
          }
          setBasePath(path.split("/").slice(0, -1).join("/"));
        }
      }
      return basePath.replace(/\/$/, "");
    }

    // src/components/icon/library.default.ts
    var library = {
      name: "default",
      resolver: (name) => `${getBasePath()}/assets/icons/${name}.svg`
    };
    var library_default_default = library;

    // src/components/icon/library.system.ts
    var icons = {
      caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
      check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
      "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
      "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
      "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
      eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
      "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
      eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
      "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
      indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
      "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
      "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
      "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
      radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
      "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
      "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
      "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
    };
    var systemLibrary = {
      name: "system",
      resolver: (name) => {
        if (name in icons) {
          return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
        }
        return "";
      }
    };
    var library_system_default = systemLibrary;

    // src/components/icon/library.ts
    var registry = [library_default_default, library_system_default];
    var watchedIcons = [];
    function watchIcon(icon) {
      watchedIcons.push(icon);
    }
    function unwatchIcon(icon) {
      watchedIcons = watchedIcons.filter((el) => el !== icon);
    }
    function getIconLibrary(name) {
      return registry.find((lib) => lib.name === name);
    }

    // src/components/include/request.ts
    var includeFiles = /* @__PURE__ */ new Map();
    function requestInclude(src, mode = "cors") {
      if (includeFiles.has(src)) {
        return includeFiles.get(src);
      }
      const fileDataPromise = fetch(src, { mode }).then(async (response) => {
        return {
          ok: response.ok,
          status: response.status,
          html: await response.text()
        };
      });
      includeFiles.set(src, fileDataPromise);
      return fileDataPromise;
    }

    // src/components/icon/request.ts
    var iconFiles = /* @__PURE__ */ new Map();
    async function requestIcon(url) {
      if (iconFiles.has(url)) {
        return iconFiles.get(url);
      }
      const fileData = await requestInclude(url);
      const iconFileData = {
        ok: fileData.ok,
        status: fileData.status,
        svg: null
      };
      if (fileData.ok) {
        const div = document.createElement("div");
        div.innerHTML = fileData.html;
        const svg = div.firstElementChild;
        iconFileData.svg = (svg == null ? void 0 : svg.tagName.toLowerCase()) === "svg" ? svg.outerHTML : "";
      }
      iconFiles.set(url, iconFileData);
      return iconFileData;
    }

    // src/components/icon/icon.styles.ts
    var icon_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

    // node_modules/lit-html/directives/unsafe-html.js
    var e4 = class extends i$2 {
      constructor(i2) {
        if (super(i2), this.it = b$1, i2.type !== t$2.CHILD)
          throw Error(this.constructor.directiveName + "() can only be used in child bindings");
      }
      render(r) {
        if (r === b$1 || null == r)
          return this._t = void 0, this.it = r;
        if (r === x$1)
          return r;
        if ("string" != typeof r)
          throw Error(this.constructor.directiveName + "() called with a non-string value");
        if (r === this.it)
          return this._t;
        this.it = r;
        const s = [r];
        return s.raw = s, this._t = { _$litType$: this.constructor.resultType, strings: s, values: [] };
      }
    };
    e4.directiveName = "unsafeHTML", e4.resultType = 1;

    // node_modules/lit-html/directives/unsafe-svg.js
    var t3 = class extends e4 {
    };
    t3.directiveName = "unsafeSVG", t3.resultType = 2;
    var o2$1 = e$2(t3);

    // src/components/icon/icon.ts
    var parser;
    var SlIcon = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.svg = "";
        this.label = "";
        this.library = "default";
      }
      connectedCallback() {
        super.connectedCallback();
        watchIcon(this);
      }
      firstUpdated() {
        this.setIcon();
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        unwatchIcon(this);
      }
      getUrl() {
        const library = getIconLibrary(this.library);
        if (this.name && library) {
          return library.resolver(this.name);
        }
        return this.src;
      }
      handleLabelChange() {
        const hasLabel = typeof this.label === "string" && this.label.length > 0;
        if (hasLabel) {
          this.setAttribute("role", "img");
          this.setAttribute("aria-label", this.label);
          this.removeAttribute("aria-hidden");
        } else {
          this.removeAttribute("role");
          this.removeAttribute("aria-label");
          this.setAttribute("aria-hidden", "true");
        }
      }
      async setIcon() {
        var _a;
        const library = getIconLibrary(this.library);
        const url = this.getUrl();
        if (!parser) {
          parser = new DOMParser();
        }
        if (url) {
          try {
            const file = await requestIcon(url);
            if (url !== this.getUrl()) {
              return;
            } else if (file.ok) {
              const doc = parser.parseFromString(file.svg, "text/html");
              const svgEl = doc.body.querySelector("svg");
              if (svgEl !== null) {
                (_a = library == null ? void 0 : library.mutator) == null ? void 0 : _a.call(library, svgEl);
                this.svg = svgEl.outerHTML;
                this.emit("sl-load");
              } else {
                this.svg = "";
                this.emit("sl-error");
              }
            } else {
              this.svg = "";
              this.emit("sl-error");
            }
          } catch (e5) {
            this.emit("sl-error");
          }
        } else if (this.svg.length > 0) {
          this.svg = "";
        }
      }
      render() {
        return y` ${o2$1(this.svg)} `;
      }
    };
    SlIcon.styles = icon_styles_default;
    __decorateClass([
      t$1()
    ], SlIcon.prototype, "svg", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlIcon.prototype, "name", 2);
    __decorateClass([
      e2$1()
    ], SlIcon.prototype, "src", 2);
    __decorateClass([
      e2$1()
    ], SlIcon.prototype, "label", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlIcon.prototype, "library", 2);
    __decorateClass([
      watch("label")
    ], SlIcon.prototype, "handleLabelChange", 1);
    __decorateClass([
      watch(["name", "src", "library"])
    ], SlIcon.prototype, "setIcon", 1);
    SlIcon = __decorateClass([
      e$1("sl-icon")
    ], SlIcon);
    /*! Bundled license information:

    lit-html/directives/unsafe-html.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    lit-html/directives/unsafe-svg.js:
      (**
       * @license
       * Copyright 2017 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // src/components/badge/badge.styles.ts
    var badge_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`;

    // src/components/badge/badge.ts
    var SlBadge = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.variant = "primary";
        this.pill = false;
        this.pulse = false;
      }
      render() {
        return y`
      <slot
        part="base"
        class=${o$1({
      badge: true,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      ></slot>
    `;
      }
    };
    SlBadge.styles = badge_styles_default;
    __decorateClass([
      e2$1({ reflect: true })
    ], SlBadge.prototype, "variant", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlBadge.prototype, "pill", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlBadge.prototype, "pulse", 2);
    SlBadge = __decorateClass([
      e$1("sl-badge")
    ], SlBadge);

    // src/internal/form.ts
    var formCollections = /* @__PURE__ */ new WeakMap();
    var userInteractedControls = /* @__PURE__ */ new WeakMap();
    var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
    var FormControlController = class {
      constructor(host, options) {
        (this.host = host).addController(this);
        this.options = __spreadValues({
          form: (input) => {
            if (input.hasAttribute("form") && input.getAttribute("form") !== "") {
              const root = input.getRootNode();
              const formId = input.getAttribute("form");
              if (formId) {
                return root.getElementById(formId);
              }
            }
            return input.closest("form");
          },
          name: (input) => input.name,
          value: (input) => input.value,
          defaultValue: (input) => input.defaultValue,
          disabled: (input) => {
            var _a;
            return (_a = input.disabled) != null ? _a : false;
          },
          reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
          setValue: (input, value) => input.value = value
        }, options);
        this.handleFormData = this.handleFormData.bind(this);
        this.handleFormSubmit = this.handleFormSubmit.bind(this);
        this.handleFormReset = this.handleFormReset.bind(this);
        this.reportFormValidity = this.reportFormValidity.bind(this);
        this.handleUserInput = this.handleUserInput.bind(this);
      }
      hostConnected() {
        const form = this.options.form(this.host);
        if (form) {
          this.attachForm(form);
        }
        this.host.addEventListener("sl-input", this.handleUserInput);
      }
      hostDisconnected() {
        this.detachForm();
        this.host.removeEventListener("sl-input", this.handleUserInput);
      }
      hostUpdated() {
        const form = this.options.form(this.host);
        if (!form) {
          this.detachForm();
        }
        if (form && this.form !== form) {
          this.detachForm();
          this.attachForm(form);
        }
        if (this.host.hasUpdated) {
          this.setValidity(this.host.checkValidity());
        }
      }
      attachForm(form) {
        if (form) {
          this.form = form;
          if (formCollections.has(this.form)) {
            formCollections.get(this.form).add(this.host);
          } else {
            formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
          }
          this.form.addEventListener("formdata", this.handleFormData);
          this.form.addEventListener("submit", this.handleFormSubmit);
          this.form.addEventListener("reset", this.handleFormReset);
          if (!reportValidityOverloads.has(this.form)) {
            reportValidityOverloads.set(this.form, this.form.reportValidity);
            this.form.reportValidity = () => this.reportFormValidity();
          }
        } else {
          this.form = void 0;
        }
      }
      detachForm() {
        var _a;
        if (this.form) {
          (_a = formCollections.get(this.form)) == null ? void 0 : _a.delete(this.host);
          this.form.removeEventListener("formdata", this.handleFormData);
          this.form.removeEventListener("submit", this.handleFormSubmit);
          this.form.removeEventListener("reset", this.handleFormReset);
          if (reportValidityOverloads.has(this.form)) {
            this.form.reportValidity = reportValidityOverloads.get(this.form);
            reportValidityOverloads.delete(this.form);
          }
        }
        this.form = void 0;
      }
      handleFormData(event) {
        const disabled = this.options.disabled(this.host);
        const name = this.options.name(this.host);
        const value = this.options.value(this.host);
        const isButton = this.host.tagName.toLowerCase() === "sl-button";
        if (!disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
          if (Array.isArray(value)) {
            value.forEach((val) => {
              event.formData.append(name, val.toString());
            });
          } else {
            event.formData.append(name, value.toString());
          }
        }
      }
      handleFormSubmit(event) {
        var _a;
        const disabled = this.options.disabled(this.host);
        const reportValidity = this.options.reportValidity;
        if (this.form && !this.form.noValidate) {
          (_a = formCollections.get(this.form)) == null ? void 0 : _a.forEach((control) => {
            this.setUserInteracted(control, true);
          });
        }
        if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      }
      handleFormReset() {
        this.options.setValue(this.host, this.options.defaultValue(this.host));
        this.setUserInteracted(this.host, false);
      }
      async handleUserInput() {
        await this.host.updateComplete;
        this.setUserInteracted(this.host, true);
      }
      reportFormValidity() {
        if (this.form && !this.form.noValidate) {
          const elements = this.form.querySelectorAll("*");
          for (const element of elements) {
            if (typeof element.reportValidity === "function") {
              if (!element.reportValidity()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      setUserInteracted(el, hasInteracted) {
        userInteractedControls.set(el, hasInteracted);
        el.requestUpdate();
      }
      doAction(type, invoker) {
        if (this.form) {
          const button = document.createElement("button");
          button.type = type;
          button.style.position = "absolute";
          button.style.width = "0";
          button.style.height = "0";
          button.style.clipPath = "inset(50%)";
          button.style.overflow = "hidden";
          button.style.whiteSpace = "nowrap";
          if (invoker) {
            button.name = invoker.name;
            button.value = invoker.value;
            ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
              if (invoker.hasAttribute(attr)) {
                button.setAttribute(attr, invoker.getAttribute(attr));
              }
            });
          }
          this.form.append(button);
          button.click();
          button.remove();
        }
      }
      /** Resets the form, restoring all the control to their default value */
      reset(invoker) {
        this.doAction("reset", invoker);
      }
      /** Submits the form, triggering validation and form data injection. */
      submit(invoker) {
        this.doAction("submit", invoker);
      }
      /**
       * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
       * the host element immediately, i.e. before Lit updates the component in the next update.
       */
      setValidity(isValid) {
        var _a;
        const host = this.host;
        const hasInteracted = Boolean(userInteractedControls.get(host));
        const required = Boolean(host.required);
        if ((_a = this.form) == null ? void 0 : _a.noValidate) {
          host.removeAttribute("data-required");
          host.removeAttribute("data-optional");
          host.removeAttribute("data-invalid");
          host.removeAttribute("data-valid");
          host.removeAttribute("data-user-invalid");
          host.removeAttribute("data-user-valid");
        } else {
          host.toggleAttribute("data-required", required);
          host.toggleAttribute("data-optional", !required);
          host.toggleAttribute("data-invalid", !isValid);
          host.toggleAttribute("data-valid", isValid);
          host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
          host.toggleAttribute("data-user-valid", isValid && hasInteracted);
        }
      }
      /**
       * Updates the form control's validity based on the current value of `host.checkValidity()`. Call this when anything
       * that affects constraint validation changes so the component receives the correct validity states.
       */
      updateValidity() {
        const host = this.host;
        this.setValidity(host.checkValidity());
      }
    };

    // src/components/button/button.styles.ts
    var button_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition: var(--sl-transition-x-fast) background-color, var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border, var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    font-size: var(--sl-button-font-size-small);
    height: var(--sl-input-height-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    font-size: var(--sl-button-font-size-medium);
    height: var(--sl-input-height-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    font-size: var(--sl-button-font-size-large);
    height: var(--sl-input-height-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;

    // src/components/button/button.ts
    var SlButton = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.formControlController = new FormControlController(this, {
          form: (input) => {
            if (input.hasAttribute("form")) {
              const doc = input.getRootNode();
              const formId = input.getAttribute("form");
              return doc.getElementById(formId);
            }
            return input.closest("form");
          }
        });
        this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
        this.localize = new LocalizeController2(this);
        this.hasFocus = false;
        this.invalid = false;
        this.title = "";
        this.variant = "default";
        this.size = "medium";
        this.caret = false;
        this.disabled = false;
        this.loading = false;
        this.outline = false;
        this.pill = false;
        this.circle = false;
        this.type = "button";
        this.name = "";
        this.value = "";
        this.href = "";
      }
      firstUpdated() {
        if (this.isButton()) {
          this.formControlController.updateValidity();
        }
      }
      handleBlur() {
        this.hasFocus = false;
        this.emit("sl-blur");
      }
      handleFocus() {
        this.hasFocus = true;
        this.emit("sl-focus");
      }
      handleClick(event) {
        if (this.disabled || this.loading) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }
        if (this.type === "submit") {
          this.formControlController.submit(this);
        }
        if (this.type === "reset") {
          this.formControlController.reset(this);
        }
      }
      isButton() {
        return this.href ? false : true;
      }
      isLink() {
        return this.href ? true : false;
      }
      handleDisabledChange() {
        if (this.isButton()) {
          this.formControlController.setValidity(this.disabled);
        }
      }
      /** Simulates a click on the button. */
      click() {
        this.button.click();
      }
      /** Sets focus on the button. */
      focus(options) {
        this.button.focus(options);
      }
      /** Removes focus from the button. */
      blur() {
        this.button.blur();
      }
      /** Checks for validity but does not show the browser's validation message. */
      checkValidity() {
        if (this.isButton()) {
          return this.button.checkValidity();
        }
        return true;
      }
      /** Checks for validity and shows the browser's validation message if the control is invalid. */
      reportValidity() {
        if (this.isButton()) {
          return this.button.reportValidity();
        }
        return true;
      }
      /** Sets a custom validation message. Pass an empty string to restore validity. */
      setCustomValidity(message) {
        if (this.isButton()) {
          this.button.setCustomValidity(message);
          this.formControlController.updateValidity();
        }
      }
      render() {
        const isLink = this.isLink();
        const tag = isLink ? i`a` : i`button`;
        return n$1`
      <${tag}
        part="base"
        class=${o$1({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${l$1(isLink ? void 0 : this.disabled)}
        type=${l$1(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${l$1(isLink ? void 0 : this.name)}
        value=${l$1(isLink ? void 0 : this.value)}
        href=${l$1(isLink ? this.href : void 0)}
        target=${l$1(isLink ? this.target : void 0)}
        download=${l$1(isLink ? this.download : void 0)}
        rel=${l$1(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${l$1(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? n$1` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? n$1`<sl-spinner></sl-spinner>` : ""}
      </${tag}>
    `;
      }
    };
    SlButton.styles = button_styles_default;
    __decorateClass([
      i2$2(".button")
    ], SlButton.prototype, "button", 2);
    __decorateClass([
      t$1()
    ], SlButton.prototype, "hasFocus", 2);
    __decorateClass([
      t$1()
    ], SlButton.prototype, "invalid", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "title", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlButton.prototype, "variant", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlButton.prototype, "size", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlButton.prototype, "caret", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlButton.prototype, "disabled", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlButton.prototype, "loading", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlButton.prototype, "outline", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlButton.prototype, "pill", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlButton.prototype, "circle", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "type", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "name", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "value", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "href", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "target", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "download", 2);
    __decorateClass([
      e2$1()
    ], SlButton.prototype, "form", 2);
    __decorateClass([
      e2$1({ attribute: "formaction" })
    ], SlButton.prototype, "formAction", 2);
    __decorateClass([
      e2$1({ attribute: "formenctype" })
    ], SlButton.prototype, "formEnctype", 2);
    __decorateClass([
      e2$1({ attribute: "formmethod" })
    ], SlButton.prototype, "formMethod", 2);
    __decorateClass([
      e2$1({ attribute: "formnovalidate", type: Boolean })
    ], SlButton.prototype, "formNoValidate", 2);
    __decorateClass([
      e2$1({ attribute: "formtarget" })
    ], SlButton.prototype, "formTarget", 2);
    __decorateClass([
      watch("disabled", { waitUntilFirstUpdate: true })
    ], SlButton.prototype, "handleDisabledChange", 1);
    SlButton = __decorateClass([
      e$1("sl-button")
    ], SlButton);

    // src/components/spinner/spinner.styles.ts
    var spinner_styles_default = i$3`
  ${component_styles_default}

  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
    mix-blend-mode: multiply;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.01em, 2.75em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.01em, 2.75em;
    }
  }
`;

    // src/components/spinner/spinner.ts
    var SlSpinner = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.localize = new LocalizeController2(this);
      }
      render() {
        return y`
      <svg part="base" class="spinner" role="progressbar" aria-valuetext=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
      }
    };
    SlSpinner.styles = spinner_styles_default;
    SlSpinner = __decorateClass([
      e$1("sl-spinner")
    ], SlSpinner);

    // src/internal/tabbable.ts
    function isTabbable(el) {
      const tag = el.tagName.toLowerCase();
      if (el.getAttribute("tabindex") === "-1") {
        return false;
      }
      if (el.hasAttribute("disabled")) {
        return false;
      }
      if (el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") !== "false") {
        return false;
      }
      if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
        return false;
      }
      if (el.offsetParent === null) {
        return false;
      }
      if (window.getComputedStyle(el).visibility === "hidden") {
        return false;
      }
      if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
        return true;
      }
      if (el.hasAttribute("tabindex")) {
        return true;
      }
      if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
        return true;
      }
      return ["button", "input", "select", "textarea", "a", "audio", "video", "summary"].includes(tag);
    }
    function getTabbableBoundary(root) {
      var _a, _b;
      const allElements = [];
      function walk(el) {
        if (el instanceof HTMLElement) {
          allElements.push(el);
          if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
            walk(el.shadowRoot);
          }
        }
        [...el.children].forEach((e) => walk(e));
      }
      walk(root);
      const start = (_a = allElements.find((el) => isTabbable(el))) != null ? _a : null;
      const end = (_b = allElements.reverse().find((el) => isTabbable(el))) != null ? _b : null;
      return { start, end };
    }

    // src/internal/modal.ts
    var activeModals = [];
    var Modal = class {
      constructor(element) {
        this.tabDirection = "forward";
        this.element = element;
        this.handleFocusIn = this.handleFocusIn.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
      }
      activate() {
        activeModals.push(this.element);
        document.addEventListener("focusin", this.handleFocusIn);
        document.addEventListener("keydown", this.handleKeyDown);
        document.addEventListener("keyup", this.handleKeyUp);
      }
      deactivate() {
        activeModals = activeModals.filter((modal) => modal !== this.element);
        document.removeEventListener("focusin", this.handleFocusIn);
        document.removeEventListener("keydown", this.handleKeyDown);
        document.removeEventListener("keyup", this.handleKeyUp);
      }
      isActive() {
        return activeModals[activeModals.length - 1] === this.element;
      }
      checkFocus() {
        if (this.isActive()) {
          if (!this.element.matches(":focus-within")) {
            const { start, end } = getTabbableBoundary(this.element);
            const target = this.tabDirection === "forward" ? start : end;
            if (typeof (target == null ? void 0 : target.focus) === "function") {
              target.focus({ preventScroll: true });
            }
          }
        }
      }
      handleFocusIn() {
        this.checkFocus();
      }
      handleKeyDown(event) {
        if (event.key === "Tab" && event.shiftKey) {
          this.tabDirection = "backward";
          requestAnimationFrame(() => this.checkFocus());
        }
      }
      handleKeyUp() {
        this.tabDirection = "forward";
      }
    };

    // src/internal/offset.ts
    function getOffset(element, parent) {
      return {
        top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
        left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
      };
    }

    // src/internal/scroll.ts
    var locks = /* @__PURE__ */ new Set();
    function getScrollbarWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    function lockBodyScrolling(lockingEl) {
      locks.add(lockingEl);
      if (!document.body.classList.contains("sl-scroll-lock")) {
        const scrollbarWidth = getScrollbarWidth();
        document.body.classList.add("sl-scroll-lock");
        document.body.style.setProperty("--sl-scroll-lock-size", `${scrollbarWidth}px`);
      }
    }
    function unlockBodyScrolling(lockingEl) {
      locks.delete(lockingEl);
      if (locks.size === 0) {
        document.body.classList.remove("sl-scroll-lock");
        document.body.style.removeProperty("--sl-scrollbar-width");
      }
    }
    function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
      const offset = getOffset(element, container);
      const offsetTop = offset.top + container.scrollTop;
      const offsetLeft = offset.left + container.scrollLeft;
      const minX = container.scrollLeft;
      const maxX = container.scrollLeft + container.offsetWidth;
      const minY = container.scrollTop;
      const maxY = container.scrollTop + container.offsetHeight;
      if (direction === "horizontal" || direction === "both") {
        if (offsetLeft < minX) {
          container.scrollTo({ left: offsetLeft, behavior });
        } else if (offsetLeft + element.clientWidth > maxX) {
          container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
        }
      }
      if (direction === "vertical" || direction === "both") {
        if (offsetTop < minY) {
          container.scrollTo({ top: offsetTop, behavior });
        } else if (offsetTop + element.clientHeight > maxY) {
          container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
        }
      }
    }

    // src/components/dialog/dialog.styles.ts
    var dialog_styles_default = i$3`
  ${component_styles_default}

  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;

    // src/components/dialog/dialog.ts
    var SlDialog = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.hasSlotController = new HasSlotController(this, "footer");
        this.localize = new LocalizeController2(this);
        this.open = false;
        this.label = "";
        this.noHeader = false;
      }
      connectedCallback() {
        super.connectedCallback();
        this.handleDocumentKeyDown = this.handleDocumentKeyDown.bind(this);
        this.modal = new Modal(this);
      }
      firstUpdated() {
        this.dialog.hidden = !this.open;
        if (this.open) {
          this.addOpenListeners();
          this.modal.activate();
          lockBodyScrolling(this);
        }
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        unlockBodyScrolling(this);
      }
      requestClose(source) {
        const slRequestClose = this.emit("sl-request-close", {
          cancelable: true,
          detail: { source }
        });
        if (slRequestClose.defaultPrevented) {
          const animation = getAnimation(this, "dialog.denyClose", { dir: this.localize.dir() });
          animateTo(this.panel, animation.keyframes, animation.options);
          return;
        }
        this.hide();
      }
      addOpenListeners() {
        document.addEventListener("keydown", this.handleDocumentKeyDown);
      }
      removeOpenListeners() {
        document.removeEventListener("keydown", this.handleDocumentKeyDown);
      }
      handleDocumentKeyDown(event) {
        if (this.open && event.key === "Escape") {
          event.stopPropagation();
          this.requestClose("keyboard");
        }
      }
      async handleOpenChange() {
        if (this.open) {
          this.emit("sl-show");
          this.addOpenListeners();
          this.originalTrigger = document.activeElement;
          this.modal.activate();
          lockBodyScrolling(this);
          const autoFocusTarget = this.querySelector("[autofocus]");
          if (autoFocusTarget) {
            autoFocusTarget.removeAttribute("autofocus");
          }
          await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
          this.dialog.hidden = false;
          requestAnimationFrame(() => {
            const slInitialFocus = this.emit("sl-initial-focus", { cancelable: true });
            if (!slInitialFocus.defaultPrevented) {
              if (autoFocusTarget) {
                autoFocusTarget.focus({ preventScroll: true });
              } else {
                this.panel.focus({ preventScroll: true });
              }
            }
            if (autoFocusTarget) {
              autoFocusTarget.setAttribute("autofocus", "");
            }
          });
          const panelAnimation = getAnimation(this, "dialog.show", { dir: this.localize.dir() });
          const overlayAnimation = getAnimation(this, "dialog.overlay.show", { dir: this.localize.dir() });
          await Promise.all([
            animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
            animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
          ]);
          this.emit("sl-after-show");
        } else {
          this.emit("sl-hide");
          this.removeOpenListeners();
          this.modal.deactivate();
          await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
          const panelAnimation = getAnimation(this, "dialog.hide", { dir: this.localize.dir() });
          const overlayAnimation = getAnimation(this, "dialog.overlay.hide", { dir: this.localize.dir() });
          await Promise.all([
            animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {
              this.overlay.hidden = true;
            }),
            animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {
              this.panel.hidden = true;
            })
          ]);
          this.dialog.hidden = true;
          this.overlay.hidden = false;
          this.panel.hidden = false;
          unlockBodyScrolling(this);
          const trigger = this.originalTrigger;
          if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
            setTimeout(() => trigger.focus());
          }
          this.emit("sl-after-hide");
        }
      }
      /** Shows the dialog. */
      async show() {
        if (this.open) {
          return void 0;
        }
        this.open = true;
        return waitForEvent(this, "sl-after-show");
      }
      /** Hides the dialog */
      async hide() {
        if (!this.open) {
          return void 0;
        }
        this.open = false;
        return waitForEvent(this, "sl-after-hide");
      }
      render() {
        return y`
      <div
        part="base"
        class=${o$1({
      dialog: true,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${l$1(this.noHeader ? this.label : void 0)}
          aria-labelledby=${l$1(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${!this.noHeader ? y`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              ` : ""}

          <slot part="body" class="dialog__body"></slot>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
      }
    };
    SlDialog.styles = dialog_styles_default;
    __decorateClass([
      i2$2(".dialog")
    ], SlDialog.prototype, "dialog", 2);
    __decorateClass([
      i2$2(".dialog__panel")
    ], SlDialog.prototype, "panel", 2);
    __decorateClass([
      i2$2(".dialog__overlay")
    ], SlDialog.prototype, "overlay", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlDialog.prototype, "open", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlDialog.prototype, "label", 2);
    __decorateClass([
      e2$1({ attribute: "no-header", type: Boolean, reflect: true })
    ], SlDialog.prototype, "noHeader", 2);
    __decorateClass([
      watch("open", { waitUntilFirstUpdate: true })
    ], SlDialog.prototype, "handleOpenChange", 1);
    SlDialog = __decorateClass([
      e$1("sl-dialog")
    ], SlDialog);
    setDefaultAnimation("dialog.show", {
      keyframes: [
        { opacity: 0, scale: 0.8 },
        { opacity: 1, scale: 1 }
      ],
      options: { duration: 250, easing: "ease" }
    });
    setDefaultAnimation("dialog.hide", {
      keyframes: [
        { opacity: 1, scale: 1 },
        { opacity: 0, scale: 0.8 }
      ],
      options: { duration: 250, easing: "ease" }
    });
    setDefaultAnimation("dialog.denyClose", {
      keyframes: [{ scale: 1 }, { scale: 1.02 }, { scale: 1 }],
      options: { duration: 250 }
    });
    setDefaultAnimation("dialog.overlay.show", {
      keyframes: [{ opacity: 0 }, { opacity: 1 }],
      options: { duration: 250 }
    });
    setDefaultAnimation("dialog.overlay.hide", {
      keyframes: [{ opacity: 1 }, { opacity: 0 }],
      options: { duration: 250 }
    });

    // src/internal/drag.ts
    function drag(container, options) {
      function move(pointerEvent) {
        const dims = container.getBoundingClientRect();
        const defaultView = container.ownerDocument.defaultView;
        const offsetX = dims.left + defaultView.pageXOffset;
        const offsetY = dims.top + defaultView.pageYOffset;
        const x = pointerEvent.pageX - offsetX;
        const y = pointerEvent.pageY - offsetY;
        if (options == null ? void 0 : options.onMove) {
          options.onMove(x, y);
        }
      }
      function stop() {
        document.removeEventListener("pointermove", move);
        document.removeEventListener("pointerup", stop);
        if (options == null ? void 0 : options.onStop) {
          options.onStop();
        }
      }
      document.addEventListener("pointermove", move, { passive: true });
      document.addEventListener("pointerup", stop);
      if ((options == null ? void 0 : options.initialEvent) instanceof PointerEvent) {
        move(options.initialEvent);
      }
    }

    // src/internal/math.ts
    function clamp(value, min, max) {
      const noNegativeZero = (n) => Object.is(n, -0) ? 0 : n;
      if (value < min) {
        return noNegativeZero(min);
      }
      if (value > max) {
        return noNegativeZero(max);
      }
      return noNegativeZero(value);
    }

    // node_modules/lit-html/directives/style-map.js
    var i2$1 = e$2(class extends i$2 {
      constructor(t2) {
        var e2;
        if (super(t2), t2.type !== t$2.ATTRIBUTE || "style" !== t2.name || (null === (e2 = t2.strings) || void 0 === e2 ? void 0 : e2.length) > 2)
          throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
      }
      render(t2) {
        return Object.keys(t2).reduce((e2, r) => {
          const s = t2[r];
          return null == s ? e2 : e2 + `${r = r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
        }, "");
      }
      update(e2, [r]) {
        const { style: s } = e2.element;
        if (void 0 === this.vt) {
          this.vt = /* @__PURE__ */ new Set();
          for (const t2 in r)
            this.vt.add(t2);
          return this.render(r);
        }
        this.vt.forEach((t2) => {
          null == r[t2] && (this.vt.delete(t2), t2.includes("-") ? s.removeProperty(t2) : s[t2] = "");
        });
        for (const t2 in r) {
          const e3 = r[t2];
          null != e3 && (this.vt.add(t2), t2.includes("-") ? s.setProperty(t2, e3) : s[t2] = e3);
        }
        return x$1;
      }
    });
    /*! Bundled license information:

    lit-html/directives/style-map.js:
      (**
       * @license
       * Copyright 2018 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // src/components/color-picker/color-picker.styles.ts
    var color_picker_styles_default = i$3`
  ${component_styles_default}

  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position: 0 0, 0 0, -5px -5px, 5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow: inset 0 0 0 2px var(--sl-input-border-color), inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

    // src/internal/default-value.ts
    var defaultValue = (propertyName = "value") => (proto, key) => {
      const ctor = proto.constructor;
      const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
      ctor.prototype.attributeChangedCallback = function(name, old, value) {
        var _a;
        const options = ctor.getPropertyOptions(propertyName);
        const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
        if (name === attributeName) {
          const converter = options.converter || n2$1;
          const fromAttribute = typeof converter === "function" ? converter : (_a = converter == null ? void 0 : converter.fromAttribute) != null ? _a : n2$1.fromAttribute;
          const newValue = fromAttribute(value, options.type);
          if (this[propertyName] !== newValue) {
            this[key] = newValue;
          }
        }
        attributeChangedCallback.call(this, name, old, value);
      };
    };

    // node_modules/@ctrl/tinycolor/dist/module/util.js
    function bound01(n, max) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var isPercent = isPercentage(n);
      n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max), 10) / 100;
      }
      if (Math.abs(n - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
      } else {
        n = n % max / parseFloat(String(max));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c) {
      return c.length === 1 ? "0" + c : String(c);
    }

    // node_modules/@ctrl/tinycolor/dist/module/conversion.js
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h = 0;
      var s = 0;
      var l2 = (max + min) / 2;
      if (max === min) {
        s = 0;
        h = 0;
      } else {
        var d = max - min;
        s = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h, s, l: l2 };
    }
    function hue2rgb(p, q, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p + (q - p) * (6 * t2);
      }
      if (t2 < 1 / 2) {
        return q;
      }
      if (t2 < 2 / 3) {
        return p + (q - p) * (2 / 3 - t2) * 6;
      }
      return p;
    }
    function hslToRgb(h, s, l2) {
      var r;
      var g;
      var b;
      h = bound01(h, 360);
      s = bound01(s, 100);
      l2 = bound01(l2, 100);
      if (s === 0) {
        g = l2;
        b = l2;
        r = l2;
      } else {
        var q = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
        var p = 2 * l2 - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h = 0;
      var v = max;
      var d = max - min;
      var s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h, s, v };
    }
    function hsvToRgb(h, s, v) {
      h = bound01(h, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i3 = Math.floor(h);
      var f = h - i3;
      var p = v * (1 - s);
      var q = v * (1 - f * s);
      var t2 = v * (1 - (1 - f) * s);
      var mod = i3 % 6;
      var r = [v, q, p, p, t2, v][mod];
      var g = [t2, v, v, q, p, p][mod];
      var b = [p, p, t2, v, v, q][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h) {
      return parseIntFromHex(h) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }

    // node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };

    // node_modules/@ctrl/tinycolor/dist/module/format-input.js
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v = null;
      var l2 = null;
      var ok = false;
      var format = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l2);
          ok = true;
          format = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }

    // node_modules/@ctrl/tinycolor/dist/module/index.js
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R;
          var G;
          var B;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R = RsRGB / 12.92;
          } else {
            R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G = GsRGB / 12.92;
          } else {
            G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B = BsRGB / 12.92;
          } else {
            B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h = Math.round(hsl.h * 360);
          var s = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r = Math.round(this.r);
          var g = Math.round(this.g);
          var b = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x) {
            return "".concat(Math.round(bound01(x, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x) {
            return Math.round(bound01(x, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format) {
          var formatSet = Boolean(format);
          format = format !== null && format !== void 0 ? format : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
          if (needsAlphaFormat) {
            if (format === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
          }
          if (format === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format === "name") {
            formattedString = this.toName();
          }
          if (format === "hsl") {
            formattedString = this.toHslString();
          }
          if (format === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h = hsv.h;
          var s = hsv.s;
          var v = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h, s, v }));
            v = (v + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          return new TinyColor2({
            r: bg.r + (fg.r - bg.r) * fg.a,
            g: bg.g + (fg.g - bg.g) * fg.a,
            b: bg.b + (fg.b - bg.b) * fg.a
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n) {
          var hsl = this.toHsl();
          var h = hsl.h;
          var result = [this];
          var increment = 360 / n;
          for (var i3 = 1; i3 < n; i3++) {
            result.push(new TinyColor2({ h: (h + i3 * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );

    // src/components/color-picker/color-picker.ts
    var hasEyeDropper = "EyeDropper" in window;
    var SlColorPicker = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.formControlController = new FormControlController(this);
        this.isSafeValue = false;
        this.localize = new LocalizeController2(this);
        this.isDraggingGridHandle = false;
        this.isEmpty = false;
        this.inputValue = "";
        this.hue = 0;
        this.saturation = 100;
        this.brightness = 100;
        this.alpha = 100;
        this.value = "";
        this.defaultValue = "";
        this.label = "";
        this.format = "hex";
        this.inline = false;
        this.size = "medium";
        this.noFormatToggle = false;
        this.name = "";
        this.disabled = false;
        this.hoist = false;
        this.opacity = false;
        this.uppercase = false;
        this.swatches = "";
        this.form = "";
      }
      handleCopy() {
        this.input.select();
        document.execCommand("copy");
        this.previewButton.focus();
        this.previewButton.classList.add("color-picker__preview-color--copied");
        this.previewButton.addEventListener("animationend", () => {
          this.previewButton.classList.remove("color-picker__preview-color--copied");
        });
      }
      handleFormatToggle() {
        const formats = ["hex", "rgb", "hsl", "hsv"];
        const nextIndex = (formats.indexOf(this.format) + 1) % formats.length;
        this.format = formats[nextIndex];
        this.setColor(this.value);
        this.emit("sl-change");
        this.emit("sl-input");
      }
      handleAlphaDrag(event) {
        const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha");
        const handle = container.querySelector(".color-picker__slider-handle");
        const { width } = container.getBoundingClientRect();
        let oldValue = this.value;
        handle.focus();
        event.preventDefault();
        drag(container, {
          onMove: (x) => {
            this.alpha = clamp(x / width * 100, 0, 100);
            this.syncValues();
            if (this.value !== oldValue) {
              oldValue = this.value;
              this.emit("sl-change");
              this.emit("sl-input");
            }
          },
          initialEvent: event
        });
      }
      handleHueDrag(event) {
        const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue");
        const handle = container.querySelector(".color-picker__slider-handle");
        const { width } = container.getBoundingClientRect();
        let oldValue = this.value;
        handle.focus();
        event.preventDefault();
        drag(container, {
          onMove: (x) => {
            this.hue = clamp(x / width * 360, 0, 360);
            this.syncValues();
            if (this.value !== oldValue) {
              oldValue = this.value;
              this.emit("sl-change");
              this.emit("sl-input");
            }
          },
          initialEvent: event
        });
      }
      handleGridDrag(event) {
        const grid = this.shadowRoot.querySelector(".color-picker__grid");
        const handle = grid.querySelector(".color-picker__grid-handle");
        const { width, height } = grid.getBoundingClientRect();
        let oldValue = this.value;
        handle.focus();
        event.preventDefault();
        this.isDraggingGridHandle = true;
        drag(grid, {
          onMove: (x, y2) => {
            this.saturation = clamp(x / width * 100, 0, 100);
            this.brightness = clamp(100 - y2 / height * 100, 0, 100);
            this.syncValues();
            if (this.value !== oldValue) {
              oldValue = this.value;
              this.emit("sl-change");
              this.emit("sl-input");
            }
          },
          onStop: () => this.isDraggingGridHandle = false,
          initialEvent: event
        });
      }
      handleAlphaKeyDown(event) {
        const increment = event.shiftKey ? 10 : 1;
        const oldValue = this.value;
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          this.alpha = clamp(this.alpha - increment, 0, 100);
          this.syncValues();
        }
        if (event.key === "ArrowRight") {
          event.preventDefault();
          this.alpha = clamp(this.alpha + increment, 0, 100);
          this.syncValues();
        }
        if (event.key === "Home") {
          event.preventDefault();
          this.alpha = 0;
          this.syncValues();
        }
        if (event.key === "End") {
          event.preventDefault();
          this.alpha = 100;
          this.syncValues();
        }
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }
      handleHueKeyDown(event) {
        const increment = event.shiftKey ? 10 : 1;
        const oldValue = this.value;
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          this.hue = clamp(this.hue - increment, 0, 360);
          this.syncValues();
        }
        if (event.key === "ArrowRight") {
          event.preventDefault();
          this.hue = clamp(this.hue + increment, 0, 360);
          this.syncValues();
        }
        if (event.key === "Home") {
          event.preventDefault();
          this.hue = 0;
          this.syncValues();
        }
        if (event.key === "End") {
          event.preventDefault();
          this.hue = 360;
          this.syncValues();
        }
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }
      handleGridKeyDown(event) {
        const increment = event.shiftKey ? 10 : 1;
        const oldValue = this.value;
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          this.saturation = clamp(this.saturation - increment, 0, 100);
          this.syncValues();
        }
        if (event.key === "ArrowRight") {
          event.preventDefault();
          this.saturation = clamp(this.saturation + increment, 0, 100);
          this.syncValues();
        }
        if (event.key === "ArrowUp") {
          event.preventDefault();
          this.brightness = clamp(this.brightness + increment, 0, 100);
          this.syncValues();
        }
        if (event.key === "ArrowDown") {
          event.preventDefault();
          this.brightness = clamp(this.brightness - increment, 0, 100);
          this.syncValues();
        }
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }
      handleInputChange(event) {
        const target = event.target;
        const oldValue = this.value;
        event.stopPropagation();
        if (this.input.value) {
          this.setColor(target.value);
          target.value = this.value;
        } else {
          this.value = "";
        }
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }
      handleInputInput(event) {
        event.stopPropagation();
      }
      handleInputKeyDown(event) {
        if (event.key === "Enter") {
          const oldValue = this.value;
          if (this.input.value) {
            this.setColor(this.input.value);
            this.input.value = this.value;
            if (this.value !== oldValue) {
              this.emit("sl-change");
              this.emit("sl-input");
            }
            setTimeout(() => this.input.select());
          } else {
            this.hue = 0;
          }
        }
      }
      handleTouchMove(event) {
        event.preventDefault();
      }
      parseColor(colorString) {
        const color = new TinyColor(colorString);
        if (!color.isValid) {
          return null;
        }
        const hslColor = color.toHsl();
        const hsl = {
          h: hslColor.h,
          s: hslColor.s * 100,
          l: hslColor.l * 100,
          a: hslColor.a
        };
        const rgb = color.toRgb();
        const hex = color.toHexString();
        const hexa = color.toHex8String();
        const hsvColor = color.toHsv();
        const hsv = {
          h: hsvColor.h,
          s: hsvColor.s * 100,
          v: hsvColor.v * 100,
          a: hsvColor.a
        };
        return {
          hsl: {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            string: this.setLetterCase(`hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`)
          },
          hsla: {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: hsl.a,
            string: this.setLetterCase(
              `hsla(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%, ${hsl.a.toFixed(2).toString()})`
            )
          },
          hsv: {
            h: hsv.h,
            s: hsv.s,
            v: hsv.v,
            string: this.setLetterCase(`hsv(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%)`)
          },
          hsva: {
            h: hsv.h,
            s: hsv.s,
            v: hsv.v,
            a: hsv.a,
            string: this.setLetterCase(
              `hsva(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%, ${hsv.a.toFixed(2).toString()})`
            )
          },
          rgb: {
            r: rgb.r,
            g: rgb.g,
            b: rgb.b,
            string: this.setLetterCase(`rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`)
          },
          rgba: {
            r: rgb.r,
            g: rgb.g,
            b: rgb.b,
            a: rgb.a,
            string: this.setLetterCase(
              `rgba(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)}, ${rgb.a.toFixed(2).toString()})`
            )
          },
          hex: this.setLetterCase(hex),
          hexa: this.setLetterCase(hexa)
        };
      }
      setColor(colorString) {
        const newColor = this.parseColor(colorString);
        if (newColor === null) {
          return false;
        }
        this.hue = newColor.hsva.h;
        this.saturation = newColor.hsva.s;
        this.brightness = newColor.hsva.v;
        this.alpha = this.opacity ? newColor.hsva.a * 100 : 100;
        this.syncValues();
        return true;
      }
      setLetterCase(string) {
        if (typeof string !== "string") {
          return "";
        }
        return this.uppercase ? string.toUpperCase() : string.toLowerCase();
      }
      async syncValues() {
        const currentColor = this.parseColor(
          `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
        );
        if (currentColor === null) {
          return;
        }
        if (this.format === "hsl") {
          this.inputValue = this.opacity ? currentColor.hsla.string : currentColor.hsl.string;
        } else if (this.format === "rgb") {
          this.inputValue = this.opacity ? currentColor.rgba.string : currentColor.rgb.string;
        } else if (this.format === "hsv") {
          this.inputValue = this.opacity ? currentColor.hsva.string : currentColor.hsv.string;
        } else {
          this.inputValue = this.opacity ? currentColor.hexa : currentColor.hex;
        }
        this.isSafeValue = true;
        this.value = this.inputValue;
        await this.updateComplete;
        this.isSafeValue = false;
      }
      handleAfterHide() {
        this.previewButton.classList.remove("color-picker__preview-color--copied");
      }
      handleEyeDropper() {
        if (!hasEyeDropper) {
          return;
        }
        const eyeDropper = new EyeDropper();
        eyeDropper.open().then((colorSelectionResult) => this.setColor(colorSelectionResult.sRGBHex)).catch(() => {
        });
      }
      selectSwatch(color) {
        const oldValue = this.value;
        if (!this.disabled) {
          this.setColor(color);
          if (this.value !== oldValue) {
            this.emit("sl-change");
            this.emit("sl-input");
          }
        }
      }
      /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
      getHexString(hue, saturation, brightness, alpha = 100) {
        const color = new TinyColor(`hsva(${hue}, ${saturation}, ${brightness}, ${alpha / 100})`);
        if (!color.isValid) {
          return "";
        }
        return color.toHex8String();
      }
      handleFormatChange() {
        this.syncValues();
      }
      handleOpacityChange() {
        this.alpha = 100;
      }
      handleValueChange(oldValue, newValue) {
        this.isEmpty = !newValue;
        if (!newValue) {
          this.hue = 0;
          this.saturation = 0;
          this.brightness = 100;
          this.alpha = 100;
        }
        if (!this.isSafeValue) {
          const newColor = this.parseColor(newValue);
          if (newColor !== null) {
            this.inputValue = this.value;
            this.hue = newColor.hsva.h;
            this.saturation = newColor.hsva.s;
            this.brightness = newColor.hsva.v;
            this.alpha = newColor.hsva.a * 100;
            this.syncValues();
          } else {
            this.inputValue = oldValue != null ? oldValue : "";
          }
        }
      }
      /** Returns the current value as a string in the specified format. */
      getFormattedValue(format = "hex") {
        const currentColor = this.parseColor(
          `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
        );
        if (currentColor === null) {
          return "";
        }
        switch (format) {
          case "hex":
            return currentColor.hex;
          case "hexa":
            return currentColor.hexa;
          case "rgb":
            return currentColor.rgb.string;
          case "rgba":
            return currentColor.rgba.string;
          case "hsl":
            return currentColor.hsl.string;
          case "hsla":
            return currentColor.hsla.string;
          case "hsv":
            return currentColor.hsv.string;
          case "hsva":
            return currentColor.hsva.string;
          default:
            return "";
        }
      }
      /** Checks for validity but does not show the browser's validation message. */
      checkValidity() {
        return this.input.checkValidity();
      }
      /** Checks for validity and shows the browser's validation message if the control is invalid. */
      reportValidity() {
        if (!this.inline && !this.checkValidity()) {
          this.dropdown.show();
          this.addEventListener("sl-after-show", () => this.input.reportValidity(), { once: true });
          return this.checkValidity();
        }
        return this.input.reportValidity();
      }
      /** Sets a custom validation message. Pass an empty string to restore validity. */
      setCustomValidity(message) {
        this.input.setCustomValidity(message);
        this.formControlController.updateValidity();
      }
      render() {
        const gridHandleX = this.saturation;
        const gridHandleY = 100 - this.brightness;
        const swatches = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter((color) => color.trim() !== "");
        const colorPicker = y`
      <div
        part="base"
        class=${o$1({
      "color-picker": true,
      "color-picker--inline": this.inline,
      "color-picker--disabled": this.disabled
    })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? y`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${i2$1({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${o$1({
      "color-picker__grid-handle": true,
      "color-picker__grid-handle--dragging": this.isDraggingGridHandle
    })}
            style=${i2$1({
      top: `${gridHandleY}%`,
      left: `${gridHandleX}%`,
      backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            role="application"
            aria-label="HSV"
            tabindex=${l$1(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${i2$1({
      left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
    })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${l$1(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? y`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${i2$1({
      backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
    })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${i2$1({
      left: `${this.alpha}%`
    })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${l$1(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${i2$1({
      "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
          ></sl-input>

          <sl-button-group>
            ${!this.noFormatToggle ? y`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                ` : ""}
            ${hasEyeDropper ? y`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${swatches.length > 0 ? y`
              <div part="swatches" class="color-picker__swatches">
                ${swatches.map((swatch) => {
      const parsedColor = this.parseColor(swatch);
      if (!parsedColor) {
        console.error(`Unable to parse swatch color: "${swatch}"`, this);
        return "";
      }
      return y`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${l$1(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${swatch}
                      @click=${() => this.selectSwatch(swatch)}
                      @keydown=${(event) => !this.disabled && event.key === "Enter" && this.setColor(parsedColor.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${i2$1({ backgroundColor: parsedColor.hexa })}
                      ></div>
                    </div>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
        if (this.inline) {
          return colorPicker;
        }
        return y`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containing-element=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${o$1({
      "color-dropdown__trigger": true,
      "color-dropdown__trigger--disabled": this.disabled,
      "color-dropdown__trigger--small": this.size === "small",
      "color-dropdown__trigger--medium": this.size === "medium",
      "color-dropdown__trigger--large": this.size === "large",
      "color-dropdown__trigger--empty": this.isEmpty,
      "color-picker__transparent-bg": true
    })}
          style=${i2$1({
      color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${colorPicker}
      </sl-dropdown>
    `;
      }
    };
    SlColorPicker.styles = color_picker_styles_default;
    __decorateClass([
      i2$2('[part~="input"]')
    ], SlColorPicker.prototype, "input", 2);
    __decorateClass([
      i2$2('[part~="preview"]')
    ], SlColorPicker.prototype, "previewButton", 2);
    __decorateClass([
      i2$2(".color-dropdown")
    ], SlColorPicker.prototype, "dropdown", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "isDraggingGridHandle", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "isEmpty", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "inputValue", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "hue", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "saturation", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "brightness", 2);
    __decorateClass([
      t$1()
    ], SlColorPicker.prototype, "alpha", 2);
    __decorateClass([
      e2$1()
    ], SlColorPicker.prototype, "value", 2);
    __decorateClass([
      defaultValue()
    ], SlColorPicker.prototype, "defaultValue", 2);
    __decorateClass([
      e2$1()
    ], SlColorPicker.prototype, "label", 2);
    __decorateClass([
      e2$1()
    ], SlColorPicker.prototype, "format", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlColorPicker.prototype, "inline", 2);
    __decorateClass([
      e2$1()
    ], SlColorPicker.prototype, "size", 2);
    __decorateClass([
      e2$1({ attribute: "no-format-toggle", type: Boolean })
    ], SlColorPicker.prototype, "noFormatToggle", 2);
    __decorateClass([
      e2$1()
    ], SlColorPicker.prototype, "name", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlColorPicker.prototype, "disabled", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlColorPicker.prototype, "hoist", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlColorPicker.prototype, "opacity", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlColorPicker.prototype, "uppercase", 2);
    __decorateClass([
      e2$1()
    ], SlColorPicker.prototype, "swatches", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlColorPicker.prototype, "form", 2);
    __decorateClass([
      watch("format", { waitUntilFirstUpdate: true })
    ], SlColorPicker.prototype, "handleFormatChange", 1);
    __decorateClass([
      watch("opacity", { waitUntilFirstUpdate: true })
    ], SlColorPicker.prototype, "handleOpacityChange", 1);
    __decorateClass([
      watch("value")
    ], SlColorPicker.prototype, "handleValueChange", 1);
    SlColorPicker = __decorateClass([
      e$1("sl-color-picker")
    ], SlColorPicker);

    // src/components/visually-hidden/visually-hidden.styles.ts
    var visually_hidden_styles_default = i$3`
  ${component_styles_default}

  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`;

    // src/components/visually-hidden/visually-hidden.ts
    var SlVisuallyHidden = class extends ShoelaceElement {
      render() {
        return y` <slot></slot> `;
      }
    };
    SlVisuallyHidden.styles = visually_hidden_styles_default;
    SlVisuallyHidden = __decorateClass([
      e$1("sl-visually-hidden")
    ], SlVisuallyHidden);

    // src/styles/form-control.styles.ts
    var form_control_styles_default = i$3`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control_label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

    // src/components/input/input.styles.ts
    var input_styles_default = i$3`
  ${component_styles_default}
  ${form_control_styles_default}

  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix::slotted(sl-icon),
  .input__suffix::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide Firefox's clear button on date and time inputs */
  .input--is-firefox input[type='date'],
  .input--is-firefox input[type='time'] {
    clip-path: inset(0 2em 0 0);
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

    var e2 = (o) => void 0 === o.strings;
    var f$1 = {};
    var s$1 = (o, l3 = f$1) => o._$AH = l3;

    // node_modules/lit-html/directives/live.js
    var l2$1 = e$2(class extends i$2 {
      constructor(r) {
        if (super(r), r.type !== t$2.PROPERTY && r.type !== t$2.ATTRIBUTE && r.type !== t$2.BOOLEAN_ATTRIBUTE)
          throw Error("The `live` directive is not allowed on child or event bindings");
        if (!e2(r))
          throw Error("`live` bindings can only contain a single expression");
      }
      render(r) {
        return r;
      }
      update(i2, [t2]) {
        if (t2 === x$1 || t2 === b$1)
          return t2;
        const o = i2.element, l3 = i2.name;
        if (i2.type === t$2.PROPERTY) {
          if (t2 === o[l3])
            return x$1;
        } else if (i2.type === t$2.BOOLEAN_ATTRIBUTE) {
          if (!!t2 === o.hasAttribute(l3))
            return x$1;
        } else if (i2.type === t$2.ATTRIBUTE && o.getAttribute(l3) === t2 + "")
          return x$1;
        return s$1(i2), t2;
      }
    });
    /*! Bundled license information:

    lit-html/directive-helpers.js:
      (**
       * @license
       * Copyright 2020 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)

    lit-html/directives/live.js:
      (**
       * @license
       * Copyright 2020 Google LLC
       * SPDX-License-Identifier: BSD-3-Clause
       *)
    */

    // src/components/input/input.ts
    var _a;
    var isChromium = (_a = navigator.userAgentData) == null ? void 0 : _a.brands.some((b) => b.brand.includes("Chromium"));
    var isFirefox = isChromium ? false : navigator.userAgent.includes("Firefox");
    var SlInput = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.formControlController = new FormControlController(this);
        this.hasSlotController = new HasSlotController(this, "help-text", "label");
        this.localize = new LocalizeController2(this);
        this.hasFocus = false;
        this.title = "";
        this.type = "text";
        this.name = "";
        this.value = "";
        this.defaultValue = "";
        this.size = "medium";
        this.filled = false;
        this.pill = false;
        this.label = "";
        this.helpText = "";
        this.clearable = false;
        this.disabled = false;
        this.placeholder = "";
        this.readonly = false;
        this.passwordToggle = false;
        this.passwordVisible = false;
        this.noSpinButtons = false;
        this.form = "";
        this.required = false;
        this.spellcheck = true;
      }
      /** Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. */
      get valueAsDate() {
        var _a2, _b;
        return (_b = (_a2 = this.input) == null ? void 0 : _a2.valueAsDate) != null ? _b : null;
      }
      set valueAsDate(newValue) {
        const input = document.createElement("input");
        input.type = "date";
        input.valueAsDate = newValue;
        this.value = input.value;
      }
      /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
      get valueAsNumber() {
        var _a2, _b;
        return (_b = (_a2 = this.input) == null ? void 0 : _a2.valueAsNumber) != null ? _b : parseFloat(this.value);
      }
      set valueAsNumber(newValue) {
        const input = document.createElement("input");
        input.type = "number";
        input.valueAsNumber = newValue;
        this.value = input.value;
      }
      firstUpdated() {
        this.formControlController.updateValidity();
      }
      handleBlur() {
        this.hasFocus = false;
        this.emit("sl-blur");
      }
      handleChange() {
        this.value = this.input.value;
        this.emit("sl-change");
      }
      handleClearClick(event) {
        this.value = "";
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
        this.input.focus();
        event.stopPropagation();
      }
      handleFocus() {
        this.hasFocus = true;
        this.emit("sl-focus");
      }
      handleInput() {
        this.value = this.input.value;
        this.formControlController.updateValidity();
        this.emit("sl-input");
      }
      handleInvalid() {
        this.formControlController.setValidity(false);
      }
      handleKeyDown(event) {
        const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
        if (event.key === "Enter" && !hasModifier) {
          setTimeout(() => {
            if (!event.defaultPrevented && !event.isComposing) {
              this.formControlController.submit();
            }
          });
        }
      }
      handlePasswordToggle() {
        this.passwordVisible = !this.passwordVisible;
      }
      handleDisabledChange() {
        this.formControlController.setValidity(this.disabled);
      }
      handleStepChange() {
        this.input.step = String(this.step);
        this.formControlController.updateValidity();
      }
      async handleValueChange() {
        await this.updateComplete;
        this.formControlController.updateValidity();
      }
      /** Sets focus on the input. */
      focus(options) {
        this.input.focus(options);
      }
      /** Removes focus from the input. */
      blur() {
        this.input.blur();
      }
      /** Selects all the text in the input. */
      select() {
        this.input.select();
      }
      /** Sets the start and end positions of the text selection (0-based). */
      setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
        this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
      }
      /** Replaces a range of text with a new string. */
      setRangeText(replacement, start, end, selectMode) {
        this.input.setRangeText(replacement, start, end, selectMode);
        if (this.value !== this.input.value) {
          this.value = this.input.value;
        }
      }
      /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
      showPicker() {
        if ("showPicker" in HTMLInputElement.prototype) {
          this.input.showPicker();
        }
      }
      /** Increments the value of a numeric input type by the value of the step attribute. */
      stepUp() {
        this.input.stepUp();
        if (this.value !== this.input.value) {
          this.value = this.input.value;
        }
      }
      /** Decrements the value of a numeric input type by the value of the step attribute. */
      stepDown() {
        this.input.stepDown();
        if (this.value !== this.input.value) {
          this.value = this.input.value;
        }
      }
      /** Checks for validity but does not show the browser's validation message. */
      checkValidity() {
        return this.input.checkValidity();
      }
      /** Checks for validity and shows the browser's validation message if the control is invalid. */
      reportValidity() {
        return this.input.reportValidity();
      }
      /** Sets a custom validation message. Pass an empty string to restore validity. */
      setCustomValidity(message) {
        this.input.setCustomValidity(message);
        this.formControlController.updateValidity();
      }
      render() {
        const hasLabelSlot = this.hasSlotController.test("label");
        const hasHelpTextSlot = this.hasSlotController.test("help-text");
        const hasLabel = this.label ? true : !!hasLabelSlot;
        const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
        const hasClearIcon = this.clearable && !this.disabled && !this.readonly && (typeof this.value === "number" || this.value.length > 0);
        return y`
      <div
        part="form-control"
        class=${o$1({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${o$1({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons,
      "input--is-firefox": isFirefox
    })}
          >
            <slot name="prefix" part="prefix" class="input__prefix"></slot>
            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${l$1(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${l$1(this.placeholder)}
              minlength=${l$1(this.minlength)}
              maxlength=${l$1(this.maxlength)}
              min=${l$1(this.min)}
              max=${l$1(this.max)}
              step=${l$1(this.step)}
              .value=${l2$1(this.value)}
              autocapitalize=${l$1(this.type === "password" ? "off" : this.autocapitalize)}
              autocomplete=${l$1(this.type === "password" ? "off" : this.autocomplete)}
              autocorrect=${l$1(this.type === "password" ? "off" : this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${l$1(this.pattern)}
              enterkeyhint=${l$1(this.enterkeyhint)}
              inputmode=${l$1(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${hasClearIcon ? y`
                    <button
                      part="clear-button"
                      class="input__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}
            ${this.passwordToggle && !this.disabled ? y`
                    <button
                      part="password-toggle-button"
                      class="input__password-toggle"
                      type="button"
                      aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                      @click=${this.handlePasswordToggle}
                      tabindex="-1"
                    >
                      ${this.passwordVisible ? y`
                            <slot name="show-password-icon">
                              <sl-icon name="eye-slash" library="system"></sl-icon>
                            </slot>
                          ` : y`
                            <slot name="hide-password-icon">
                              <sl-icon name="eye" library="system"></sl-icon>
                            </slot>
                          `}
                    </button>
                  ` : ""}

            <slot name="suffix" part="suffix" class="input__suffix"></slot>
          </div>
        </div>

        <slot
          name="help-text"
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          ${this.helpText}
        </slot>
        </div>
      </div>
    `;
      }
    };
    SlInput.styles = input_styles_default;
    __decorateClass([
      i2$2(".input__control")
    ], SlInput.prototype, "input", 2);
    __decorateClass([
      t$1()
    ], SlInput.prototype, "hasFocus", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "title", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlInput.prototype, "type", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "name", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "value", 2);
    __decorateClass([
      defaultValue()
    ], SlInput.prototype, "defaultValue", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlInput.prototype, "size", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlInput.prototype, "filled", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlInput.prototype, "pill", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "label", 2);
    __decorateClass([
      e2$1({ attribute: "help-text" })
    ], SlInput.prototype, "helpText", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlInput.prototype, "clearable", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlInput.prototype, "disabled", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "placeholder", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlInput.prototype, "readonly", 2);
    __decorateClass([
      e2$1({ attribute: "password-toggle", type: Boolean })
    ], SlInput.prototype, "passwordToggle", 2);
    __decorateClass([
      e2$1({ attribute: "password-visible", type: Boolean })
    ], SlInput.prototype, "passwordVisible", 2);
    __decorateClass([
      e2$1({ attribute: "no-spin-buttons", type: Boolean })
    ], SlInput.prototype, "noSpinButtons", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlInput.prototype, "form", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlInput.prototype, "required", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "pattern", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlInput.prototype, "minlength", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlInput.prototype, "maxlength", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlInput.prototype, "min", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlInput.prototype, "max", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "step", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "autocapitalize", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "autocorrect", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "autocomplete", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlInput.prototype, "autofocus", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "enterkeyhint", 2);
    __decorateClass([
      e2$1({
        type: Boolean,
        converter: {
          // Allow "true|false" attribute values but keep the property boolean
          fromAttribute: (value) => !value || value === "false" ? false : true,
          toAttribute: (value) => value ? "true" : "false"
        }
      })
    ], SlInput.prototype, "spellcheck", 2);
    __decorateClass([
      e2$1()
    ], SlInput.prototype, "inputmode", 2);
    __decorateClass([
      watch("disabled", { waitUntilFirstUpdate: true })
    ], SlInput.prototype, "handleDisabledChange", 1);
    __decorateClass([
      watch("step", { waitUntilFirstUpdate: true })
    ], SlInput.prototype, "handleStepChange", 1);
    __decorateClass([
      watch("value", { waitUntilFirstUpdate: true })
    ], SlInput.prototype, "handleValueChange", 1);
    SlInput = __decorateClass([
      e$1("sl-input")
    ], SlInput);

    // src/components/dropdown/dropdown.styles.ts
    var dropdown_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

    // src/components/dropdown/dropdown.ts
    var SlDropdown = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.localize = new LocalizeController2(this);
        this.open = false;
        this.placement = "bottom-start";
        this.disabled = false;
        this.stayOpenOnSelect = false;
        this.distance = 0;
        this.skidding = 0;
        this.hoist = false;
      }
      connectedCallback() {
        super.connectedCallback();
        this.handleMenuItemActivate = this.handleMenuItemActivate.bind(this);
        this.handlePanelSelect = this.handlePanelSelect.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleDocumentKeyDown = this.handleDocumentKeyDown.bind(this);
        this.handleDocumentMouseDown = this.handleDocumentMouseDown.bind(this);
        if (!this.containingElement) {
          this.containingElement = this;
        }
      }
      firstUpdated() {
        this.panel.hidden = !this.open;
        if (this.open) {
          this.addOpenListeners();
          this.popup.active = true;
        }
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeOpenListeners();
        this.hide();
      }
      focusOnTrigger() {
        const trigger = this.trigger.assignedElements({ flatten: true })[0];
        if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
          trigger.focus();
        }
      }
      getMenu() {
        return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
      }
      handleKeyDown(event) {
        if (this.open && event.key === "Escape") {
          event.stopPropagation();
          this.hide();
          this.focusOnTrigger();
        }
      }
      handleDocumentKeyDown(event) {
        var _a;
        if (event.key === "Tab") {
          if (this.open && ((_a = document.activeElement) == null ? void 0 : _a.tagName.toLowerCase()) === "sl-menu-item") {
            event.preventDefault();
            this.hide();
            this.focusOnTrigger();
            return;
          }
          setTimeout(() => {
            var _a2, _b, _c;
            const activeElement = ((_a2 = this.containingElement) == null ? void 0 : _a2.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
            if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
              this.hide();
            }
          });
        }
      }
      handleDocumentMouseDown(event) {
        const path = event.composedPath();
        if (this.containingElement && !path.includes(this.containingElement)) {
          this.hide();
        }
      }
      handleMenuItemActivate(event) {
        const item = event.target;
        scrollIntoView(item, this.panel);
      }
      handlePanelSelect(event) {
        const target = event.target;
        if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
          this.hide();
          this.focusOnTrigger();
        }
      }
      handleTriggerClick() {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
      handleTriggerKeyDown(event) {
        if (event.key === "Escape" && this.open) {
          event.stopPropagation();
          this.focusOnTrigger();
          this.hide();
          return;
        }
        if ([" ", "Enter"].includes(event.key)) {
          event.preventDefault();
          this.handleTriggerClick();
          return;
        }
        const menu = this.getMenu();
        if (menu) {
          const menuItems = menu.defaultSlot.assignedElements({ flatten: true });
          const firstMenuItem = menuItems[0];
          const lastMenuItem = menuItems[menuItems.length - 1];
          if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
            event.preventDefault();
            if (!this.open) {
              this.show();
            }
            if (menuItems.length > 0) {
              requestAnimationFrame(() => {
                if (event.key === "ArrowDown" || event.key === "Home") {
                  menu.setCurrentItem(firstMenuItem);
                  firstMenuItem.focus();
                }
                if (event.key === "ArrowUp" || event.key === "End") {
                  menu.setCurrentItem(lastMenuItem);
                  lastMenuItem.focus();
                }
              });
            }
          }
        }
      }
      handleTriggerKeyUp(event) {
        if (event.key === " ") {
          event.preventDefault();
        }
      }
      handleTriggerSlotChange() {
        this.updateAccessibleTrigger();
      }
      //
      // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
      // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
      // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
      // a child of the slotted element, or an element in the slotted element's shadow root.
      //
      // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
      //
      // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
      //
      updateAccessibleTrigger() {
        const assignedElements = this.trigger.assignedElements({ flatten: true });
        const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
        let target;
        if (accessibleTrigger) {
          switch (accessibleTrigger.tagName.toLowerCase()) {
            case "sl-button":
            case "sl-icon-button":
              target = accessibleTrigger.button;
              break;
            default:
              target = accessibleTrigger;
          }
          target.setAttribute("aria-haspopup", "true");
          target.setAttribute("aria-expanded", this.open ? "true" : "false");
        }
      }
      /** Shows the dropdown panel. */
      async show() {
        if (this.open) {
          return void 0;
        }
        this.open = true;
        return waitForEvent(this, "sl-after-show");
      }
      /** Hides the dropdown panel */
      async hide() {
        if (!this.open) {
          return void 0;
        }
        this.open = false;
        return waitForEvent(this, "sl-after-hide");
      }
      /**
       * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
       * is activated.
       */
      reposition() {
        this.popup.reposition();
      }
      addOpenListeners() {
        this.panel.addEventListener("sl-activate", this.handleMenuItemActivate);
        this.panel.addEventListener("sl-select", this.handlePanelSelect);
        this.panel.addEventListener("keydown", this.handleKeyDown);
        document.addEventListener("keydown", this.handleDocumentKeyDown);
        document.addEventListener("mousedown", this.handleDocumentMouseDown);
      }
      removeOpenListeners() {
        if (this.panel) {
          this.panel.removeEventListener("sl-activate", this.handleMenuItemActivate);
          this.panel.removeEventListener("sl-select", this.handlePanelSelect);
          this.panel.removeEventListener("keydown", this.handleKeyDown);
        }
        document.removeEventListener("keydown", this.handleDocumentKeyDown);
        document.removeEventListener("mousedown", this.handleDocumentMouseDown);
      }
      async handleOpenChange() {
        if (this.disabled) {
          this.open = false;
          return;
        }
        this.updateAccessibleTrigger();
        if (this.open) {
          this.emit("sl-show");
          this.addOpenListeners();
          await stopAnimations(this);
          this.panel.hidden = false;
          this.popup.active = true;
          const { keyframes, options } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
          await animateTo(this.popup.popup, keyframes, options);
          this.emit("sl-after-show");
        } else {
          this.emit("sl-hide");
          this.removeOpenListeners();
          await stopAnimations(this);
          const { keyframes, options } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
          await animateTo(this.popup.popup, keyframes, options);
          this.panel.hidden = true;
          this.popup.active = false;
          this.emit("sl-after-hide");
        }
      }
      render() {
        return y`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        class=${o$1({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <slot
          part="panel"
          class="dropdown__panel"
          aria-hidden=${this.open ? "false" : "true"}
          aria-labelledby="dropdown"
        ></slot>
      </sl-popup>
    `;
      }
    };
    SlDropdown.styles = dropdown_styles_default;
    __decorateClass([
      i2$2(".dropdown")
    ], SlDropdown.prototype, "popup", 2);
    __decorateClass([
      i2$2(".dropdown__trigger")
    ], SlDropdown.prototype, "trigger", 2);
    __decorateClass([
      i2$2(".dropdown__panel")
    ], SlDropdown.prototype, "panel", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlDropdown.prototype, "open", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlDropdown.prototype, "placement", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlDropdown.prototype, "disabled", 2);
    __decorateClass([
      e2$1({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
    ], SlDropdown.prototype, "stayOpenOnSelect", 2);
    __decorateClass([
      e2$1({ attribute: false })
    ], SlDropdown.prototype, "containingElement", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlDropdown.prototype, "distance", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlDropdown.prototype, "skidding", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlDropdown.prototype, "hoist", 2);
    __decorateClass([
      watch("open", { waitUntilFirstUpdate: true })
    ], SlDropdown.prototype, "handleOpenChange", 1);
    SlDropdown = __decorateClass([
      e$1("sl-dropdown")
    ], SlDropdown);
    setDefaultAnimation("dropdown.show", {
      keyframes: [
        { opacity: 0, scale: 0.9 },
        { opacity: 1, scale: 1 }
      ],
      options: { duration: 100, easing: "ease" }
    });
    setDefaultAnimation("dropdown.hide", {
      keyframes: [
        { opacity: 1, scale: 1 },
        { opacity: 0, scale: 0.9 }
      ],
      options: { duration: 100, easing: "ease" }
    });

    // src/components/popup/popup.styles.ts
    var popup_styles_default = i$3`
  ${component_styles_default}

  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }
`;

    // node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
    function t(t2) {
      return t2.split("-")[1];
    }
    function e3(t2) {
      return "y" === t2 ? "height" : "width";
    }
    function n(t2) {
      return t2.split("-")[0];
    }
    function o2(t2) {
      return ["top", "bottom"].includes(n(t2)) ? "x" : "y";
    }
    function i2(i4, r3, a3) {
      let { reference: l3, floating: s3 } = i4;
      const c3 = l3.x + l3.width / 2 - s3.width / 2, f3 = l3.y + l3.height / 2 - s3.height / 2, u3 = o2(r3), m3 = e3(u3), g3 = l3[m3] / 2 - s3[m3] / 2, d3 = "x" === u3;
      let p3;
      switch (n(r3)) {
        case "top":
          p3 = { x: c3, y: l3.y - s3.height };
          break;
        case "bottom":
          p3 = { x: c3, y: l3.y + l3.height };
          break;
        case "right":
          p3 = { x: l3.x + l3.width, y: f3 };
          break;
        case "left":
          p3 = { x: l3.x - s3.width, y: f3 };
          break;
        default:
          p3 = { x: l3.x, y: l3.y };
      }
      switch (t(r3)) {
        case "start":
          p3[u3] -= g3 * (a3 && d3 ? -1 : 1);
          break;
        case "end":
          p3[u3] += g3 * (a3 && d3 ? -1 : 1);
      }
      return p3;
    }
    var r = async (t2, e4, n3) => {
      const { placement: o4 = "bottom", strategy: r3 = "absolute", middleware: a3 = [], platform: l3 } = n3, s3 = a3.filter(Boolean), c3 = await (null == l3.isRTL ? void 0 : l3.isRTL(e4));
      let f3 = await l3.getElementRects({ reference: t2, floating: e4, strategy: r3 }), { x: u3, y: m3 } = i2(f3, o4, c3), g3 = o4, d3 = {}, p3 = 0;
      for (let n4 = 0; n4 < s3.length; n4++) {
        const { name: a4, fn: h3 } = s3[n4], { x: y4, y: x3, data: w3, reset: v3 } = await h3({ x: u3, y: m3, initialPlacement: o4, placement: g3, strategy: r3, middlewareData: d3, rects: f3, platform: l3, elements: { reference: t2, floating: e4 } });
        u3 = null != y4 ? y4 : u3, m3 = null != x3 ? x3 : m3, d3 = __spreadProps(__spreadValues({}, d3), { [a4]: __spreadValues(__spreadValues({}, d3[a4]), w3) }), v3 && p3 <= 50 && (p3++, "object" == typeof v3 && (v3.placement && (g3 = v3.placement), v3.rects && (f3 = true === v3.rects ? await l3.getElementRects({ reference: t2, floating: e4, strategy: r3 }) : v3.rects), { x: u3, y: m3 } = i2(f3, g3, c3)), n4 = -1);
      }
      return { x: u3, y: m3, placement: g3, strategy: r3, middlewareData: d3 };
    };
    function a(t2) {
      return "number" != typeof t2 ? function(t3) {
        return __spreadValues({ top: 0, right: 0, bottom: 0, left: 0 }, t3);
      }(t2) : { top: t2, right: t2, bottom: t2, left: t2 };
    }
    function l(t2) {
      return __spreadProps(__spreadValues({}, t2), { top: t2.y, left: t2.x, right: t2.x + t2.width, bottom: t2.y + t2.height });
    }
    async function s(t2, e4) {
      var n3;
      void 0 === e4 && (e4 = {});
      const { x: o4, y: i4, platform: r3, rects: s3, elements: c3, strategy: f3 } = t2, { boundary: u3 = "clippingAncestors", rootBoundary: m3 = "viewport", elementContext: g3 = "floating", altBoundary: d3 = false, padding: p3 = 0 } = e4, h3 = a(p3), y4 = c3[d3 ? "floating" === g3 ? "reference" : "floating" : g3], x3 = l(await r3.getClippingRect({ element: null == (n3 = await (null == r3.isElement ? void 0 : r3.isElement(y4))) || n3 ? y4 : y4.contextElement || await (null == r3.getDocumentElement ? void 0 : r3.getDocumentElement(c3.floating)), boundary: u3, rootBoundary: m3, strategy: f3 })), w3 = "floating" === g3 ? __spreadProps(__spreadValues({}, s3.floating), { x: o4, y: i4 }) : s3.reference, v3 = await (null == r3.getOffsetParent ? void 0 : r3.getOffsetParent(c3.floating)), b3 = await (null == r3.isElement ? void 0 : r3.isElement(v3)) && await (null == r3.getScale ? void 0 : r3.getScale(v3)) || { x: 1, y: 1 }, R2 = l(r3.convertOffsetParentRelativeRectToViewportRelativeRect ? await r3.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: w3, offsetParent: v3, strategy: f3 }) : w3);
      return { top: (x3.top - R2.top + h3.top) / b3.y, bottom: (R2.bottom - x3.bottom + h3.bottom) / b3.y, left: (x3.left - R2.left + h3.left) / b3.x, right: (R2.right - x3.right + h3.right) / b3.x };
    }
    var c = Math.min;
    var f = Math.max;
    function u(t2, e4, n3) {
      return f(t2, c(e4, n3));
    }
    var m = (n3) => ({ name: "arrow", options: n3, async fn(i4) {
      const { element: r3, padding: l3 = 0 } = n3 || {}, { x: s3, y: c3, placement: f3, rects: m3, platform: g3 } = i4;
      if (null == r3)
        return {};
      const d3 = a(l3), p3 = { x: s3, y: c3 }, h3 = o2(f3), y4 = e3(h3), x3 = await g3.getDimensions(r3), w3 = "y" === h3 ? "top" : "left", v3 = "y" === h3 ? "bottom" : "right", b3 = m3.reference[y4] + m3.reference[h3] - p3[h3] - m3.floating[y4], R2 = p3[h3] - m3.reference[h3], A2 = await (null == g3.getOffsetParent ? void 0 : g3.getOffsetParent(r3));
      let P3 = A2 ? "y" === h3 ? A2.clientHeight || 0 : A2.clientWidth || 0 : 0;
      0 === P3 && (P3 = m3.floating[y4]);
      const T3 = b3 / 2 - R2 / 2, O3 = d3[w3], D3 = P3 - x3[y4] - d3[v3], E3 = P3 / 2 - x3[y4] / 2 + T3, L3 = u(O3, E3, D3), k2 = null != t(f3) && E3 != L3 && m3.reference[y4] / 2 - (E3 < O3 ? d3[w3] : d3[v3]) - x3[y4] / 2 < 0;
      return { [h3]: p3[h3] - (k2 ? E3 < O3 ? O3 - E3 : D3 - E3 : 0), data: { [h3]: L3, centerOffset: E3 - L3 } };
    } });
    var g = ["top", "right", "bottom", "left"];
    g.reduce((t2, e4) => t2.concat(e4, e4 + "-start", e4 + "-end"), []);
    var p = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function h(t2) {
      return t2.replace(/left|right|bottom|top/g, (t3) => p[t3]);
    }
    function y2(n3, i4, r3) {
      void 0 === r3 && (r3 = false);
      const a3 = t(n3), l3 = o2(n3), s3 = e3(l3);
      let c3 = "x" === l3 ? a3 === (r3 ? "end" : "start") ? "right" : "left" : "start" === a3 ? "bottom" : "top";
      return i4.reference[s3] > i4.floating[s3] && (c3 = h(c3)), { main: c3, cross: h(c3) };
    }
    var x = { start: "end", end: "start" };
    function w(t2) {
      return t2.replace(/start|end/g, (t3) => x[t3]);
    }
    var b = function(e4) {
      return void 0 === e4 && (e4 = {}), { name: "flip", options: e4, async fn(o4) {
        var i4;
        const { placement: r3, middlewareData: a3, rects: l3, initialPlacement: c3, platform: f3, elements: u3 } = o4, _a = e4, { mainAxis: m3 = true, crossAxis: g3 = true, fallbackPlacements: d3, fallbackStrategy: p3 = "bestFit", fallbackAxisSideDirection: x3 = "none", flipAlignment: v3 = true } = _a, b3 = __objRest(_a, ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"]), R2 = n(r3), A2 = n(c3) === c3, P3 = await (null == f3.isRTL ? void 0 : f3.isRTL(u3.floating)), T3 = d3 || (A2 || !v3 ? [h(c3)] : function(t2) {
          const e5 = h(t2);
          return [w(t2), e5, w(e5)];
        }(c3));
        d3 || "none" === x3 || T3.push(...function(e5, o5, i5, r4) {
          const a4 = t(e5);
          let l4 = function(t2, e6, n3) {
            const o6 = ["left", "right"], i6 = ["right", "left"], r5 = ["top", "bottom"], a5 = ["bottom", "top"];
            switch (t2) {
              case "top":
              case "bottom":
                return n3 ? e6 ? i6 : o6 : e6 ? o6 : i6;
              case "left":
              case "right":
                return e6 ? r5 : a5;
              default:
                return [];
            }
          }(n(e5), "start" === i5, r4);
          return a4 && (l4 = l4.map((t2) => t2 + "-" + a4), o5 && (l4 = l4.concat(l4.map(w)))), l4;
        }(c3, v3, x3, P3));
        const O3 = [c3, ...T3], D3 = await s(o4, b3), E3 = [];
        let L3 = (null == (i4 = a3.flip) ? void 0 : i4.overflows) || [];
        if (m3 && E3.push(D3[R2]), g3) {
          const { main: t2, cross: e5 } = y2(r3, l3, P3);
          E3.push(D3[t2], D3[e5]);
        }
        if (L3 = [...L3, { placement: r3, overflows: E3 }], !E3.every((t2) => t2 <= 0)) {
          var k2;
          const t2 = ((null == (k2 = a3.flip) ? void 0 : k2.index) || 0) + 1, e5 = O3[t2];
          if (e5)
            return { data: { index: t2, overflows: L3 }, reset: { placement: e5 } };
          let n3 = "bottom";
          switch (p3) {
            case "bestFit": {
              var B;
              const t3 = null == (B = L3.map((t4) => [t4, t4.overflows.filter((t5) => t5 > 0).reduce((t5, e6) => t5 + e6, 0)]).sort((t4, e6) => t4[1] - e6[1])[0]) ? void 0 : B[0].placement;
              t3 && (n3 = t3);
              break;
            }
            case "initialPlacement":
              n3 = c3;
          }
          if (r3 !== n3)
            return { reset: { placement: n3 } };
        }
        return {};
      } };
    };
    var O = function(e4) {
      return void 0 === e4 && (e4 = 0), { name: "offset", options: e4, async fn(i4) {
        const { x: r3, y: a3 } = i4, l3 = await async function(e5, i5) {
          const { placement: r4, platform: a4, elements: l4 } = e5, s3 = await (null == a4.isRTL ? void 0 : a4.isRTL(l4.floating)), c3 = n(r4), f3 = t(r4), u3 = "x" === o2(r4), m3 = ["left", "top"].includes(c3) ? -1 : 1, g3 = s3 && u3 ? -1 : 1, d3 = "function" == typeof i5 ? i5(e5) : i5;
          let { mainAxis: p3, crossAxis: h3, alignmentAxis: y4 } = "number" == typeof d3 ? { mainAxis: d3, crossAxis: 0, alignmentAxis: null } : __spreadValues({ mainAxis: 0, crossAxis: 0, alignmentAxis: null }, d3);
          return f3 && "number" == typeof y4 && (h3 = "end" === f3 ? -1 * y4 : y4), u3 ? { x: h3 * g3, y: p3 * m3 } : { x: p3 * m3, y: h3 * g3 };
        }(i4, e4);
        return { x: r3 + l3.x, y: a3 + l3.y, data: l3 };
      } };
    };
    function D(t2) {
      return "x" === t2 ? "y" : "x";
    }
    var E = function(t2) {
      return void 0 === t2 && (t2 = {}), { name: "shift", options: t2, async fn(e4) {
        const { x: i4, y: r3, placement: a3 } = e4, _a = t2, { mainAxis: l3 = true, crossAxis: c3 = false, limiter: f3 = { fn: (t3) => {
          let { x: e5, y: n3 } = t3;
          return { x: e5, y: n3 };
        } } } = _a, m3 = __objRest(_a, ["mainAxis", "crossAxis", "limiter"]), g3 = { x: i4, y: r3 }, d3 = await s(e4, m3), p3 = o2(n(a3)), h3 = D(p3);
        let y4 = g3[p3], x3 = g3[h3];
        if (l3) {
          const t3 = "y" === p3 ? "bottom" : "right";
          y4 = u(y4 + d3["y" === p3 ? "top" : "left"], y4, y4 - d3[t3]);
        }
        if (c3) {
          const t3 = "y" === h3 ? "bottom" : "right";
          x3 = u(x3 + d3["y" === h3 ? "top" : "left"], x3, x3 - d3[t3]);
        }
        const w3 = f3.fn(__spreadProps(__spreadValues({}, e4), { [p3]: y4, [h3]: x3 }));
        return __spreadProps(__spreadValues({}, w3), { data: { x: w3.x - i4, y: w3.y - r3 } });
      } };
    };
    var k = function(e4) {
      return void 0 === e4 && (e4 = {}), { name: "size", options: e4, async fn(o4) {
        const { placement: i4, rects: r3, platform: a3, elements: l3 } = o4, _a = e4, { apply: c3 = () => {
        } } = _a, u3 = __objRest(_a, ["apply"]), m3 = await s(o4, u3), g3 = n(i4), d3 = t(i4);
        let p3, h3;
        "top" === g3 || "bottom" === g3 ? (p3 = g3, h3 = d3 === (await (null == a3.isRTL ? void 0 : a3.isRTL(l3.floating)) ? "start" : "end") ? "left" : "right") : (h3 = g3, p3 = "end" === d3 ? "top" : "bottom");
        const y4 = f(m3.left, 0), x3 = f(m3.right, 0), w3 = f(m3.top, 0), v3 = f(m3.bottom, 0), b3 = { availableHeight: r3.floating.height - (["left", "right"].includes(i4) ? 2 * (0 !== w3 || 0 !== v3 ? w3 + v3 : f(m3.top, m3.bottom)) : m3[p3]), availableWidth: r3.floating.width - (["top", "bottom"].includes(i4) ? 2 * (0 !== y4 || 0 !== x3 ? y4 + x3 : f(m3.left, m3.right)) : m3[h3]) };
        await c3(__spreadValues(__spreadValues({}, o4), b3));
        const R2 = await a3.getDimensions(l3.floating);
        return r3.floating.width !== R2.width || r3.floating.height !== R2.height ? { reset: { rects: true } } : {};
      } };
    };

    // node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
    function n2(t2) {
      var e4;
      return (null == (e4 = t2.ownerDocument) ? void 0 : e4.defaultView) || window;
    }
    function o3(t2) {
      return n2(t2).getComputedStyle(t2);
    }
    function i3(t2) {
      return f2(t2) ? (t2.nodeName || "").toLowerCase() : "";
    }
    var r2;
    function l2() {
      if (r2)
        return r2;
      const t2 = navigator.userAgentData;
      return t2 && Array.isArray(t2.brands) ? (r2 = t2.brands.map((t3) => t3.brand + "/" + t3.version).join(" "), r2) : navigator.userAgent;
    }
    function c2(t2) {
      return t2 instanceof n2(t2).HTMLElement;
    }
    function s2(t2) {
      return t2 instanceof n2(t2).Element;
    }
    function f2(t2) {
      return t2 instanceof n2(t2).Node;
    }
    function u2(t2) {
      if ("undefined" == typeof ShadowRoot)
        return false;
      return t2 instanceof n2(t2).ShadowRoot || t2 instanceof ShadowRoot;
    }
    function a2(t2) {
      const { overflow: e4, overflowX: n3, overflowY: i4, display: r3 } = o3(t2);
      return /auto|scroll|overlay|hidden|clip/.test(e4 + i4 + n3) && !["inline", "contents"].includes(r3);
    }
    function d2(t2) {
      return ["table", "td", "th"].includes(i3(t2));
    }
    function h2(t2) {
      const e4 = /firefox/i.test(l2()), n3 = o3(t2), i4 = n3.backdropFilter || n3.WebkitBackdropFilter;
      return "none" !== n3.transform || "none" !== n3.perspective || !!i4 && "none" !== i4 || e4 && "filter" === n3.willChange || e4 && !!n3.filter && "none" !== n3.filter || ["transform", "perspective"].some((t3) => n3.willChange.includes(t3)) || ["paint", "layout", "strict", "content"].some((t3) => {
        const e5 = n3.contain;
        return null != e5 && e5.includes(t3);
      });
    }
    function p2() {
      return !/^((?!chrome|android).)*safari/i.test(l2());
    }
    function g2(t2) {
      return ["html", "body", "#document"].includes(i3(t2));
    }
    var m2 = Math.min;
    var y3 = Math.max;
    var x2 = Math.round;
    function w2(t2) {
      const e4 = o3(t2);
      let n3 = parseFloat(e4.width), i4 = parseFloat(e4.height);
      const r3 = t2.offsetWidth, l3 = t2.offsetHeight, c3 = x2(n3) !== r3 || x2(i4) !== l3;
      return c3 && (n3 = r3, i4 = l3), { width: n3, height: i4, fallback: c3 };
    }
    function v2(t2) {
      return s2(t2) ? t2 : t2.contextElement;
    }
    var b2 = { x: 1, y: 1 };
    function L2(t2) {
      const e4 = v2(t2);
      if (!c2(e4))
        return b2;
      const n3 = e4.getBoundingClientRect(), { width: o4, height: i4, fallback: r3 } = w2(e4);
      let l3 = (r3 ? x2(n3.width) : n3.width) / o4, s3 = (r3 ? x2(n3.height) : n3.height) / i4;
      return l3 && Number.isFinite(l3) || (l3 = 1), s3 && Number.isFinite(s3) || (s3 = 1), { x: l3, y: s3 };
    }
    function E2(t2, e4, o4, i4) {
      var r3, l3;
      void 0 === e4 && (e4 = false), void 0 === o4 && (o4 = false);
      const c3 = t2.getBoundingClientRect(), f3 = v2(t2);
      let u3 = b2;
      e4 && (i4 ? s2(i4) && (u3 = L2(i4)) : u3 = L2(t2));
      const a3 = f3 ? n2(f3) : window, d3 = !p2() && o4;
      let h3 = (c3.left + (d3 && (null == (r3 = a3.visualViewport) ? void 0 : r3.offsetLeft) || 0)) / u3.x, g3 = (c3.top + (d3 && (null == (l3 = a3.visualViewport) ? void 0 : l3.offsetTop) || 0)) / u3.y, m3 = c3.width / u3.x, y4 = c3.height / u3.y;
      if (f3) {
        const t3 = n2(f3), e5 = i4 && s2(i4) ? n2(i4) : i4;
        let o5 = t3.frameElement;
        for (; o5 && i4 && e5 !== t3; ) {
          const t4 = L2(o5), e6 = o5.getBoundingClientRect(), i5 = getComputedStyle(o5);
          e6.x += (o5.clientLeft + parseFloat(i5.paddingLeft)) * t4.x, e6.y += (o5.clientTop + parseFloat(i5.paddingTop)) * t4.y, h3 *= t4.x, g3 *= t4.y, m3 *= t4.x, y4 *= t4.y, h3 += e6.x, g3 += e6.y, o5 = n2(o5).frameElement;
        }
      }
      return { width: m3, height: y4, top: g3, right: h3 + m3, bottom: g3 + y4, left: h3, x: h3, y: g3 };
    }
    function R(t2) {
      return ((f2(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
    }
    function T2(t2) {
      return s2(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
    }
    function C(t2) {
      return E2(R(t2)).left + T2(t2).scrollLeft;
    }
    function F(t2, e4, n3) {
      const o4 = c2(e4), r3 = R(e4), l3 = E2(t2, true, "fixed" === n3, e4);
      let s3 = { scrollLeft: 0, scrollTop: 0 };
      const f3 = { x: 0, y: 0 };
      if (o4 || !o4 && "fixed" !== n3)
        if (("body" !== i3(e4) || a2(r3)) && (s3 = T2(e4)), c2(e4)) {
          const t3 = E2(e4, true);
          f3.x = t3.x + e4.clientLeft, f3.y = t3.y + e4.clientTop;
        } else
          r3 && (f3.x = C(r3));
      return { x: l3.left + s3.scrollLeft - f3.x, y: l3.top + s3.scrollTop - f3.y, width: l3.width, height: l3.height };
    }
    function W(t2) {
      if ("html" === i3(t2))
        return t2;
      const e4 = t2.assignedSlot || t2.parentNode || (u2(t2) ? t2.host : null) || R(t2);
      return u2(e4) ? e4.host : e4;
    }
    function D2(t2) {
      return c2(t2) && "fixed" !== o3(t2).position ? t2.offsetParent : null;
    }
    function S(t2) {
      const e4 = n2(t2);
      let r3 = D2(t2);
      for (; r3 && d2(r3) && "static" === o3(r3).position; )
        r3 = D2(r3);
      return r3 && ("html" === i3(r3) || "body" === i3(r3) && "static" === o3(r3).position && !h2(r3)) ? e4 : r3 || function(t3) {
        let e5 = W(t3);
        for (; c2(e5) && !g2(e5); ) {
          if (h2(e5))
            return e5;
          e5 = W(e5);
        }
        return null;
      }(t2) || e4;
    }
    function A(t2) {
      const e4 = W(t2);
      return g2(e4) ? t2.ownerDocument.body : c2(e4) && a2(e4) ? e4 : A(e4);
    }
    function H(t2, e4) {
      var o4;
      void 0 === e4 && (e4 = []);
      const i4 = A(t2), r3 = i4 === (null == (o4 = t2.ownerDocument) ? void 0 : o4.body), l3 = n2(i4);
      return r3 ? e4.concat(l3, l3.visualViewport || [], a2(i4) ? i4 : []) : e4.concat(i4, H(i4));
    }
    function O2(e4, i4, r3) {
      return "viewport" === i4 ? l(function(t2, e5) {
        const o4 = n2(t2), i5 = R(t2), r4 = o4.visualViewport;
        let l3 = i5.clientWidth, c3 = i5.clientHeight, s3 = 0, f3 = 0;
        if (r4) {
          l3 = r4.width, c3 = r4.height;
          const t3 = p2();
          (t3 || !t3 && "fixed" === e5) && (s3 = r4.offsetLeft, f3 = r4.offsetTop);
        }
        return { width: l3, height: c3, x: s3, y: f3 };
      }(e4, r3)) : s2(i4) ? function(t2, e5) {
        const n3 = E2(t2, true, "fixed" === e5), o4 = n3.top + t2.clientTop, i5 = n3.left + t2.clientLeft, r4 = c2(t2) ? L2(t2) : { x: 1, y: 1 }, l3 = t2.clientWidth * r4.x, s3 = t2.clientHeight * r4.y, f3 = i5 * r4.x, u3 = o4 * r4.y;
        return { top: u3, left: f3, right: f3 + l3, bottom: u3 + s3, x: f3, y: u3, width: l3, height: s3 };
      }(i4, r3) : l(function(t2) {
        var e5;
        const n3 = R(t2), i5 = T2(t2), r4 = null == (e5 = t2.ownerDocument) ? void 0 : e5.body, l3 = y3(n3.scrollWidth, n3.clientWidth, r4 ? r4.scrollWidth : 0, r4 ? r4.clientWidth : 0), c3 = y3(n3.scrollHeight, n3.clientHeight, r4 ? r4.scrollHeight : 0, r4 ? r4.clientHeight : 0);
        let s3 = -i5.scrollLeft + C(t2);
        const f3 = -i5.scrollTop;
        return "rtl" === o3(r4 || n3).direction && (s3 += y3(n3.clientWidth, r4 ? r4.clientWidth : 0) - l3), { width: l3, height: c3, x: s3, y: f3 };
      }(R(e4)));
    }
    var P2 = { getClippingRect: function(t2) {
      let { element: e4, boundary: n3, rootBoundary: r3, strategy: l3 } = t2;
      const c3 = "clippingAncestors" === n3 ? function(t3, e5) {
        const n4 = e5.get(t3);
        if (n4)
          return n4;
        let r4 = H(t3).filter((t4) => s2(t4) && "body" !== i3(t4)), l4 = null;
        const c4 = "fixed" === o3(t3).position;
        let f4 = c4 ? W(t3) : t3;
        for (; s2(f4) && !g2(f4); ) {
          const t4 = o3(f4), e6 = h2(f4);
          (c4 ? e6 || l4 : e6 || "static" !== t4.position || !l4 || !["absolute", "fixed"].includes(l4.position)) ? l4 = t4 : r4 = r4.filter((t5) => t5 !== f4), f4 = W(f4);
        }
        return e5.set(t3, r4), r4;
      }(e4, this._c) : [].concat(n3), f3 = [...c3, r3], u3 = f3[0], a3 = f3.reduce((t3, n4) => {
        const o4 = O2(e4, n4, l3);
        return t3.top = y3(o4.top, t3.top), t3.right = m2(o4.right, t3.right), t3.bottom = m2(o4.bottom, t3.bottom), t3.left = y3(o4.left, t3.left), t3;
      }, O2(e4, u3, l3));
      return { width: a3.right - a3.left, height: a3.bottom - a3.top, x: a3.left, y: a3.top };
    }, convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
      let { rect: e4, offsetParent: n3, strategy: o4 } = t2;
      const r3 = c2(n3), l3 = R(n3);
      if (n3 === l3)
        return e4;
      let s3 = { scrollLeft: 0, scrollTop: 0 }, f3 = { x: 1, y: 1 };
      const u3 = { x: 0, y: 0 };
      if ((r3 || !r3 && "fixed" !== o4) && (("body" !== i3(n3) || a2(l3)) && (s3 = T2(n3)), c2(n3))) {
        const t3 = E2(n3);
        f3 = L2(n3), u3.x = t3.x + n3.clientLeft, u3.y = t3.y + n3.clientTop;
      }
      return { width: e4.width * f3.x, height: e4.height * f3.y, x: e4.x * f3.x - s3.scrollLeft * f3.x + u3.x, y: e4.y * f3.y - s3.scrollTop * f3.y + u3.y };
    }, isElement: s2, getDimensions: function(t2) {
      return w2(t2);
    }, getOffsetParent: S, getDocumentElement: R, getScale: L2, async getElementRects(t2) {
      let { reference: e4, floating: n3, strategy: o4 } = t2;
      const i4 = this.getOffsetParent || S, r3 = this.getDimensions;
      return { reference: F(e4, await i4(n3), o4), floating: __spreadValues({ x: 0, y: 0 }, await r3(n3)) };
    }, getClientRects: (t2) => Array.from(t2.getClientRects()), isRTL: (t2) => "rtl" === o3(t2).direction };
    function z(t2, e4, n3, o4) {
      void 0 === o4 && (o4 = {});
      const { ancestorScroll: i4 = true, ancestorResize: r3 = true, elementResize: l3 = true, animationFrame: c3 = false } = o4, f3 = i4 && !c3, u3 = f3 || r3 ? [...s2(t2) ? H(t2) : t2.contextElement ? H(t2.contextElement) : [], ...H(e4)] : [];
      u3.forEach((t3) => {
        f3 && t3.addEventListener("scroll", n3, { passive: true }), r3 && t3.addEventListener("resize", n3);
      });
      let a3, d3 = null;
      if (l3) {
        let o5 = true;
        d3 = new ResizeObserver(() => {
          o5 || n3(), o5 = false;
        }), s2(t2) && !c3 && d3.observe(t2), s2(t2) || !t2.contextElement || c3 || d3.observe(t2.contextElement), d3.observe(e4);
      }
      let h3 = c3 ? E2(t2) : null;
      return c3 && function e5() {
        const o5 = E2(t2);
        !h3 || o5.x === h3.x && o5.y === h3.y && o5.width === h3.width && o5.height === h3.height || n3();
        h3 = o5, a3 = requestAnimationFrame(e5);
      }(), n3(), () => {
        var t3;
        u3.forEach((t4) => {
          f3 && t4.removeEventListener("scroll", n3), r3 && t4.removeEventListener("resize", n3);
        }), null == (t3 = d3) || t3.disconnect(), d3 = null, c3 && cancelAnimationFrame(a3);
      };
    }
    var V = (t2, n3, o4) => {
      const i4 = /* @__PURE__ */ new Map(), r3 = __spreadValues({ platform: P2 }, o4), l3 = __spreadProps(__spreadValues({}, r3.platform), { _c: i4 });
      return r(t2, n3, __spreadProps(__spreadValues({}, r3), { platform: l3 }));
    };

    // src/components/popup/popup.ts
    var SlPopup = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.active = false;
        this.placement = "top";
        this.strategy = "absolute";
        this.distance = 0;
        this.skidding = 0;
        this.arrow = false;
        this.arrowPlacement = "anchor";
        this.arrowPadding = 10;
        this.flip = false;
        this.flipFallbackPlacements = "";
        this.flipFallbackStrategy = "best-fit";
        this.flipPadding = 0;
        this.shift = false;
        this.shiftPadding = 0;
        this.autoSizePadding = 0;
      }
      async connectedCallback() {
        super.connectedCallback();
        await this.updateComplete;
        this.start();
      }
      disconnectedCallback() {
        this.stop();
      }
      async updated(changedProps) {
        super.updated(changedProps);
        if (changedProps.has("active")) {
          if (this.active) {
            this.start();
          } else {
            this.stop();
          }
        }
        if (changedProps.has("anchor")) {
          this.handleAnchorChange();
        }
        if (this.active) {
          await this.updateComplete;
          this.reposition();
        }
      }
      async handleAnchorChange() {
        await this.stop();
        if (this.anchor && typeof this.anchor === "string") {
          const root = this.getRootNode();
          this.anchorEl = root.getElementById(this.anchor);
        } else if (this.anchor instanceof HTMLElement) {
          this.anchorEl = this.anchor;
        } else {
          this.anchorEl = this.querySelector('[slot="anchor"]');
        }
        if (this.anchorEl instanceof HTMLSlotElement) {
          this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
        }
        if (!this.anchorEl) {
          throw new Error(
            "Invalid anchor element: no anchor could be found using the anchor slot or the anchor attribute."
          );
        }
        this.start();
      }
      start() {
        if (!this.anchorEl) {
          return;
        }
        this.cleanup = z(this.anchorEl, this.popup, () => {
          this.reposition();
        });
      }
      async stop() {
        return new Promise((resolve) => {
          if (this.cleanup) {
            this.cleanup();
            this.cleanup = void 0;
            this.removeAttribute("data-current-placement");
            this.style.removeProperty("--auto-size-available-width");
            this.style.removeProperty("--auto-size-available-height");
            requestAnimationFrame(() => resolve());
          } else {
            resolve();
          }
        });
      }
      /** Forces the popup to recalculate and reposition itself. */
      reposition() {
        if (!this.active || !this.anchorEl) {
          return;
        }
        const middleware = [
          // The offset middleware goes first
          O({ mainAxis: this.distance, crossAxis: this.skidding })
        ];
        if (this.sync) {
          middleware.push(
            k({
              apply: ({ rects }) => {
                const syncWidth = this.sync === "width" || this.sync === "both";
                const syncHeight = this.sync === "height" || this.sync === "both";
                this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
                this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
              }
            })
          );
        } else {
          this.popup.style.width = "";
          this.popup.style.height = "";
        }
        if (this.flip) {
          middleware.push(
            b({
              boundary: this.flipBoundary,
              // @ts-expect-error - We're converting a string attribute to an array here
              fallbackPlacements: this.flipFallbackPlacements,
              fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
              padding: this.flipPadding
            })
          );
        }
        if (this.shift) {
          middleware.push(
            E({
              boundary: this.shiftBoundary,
              padding: this.shiftPadding
            })
          );
        }
        if (this.autoSize) {
          middleware.push(
            k({
              boundary: this.autoSizeBoundary,
              padding: this.autoSizePadding,
              apply: ({ availableWidth, availableHeight }) => {
                if (this.autoSize === "vertical" || this.autoSize === "both") {
                  this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
                } else {
                  this.style.removeProperty("--auto-size-available-height");
                }
                if (this.autoSize === "horizontal" || this.autoSize === "both") {
                  this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
                } else {
                  this.style.removeProperty("--auto-size-available-width");
                }
              }
            })
          );
        } else {
          this.style.removeProperty("--auto-size-available-width");
          this.style.removeProperty("--auto-size-available-height");
        }
        if (this.arrow) {
          middleware.push(
            m({
              element: this.arrowEl,
              padding: this.arrowPadding
            })
          );
        }
        V(this.anchorEl, this.popup, {
          placement: this.placement,
          middleware,
          strategy: this.strategy
        }).then(({ x: x3, y: y4, middlewareData, placement }) => {
          const isRtl = getComputedStyle(this).direction === "rtl";
          const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
          this.setAttribute("data-current-placement", placement);
          Object.assign(this.popup.style, {
            left: `${x3}px`,
            top: `${y4}px`
          });
          if (this.arrow) {
            const arrowX = middlewareData.arrow.x;
            const arrowY = middlewareData.arrow.y;
            let top = "";
            let right = "";
            let bottom = "";
            let left = "";
            if (this.arrowPlacement === "start") {
              const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
              top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
              right = isRtl ? value : "";
              left = isRtl ? "" : value;
            } else if (this.arrowPlacement === "end") {
              const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
              right = isRtl ? "" : value;
              left = isRtl ? value : "";
              bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
            } else if (this.arrowPlacement === "center") {
              left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
              top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
            } else {
              left = typeof arrowX === "number" ? `${arrowX}px` : "";
              top = typeof arrowY === "number" ? `${arrowY}px` : "";
            }
            Object.assign(this.arrowEl.style, {
              top,
              right,
              bottom,
              left,
              [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
            });
          }
        });
        this.emit("sl-reposition");
      }
      render() {
        return y`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <div
        part="popup"
        class=${o$1({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? y`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
      }
    };
    SlPopup.styles = popup_styles_default;
    __decorateClass([
      i2$2(".popup")
    ], SlPopup.prototype, "popup", 2);
    __decorateClass([
      i2$2(".popup__arrow")
    ], SlPopup.prototype, "arrowEl", 2);
    __decorateClass([
      e2$1()
    ], SlPopup.prototype, "anchor", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlPopup.prototype, "active", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlPopup.prototype, "placement", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlPopup.prototype, "strategy", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlPopup.prototype, "distance", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlPopup.prototype, "skidding", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlPopup.prototype, "arrow", 2);
    __decorateClass([
      e2$1({ attribute: "arrow-placement" })
    ], SlPopup.prototype, "arrowPlacement", 2);
    __decorateClass([
      e2$1({ attribute: "arrow-padding", type: Number })
    ], SlPopup.prototype, "arrowPadding", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlPopup.prototype, "flip", 2);
    __decorateClass([
      e2$1({
        attribute: "flip-fallback-placements",
        converter: {
          fromAttribute: (value) => {
            return value.split(" ").map((p3) => p3.trim()).filter((p3) => p3 !== "");
          },
          toAttribute: (value) => {
            return value.join(" ");
          }
        }
      })
    ], SlPopup.prototype, "flipFallbackPlacements", 2);
    __decorateClass([
      e2$1({ attribute: "flip-fallback-strategy" })
    ], SlPopup.prototype, "flipFallbackStrategy", 2);
    __decorateClass([
      e2$1({ type: Object })
    ], SlPopup.prototype, "flipBoundary", 2);
    __decorateClass([
      e2$1({ attribute: "flip-padding", type: Number })
    ], SlPopup.prototype, "flipPadding", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlPopup.prototype, "shift", 2);
    __decorateClass([
      e2$1({ type: Object })
    ], SlPopup.prototype, "shiftBoundary", 2);
    __decorateClass([
      e2$1({ attribute: "shift-padding", type: Number })
    ], SlPopup.prototype, "shiftPadding", 2);
    __decorateClass([
      e2$1({ attribute: "auto-size" })
    ], SlPopup.prototype, "autoSize", 2);
    __decorateClass([
      e2$1()
    ], SlPopup.prototype, "sync", 2);
    __decorateClass([
      e2$1({ type: Object })
    ], SlPopup.prototype, "autoSizeBoundary", 2);
    __decorateClass([
      e2$1({ attribute: "auto-size-padding", type: Number })
    ], SlPopup.prototype, "autoSizePadding", 2);
    SlPopup = __decorateClass([
      e$1("sl-popup")
    ], SlPopup);

    // src/components/button-group/button-group.styles.ts
    var button_group_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;

    // src/components/button-group/button-group.ts
    var SlButtonGroup = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.disableRole = false;
        this.label = "";
      }
      handleFocus(event) {
        const button = findButton(event.target);
        button == null ? void 0 : button.classList.add("sl-button-group__button--focus");
      }
      handleBlur(event) {
        const button = findButton(event.target);
        button == null ? void 0 : button.classList.remove("sl-button-group__button--focus");
      }
      handleMouseOver(event) {
        const button = findButton(event.target);
        button == null ? void 0 : button.classList.add("sl-button-group__button--hover");
      }
      handleMouseOut(event) {
        const button = findButton(event.target);
        button == null ? void 0 : button.classList.remove("sl-button-group__button--hover");
      }
      handleSlotChange() {
        const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
        slottedElements.forEach((el) => {
          const index = slottedElements.indexOf(el);
          const button = findButton(el);
          if (button !== null) {
            button.classList.add("sl-button-group__button");
            button.classList.toggle("sl-button-group__button--first", index === 0);
            button.classList.toggle("sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
            button.classList.toggle("sl-button-group__button--last", index === slottedElements.length - 1);
            button.classList.toggle("sl-button-group__button--radio", button.tagName.toLowerCase() === "sl-radio-button");
          }
        });
      }
      render() {
        return y`
      <slot
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
        @slotchange=${this.handleSlotChange}
      ></slot>
    `;
      }
    };
    SlButtonGroup.styles = button_group_styles_default;
    __decorateClass([
      i2$2("slot")
    ], SlButtonGroup.prototype, "defaultSlot", 2);
    __decorateClass([
      t$1()
    ], SlButtonGroup.prototype, "disableRole", 2);
    __decorateClass([
      e2$1()
    ], SlButtonGroup.prototype, "label", 2);
    SlButtonGroup = __decorateClass([
      e$1("sl-button-group")
    ], SlButtonGroup);
    function findButton(el) {
      var _a;
      const selector = "sl-button, sl-radio-button";
      return (_a = el.closest(selector)) != null ? _a : el.querySelector(selector);
    }

    // src/components/tab-group/tab-group.styles.ts
    var tab_group_styles_default = i$3`
  ${component_styles_default}

  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition: var(--sl-transition-fast) translate ease, var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;

    // src/components/tab-group/tab-group.ts
    var SlTabGroup = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.localize = new LocalizeController2(this);
        this.tabs = [];
        this.panels = [];
        this.hasScrollControls = false;
        this.placement = "top";
        this.activation = "auto";
        this.noScrollControls = false;
      }
      connectedCallback() {
        super.connectedCallback();
        this.resizeObserver = new ResizeObserver(() => {
          this.repositionIndicator();
          this.updateScrollControls();
        });
        this.mutationObserver = new MutationObserver((mutations) => {
          if (mutations.some((m) => !["aria-labelledby", "aria-controls"].includes(m.attributeName))) {
            setTimeout(() => this.setAriaLabels());
          }
          if (mutations.some((m) => m.attributeName === "disabled")) {
            this.syncTabsAndPanels();
          }
        });
        this.updateComplete.then(() => {
          this.syncTabsAndPanels();
          this.mutationObserver.observe(this, { attributes: true, childList: true, subtree: true });
          this.resizeObserver.observe(this.nav);
          const intersectionObserver = new IntersectionObserver((entries, observer) => {
            var _a;
            if (entries[0].intersectionRatio > 0) {
              this.setAriaLabels();
              this.setActiveTab((_a = this.getActiveTab()) != null ? _a : this.tabs[0], { emitEvents: false });
              observer.unobserve(entries[0].target);
            }
          });
          intersectionObserver.observe(this.tabGroup);
        });
      }
      disconnectedCallback() {
        this.mutationObserver.disconnect();
        this.resizeObserver.unobserve(this.nav);
      }
      getAllTabs(options = { includeDisabled: true }) {
        const slot = this.shadowRoot.querySelector('slot[name="nav"]');
        return [...slot.assignedElements()].filter((el) => {
          return options.includeDisabled ? el.tagName.toLowerCase() === "sl-tab" : el.tagName.toLowerCase() === "sl-tab" && !el.disabled;
        });
      }
      getAllPanels() {
        return [...this.body.assignedElements()].filter((el) => el.tagName.toLowerCase() === "sl-tab-panel");
      }
      getActiveTab() {
        return this.tabs.find((el) => el.active);
      }
      handleClick(event) {
        const target = event.target;
        const tab = target.closest("sl-tab");
        const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
        if (tabGroup !== this) {
          return;
        }
        if (tab !== null) {
          this.setActiveTab(tab, { scrollBehavior: "smooth" });
        }
      }
      handleKeyDown(event) {
        const target = event.target;
        const tab = target.closest("sl-tab");
        const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
        if (tabGroup !== this) {
          return;
        }
        if (["Enter", " "].includes(event.key)) {
          if (tab !== null) {
            this.setActiveTab(tab, { scrollBehavior: "smooth" });
            event.preventDefault();
          }
        }
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
          const activeEl = this.tabs.find((t2) => t2.matches(":focus"));
          const isRtl = this.localize.dir() === "rtl";
          if ((activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) === "sl-tab") {
            let index = this.tabs.indexOf(activeEl);
            if (event.key === "Home") {
              index = 0;
            } else if (event.key === "End") {
              index = this.tabs.length - 1;
            } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && event.key === "ArrowUp") {
              index--;
            } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && event.key === "ArrowDown") {
              index++;
            }
            if (index < 0) {
              index = this.tabs.length - 1;
            }
            if (index > this.tabs.length - 1) {
              index = 0;
            }
            this.tabs[index].focus({ preventScroll: true });
            if (this.activation === "auto") {
              this.setActiveTab(this.tabs[index], { scrollBehavior: "smooth" });
            }
            if (["top", "bottom"].includes(this.placement)) {
              scrollIntoView(this.tabs[index], this.nav, "horizontal");
            }
            event.preventDefault();
          }
        }
      }
      handleScrollToStart() {
        this.nav.scroll({
          left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
          behavior: "smooth"
        });
      }
      handleScrollToEnd() {
        this.nav.scroll({
          left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
          behavior: "smooth"
        });
      }
      setActiveTab(tab, options) {
        options = __spreadValues({
          emitEvents: true,
          scrollBehavior: "auto"
        }, options);
        if (tab !== this.activeTab && !tab.disabled) {
          const previousTab = this.activeTab;
          this.activeTab = tab;
          this.tabs.map((el) => el.active = el === this.activeTab);
          this.panels.map((el) => {
            var _a;
            return el.active = el.name === ((_a = this.activeTab) == null ? void 0 : _a.panel);
          });
          this.syncIndicator();
          if (["top", "bottom"].includes(this.placement)) {
            scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
          }
          if (options.emitEvents) {
            if (previousTab) {
              this.emit("sl-tab-hide", { detail: { name: previousTab.panel } });
            }
            this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } });
          }
        }
      }
      setAriaLabels() {
        this.tabs.forEach((tab) => {
          const panel = this.panels.find((el) => el.name === tab.panel);
          if (panel) {
            tab.setAttribute("aria-controls", panel.getAttribute("id"));
            panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
          }
        });
      }
      repositionIndicator() {
        const currentTab = this.getActiveTab();
        if (!currentTab) {
          return;
        }
        const width = currentTab.clientWidth;
        const height = currentTab.clientHeight;
        const isRtl = this.localize.dir() === "rtl";
        const allTabs = this.getAllTabs();
        const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
        const offset = precedingTabs.reduce(
          (previous, current) => ({
            left: previous.left + current.clientWidth,
            top: previous.top + current.clientHeight
          }),
          { left: 0, top: 0 }
        );
        switch (this.placement) {
          case "top":
          case "bottom":
            this.indicator.style.width = `${width}px`;
            this.indicator.style.height = "auto";
            this.indicator.style.translate = isRtl ? `${-1 * offset.left}px` : `${offset.left}px`;
            break;
          case "start":
          case "end":
            this.indicator.style.width = "auto";
            this.indicator.style.height = `${height}px`;
            this.indicator.style.translate = `0 ${offset.top}px`;
            break;
        }
      }
      // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
      syncTabsAndPanels() {
        this.tabs = this.getAllTabs({ includeDisabled: false });
        this.panels = this.getAllPanels();
        this.syncIndicator();
      }
      updateScrollControls() {
        if (this.noScrollControls) {
          this.hasScrollControls = false;
        } else {
          this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth;
        }
      }
      syncIndicator() {
        const tab = this.getActiveTab();
        if (tab) {
          this.indicator.style.display = "block";
          this.repositionIndicator();
        } else {
          this.indicator.style.display = "none";
        }
      }
      /** Shows the specified tab panel. */
      show(panel) {
        const tab = this.tabs.find((el) => el.panel === panel);
        if (tab) {
          this.setActiveTab(tab, { scrollBehavior: "smooth" });
        }
      }
      render() {
        const isRtl = this.localize.dir() === "rtl";
        return y`
      <div
        part="base"
        class=${o$1({
      "tab-group": true,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? y`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name=${isRtl ? "chevron-right" : "chevron-left"}
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? y`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name=${isRtl ? "chevron-left" : "chevron-right"}
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
      }
    };
    SlTabGroup.styles = tab_group_styles_default;
    __decorateClass([
      i2$2(".tab-group")
    ], SlTabGroup.prototype, "tabGroup", 2);
    __decorateClass([
      i2$2(".tab-group__body")
    ], SlTabGroup.prototype, "body", 2);
    __decorateClass([
      i2$2(".tab-group__nav")
    ], SlTabGroup.prototype, "nav", 2);
    __decorateClass([
      i2$2(".tab-group__indicator")
    ], SlTabGroup.prototype, "indicator", 2);
    __decorateClass([
      t$1()
    ], SlTabGroup.prototype, "hasScrollControls", 2);
    __decorateClass([
      e2$1()
    ], SlTabGroup.prototype, "placement", 2);
    __decorateClass([
      e2$1()
    ], SlTabGroup.prototype, "activation", 2);
    __decorateClass([
      e2$1({ attribute: "no-scroll-controls", type: Boolean })
    ], SlTabGroup.prototype, "noScrollControls", 2);
    __decorateClass([
      watch("noScrollControls", { waitUntilFirstUpdate: true })
    ], SlTabGroup.prototype, "updateScrollControls", 1);
    __decorateClass([
      watch("placement", { waitUntilFirstUpdate: true })
    ], SlTabGroup.prototype, "syncIndicator", 1);
    SlTabGroup = __decorateClass([
      e$1("sl-tab-group")
    ], SlTabGroup);

    // src/components/tab/tab.styles.ts
    var tab_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    cursor: pointer;
    transition: var(--transition-speed) box-shadow, var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab:focus-visible:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`;

    // src/components/tab/tab.ts
    var id$1 = 0;
    var SlTab = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.localize = new LocalizeController2(this);
        this.attrId = ++id$1;
        this.componentId = `sl-tab-${this.attrId}`;
        this.panel = "";
        this.active = false;
        this.closable = false;
        this.disabled = false;
      }
      connectedCallback() {
        super.connectedCallback();
        this.setAttribute("role", "tab");
      }
      handleCloseClick() {
        this.emit("sl-close");
      }
      handleActiveChange() {
        this.setAttribute("aria-selected", this.active ? "true" : "false");
      }
      handleDisabledChange() {
        this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
      }
      /** Sets focus to the tab. */
      focus(options) {
        this.tab.focus(options);
      }
      /** Removes focus from the tab. */
      blur() {
        this.tab.blur();
      }
      render() {
        this.id = this.id.length > 0 ? this.id : this.componentId;
        return y`
      <div
        part="base"
        class=${o$1({
      tab: true,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
        tabindex=${this.disabled ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? y`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
      }
    };
    SlTab.styles = tab_styles_default;
    __decorateClass([
      i2$2(".tab")
    ], SlTab.prototype, "tab", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlTab.prototype, "panel", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlTab.prototype, "active", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlTab.prototype, "closable", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlTab.prototype, "disabled", 2);
    __decorateClass([
      watch("active")
    ], SlTab.prototype, "handleActiveChange", 1);
    __decorateClass([
      watch("disabled")
    ], SlTab.prototype, "handleDisabledChange", 1);
    SlTab = __decorateClass([
      e$1("sl-tab")
    ], SlTab);

    // src/components/tab-panel/tab-panel.styles.ts
    var tab_panel_styles_default = i$3`
  ${component_styles_default}

  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;

    // src/components/tab-panel/tab-panel.ts
    var id = 0;
    var SlTabPanel = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.attrId = ++id;
        this.componentId = `sl-tab-panel-${this.attrId}`;
        this.name = "";
        this.active = false;
      }
      connectedCallback() {
        super.connectedCallback();
        this.id = this.id.length > 0 ? this.id : this.componentId;
        this.setAttribute("role", "tabpanel");
      }
      handleActiveChange() {
        this.setAttribute("aria-hidden", this.active ? "false" : "true");
      }
      render() {
        return y`
      <slot
        part="base"
        class=${o$1({
      "tab-panel": true,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
      }
    };
    SlTabPanel.styles = tab_panel_styles_default;
    __decorateClass([
      e2$1({ reflect: true })
    ], SlTabPanel.prototype, "name", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlTabPanel.prototype, "active", 2);
    __decorateClass([
      watch("active")
    ], SlTabPanel.prototype, "handleActiveChange", 1);
    SlTabPanel = __decorateClass([
      e$1("sl-tab-panel")
    ], SlTabPanel);

    // src/components/tooltip/tooltip.styles.ts
    var tooltip_styles_default = i$3`
  ${component_styles_default}

  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    pointer-events: none;
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
  }
`;

    // src/components/tooltip/tooltip.ts
    var SlTooltip = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.localize = new LocalizeController2(this);
        this.content = "";
        this.placement = "top";
        this.disabled = false;
        this.distance = 8;
        this.open = false;
        this.skidding = 0;
        this.trigger = "hover focus";
        this.hoist = false;
      }
      connectedCallback() {
        super.connectedCallback();
        this.handleBlur = this.handleBlur.bind(this);
        this.handleClick = this.handleClick.bind(this);
        this.handleFocus = this.handleFocus.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleMouseOver = this.handleMouseOver.bind(this);
        this.handleMouseOut = this.handleMouseOut.bind(this);
        this.updateComplete.then(() => {
          this.addEventListener("blur", this.handleBlur, true);
          this.addEventListener("focus", this.handleFocus, true);
          this.addEventListener("click", this.handleClick);
          this.addEventListener("keydown", this.handleKeyDown);
          this.addEventListener("mouseover", this.handleMouseOver);
          this.addEventListener("mouseout", this.handleMouseOut);
        });
      }
      firstUpdated() {
        this.body.hidden = !this.open;
        if (this.open) {
          this.popup.active = true;
          this.popup.reposition();
        }
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("blur", this.handleBlur, true);
        this.removeEventListener("focus", this.handleFocus, true);
        this.removeEventListener("click", this.handleClick);
        this.removeEventListener("keydown", this.handleKeyDown);
        this.removeEventListener("mouseover", this.handleMouseOver);
        this.removeEventListener("mouseout", this.handleMouseOut);
      }
      handleBlur() {
        if (this.hasTrigger("focus")) {
          this.hide();
        }
      }
      handleClick() {
        if (this.hasTrigger("click")) {
          if (this.open) {
            this.hide();
          } else {
            this.show();
          }
        }
      }
      handleFocus() {
        if (this.hasTrigger("focus")) {
          this.show();
        }
      }
      handleKeyDown(event) {
        if (this.open && event.key === "Escape") {
          event.stopPropagation();
          this.hide();
        }
      }
      handleMouseOver() {
        if (this.hasTrigger("hover")) {
          const delay = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
          clearTimeout(this.hoverTimeout);
          this.hoverTimeout = window.setTimeout(() => this.show(), delay);
        }
      }
      handleMouseOut() {
        if (this.hasTrigger("hover")) {
          const delay = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
          clearTimeout(this.hoverTimeout);
          this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
        }
      }
      hasTrigger(triggerType) {
        const triggers = this.trigger.split(" ");
        return triggers.includes(triggerType);
      }
      async handleOpenChange() {
        if (this.open) {
          if (this.disabled) {
            return;
          }
          this.emit("sl-show");
          await stopAnimations(this.body);
          this.body.hidden = false;
          this.popup.active = true;
          const { keyframes, options } = getAnimation(this, "tooltip.show", { dir: this.localize.dir() });
          await animateTo(this.popup.popup, keyframes, options);
          this.emit("sl-after-show");
        } else {
          this.emit("sl-hide");
          await stopAnimations(this.body);
          const { keyframes, options } = getAnimation(this, "tooltip.hide", { dir: this.localize.dir() });
          await animateTo(this.popup.popup, keyframes, options);
          this.popup.active = false;
          this.body.hidden = true;
          this.emit("sl-after-hide");
        }
      }
      async handleOptionsChange() {
        if (this.hasUpdated) {
          await this.updateComplete;
          this.popup.reposition();
        }
      }
      handleDisabledChange() {
        if (this.disabled && this.open) {
          this.hide();
        }
      }
      /** Shows the tooltip. */
      async show() {
        if (this.open) {
          return void 0;
        }
        this.open = true;
        return waitForEvent(this, "sl-after-show");
      }
      /** Hides the tooltip */
      async hide() {
        if (!this.open) {
          return void 0;
        }
        this.open = false;
        return waitForEvent(this, "sl-after-hide");
      }
      render() {
        return y`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${o$1({
      tooltip: true,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
      >
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        <slot
          name="content"
          part="body"
          id="tooltip"
          class="tooltip__body"
          role="tooltip"
          aria-live=${this.open ? "polite" : "off"}
        >
          ${this.content}
        </slot>
      </sl-popup>
    `;
      }
    };
    SlTooltip.styles = tooltip_styles_default;
    __decorateClass([
      i2$2("slot:not([name])")
    ], SlTooltip.prototype, "defaultSlot", 2);
    __decorateClass([
      i2$2(".tooltip__body")
    ], SlTooltip.prototype, "body", 2);
    __decorateClass([
      i2$2("sl-popup")
    ], SlTooltip.prototype, "popup", 2);
    __decorateClass([
      e2$1()
    ], SlTooltip.prototype, "content", 2);
    __decorateClass([
      e2$1()
    ], SlTooltip.prototype, "placement", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlTooltip.prototype, "disabled", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlTooltip.prototype, "distance", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlTooltip.prototype, "open", 2);
    __decorateClass([
      e2$1({ type: Number })
    ], SlTooltip.prototype, "skidding", 2);
    __decorateClass([
      e2$1()
    ], SlTooltip.prototype, "trigger", 2);
    __decorateClass([
      e2$1({ type: Boolean })
    ], SlTooltip.prototype, "hoist", 2);
    __decorateClass([
      watch("open", { waitUntilFirstUpdate: true })
    ], SlTooltip.prototype, "handleOpenChange", 1);
    __decorateClass([
      watch(["content", "distance", "hoist", "placement", "skidding"])
    ], SlTooltip.prototype, "handleOptionsChange", 1);
    __decorateClass([
      watch("disabled")
    ], SlTooltip.prototype, "handleDisabledChange", 1);
    SlTooltip = __decorateClass([
      e$1("sl-tooltip")
    ], SlTooltip);
    setDefaultAnimation("tooltip.show", {
      keyframes: [
        { opacity: 0, scale: 0.8 },
        { opacity: 1, scale: 1 }
      ],
      options: { duration: 150, easing: "ease" }
    });
    setDefaultAnimation("tooltip.hide", {
      keyframes: [
        { opacity: 1, scale: 1 },
        { opacity: 0, scale: 0.8 }
      ],
      options: { duration: 150, easing: "ease" }
    });

    // src/components/switch/switch.styles.ts
    var switch_styles_default = i$3`
  ${component_styles_default}

  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition: var(--sl-transition-fast) translate ease, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color, var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;

    // src/components/switch/switch.ts
    var SlSwitch = class extends ShoelaceElement {
      constructor() {
        super(...arguments);
        this.formControlController = new FormControlController(this, {
          value: (control) => control.checked ? control.value || "on" : void 0,
          defaultValue: (control) => control.defaultChecked,
          setValue: (control, checked) => control.checked = checked
        });
        this.hasFocus = false;
        this.title = "";
        this.name = "";
        this.size = "medium";
        this.disabled = false;
        this.checked = false;
        this.defaultChecked = false;
        this.form = "";
        this.required = false;
      }
      firstUpdated() {
        this.formControlController.updateValidity();
      }
      handleBlur() {
        this.hasFocus = false;
        this.emit("sl-blur");
      }
      handleInput() {
        this.emit("sl-input");
      }
      handleClick() {
        this.checked = !this.checked;
        this.emit("sl-change");
      }
      handleFocus() {
        this.hasFocus = true;
        this.emit("sl-focus");
      }
      handleKeyDown(event) {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          this.checked = false;
          this.emit("sl-change");
          this.emit("sl-input");
        }
        if (event.key === "ArrowRight") {
          event.preventDefault();
          this.checked = true;
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }
      handleCheckedChange() {
        this.input.checked = this.checked;
        this.formControlController.updateValidity();
      }
      handleDisabledChange() {
        this.formControlController.setValidity(true);
      }
      /** Simulates a click on the switch. */
      click() {
        this.input.click();
      }
      /** Sets focus on the switch. */
      focus(options) {
        this.input.focus(options);
      }
      /** Removes focus from the switch. */
      blur() {
        this.input.blur();
      }
      /** Checks for validity but does not show the browser's validation message. */
      checkValidity() {
        return this.input.checkValidity();
      }
      /** Checks for validity and shows the browser's validation message if the control is invalid. */
      reportValidity() {
        return this.input.reportValidity();
      }
      /** Sets a custom validation message. Pass an empty string to restore validity. */
      setCustomValidity(message) {
        this.input.setCustomValidity(message);
        this.formControlController.updateValidity();
      }
      render() {
        return y`
      <label
        part="base"
        class=${o$1({
      switch: true,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus,
      "switch--small": this.size === "small",
      "switch--medium": this.size === "medium",
      "switch--large": this.size === "large"
    })}
      >
        <input
          class="switch__input"
          type="checkbox"
          title=${this.title}
          name=${this.name}
          value=${l$1(this.value)}
          .checked=${l2$1(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          role="switch"
          aria-checked=${this.checked ? "true" : "false"}
          @click=${this.handleClick}
          @input=${this.handleInput}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @keydown=${this.handleKeyDown}
        />

        <span part="control" class="switch__control">
          <span part="thumb" class="switch__thumb"></span>
        </span>

        <slot part="label" class="switch__label"></slot>
      </label>
    `;
      }
    };
    SlSwitch.styles = switch_styles_default;
    __decorateClass([
      i2$2('input[type="checkbox"]')
    ], SlSwitch.prototype, "input", 2);
    __decorateClass([
      t$1()
    ], SlSwitch.prototype, "hasFocus", 2);
    __decorateClass([
      e2$1()
    ], SlSwitch.prototype, "title", 2);
    __decorateClass([
      e2$1()
    ], SlSwitch.prototype, "name", 2);
    __decorateClass([
      e2$1()
    ], SlSwitch.prototype, "value", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlSwitch.prototype, "size", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlSwitch.prototype, "disabled", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlSwitch.prototype, "checked", 2);
    __decorateClass([
      defaultValue("checked")
    ], SlSwitch.prototype, "defaultChecked", 2);
    __decorateClass([
      e2$1({ reflect: true })
    ], SlSwitch.prototype, "form", 2);
    __decorateClass([
      e2$1({ type: Boolean, reflect: true })
    ], SlSwitch.prototype, "required", 2);
    __decorateClass([
      watch("checked", { waitUntilFirstUpdate: true })
    ], SlSwitch.prototype, "handleCheckedChange", 1);
    __decorateClass([
      watch("disabled", { waitUntilFirstUpdate: true })
    ], SlSwitch.prototype, "handleDisabledChange", 1);
    SlSwitch = __decorateClass([
      e$1("sl-switch")
    ], SlSwitch);

    /* src\CanvasCollections.svelte generated by Svelte v3.55.0 */
    const file = "src\\CanvasCollections.svelte";

    // (457:0) {#if editMode && modulesPage && canvasDataLoaded && !importedCollections}
    function create_if_block(ctx) {
    	let div2;
    	let div1;
    	let sl_tooltip;
    	let div0;
    	let raw_value = /*HELP*/ ctx[7].switchTitle.tooltip + "";
    	let t0;
    	let a;
    	let i;
    	let a_href_value;
    	let t1;
    	let t2;
    	let show_if;
    	let t3;
    	let small;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let current;
    	let if_block0 = /*allDataLoaded*/ ctx[4] && !/*noCollections*/ ctx[3] && create_if_block_6(ctx);

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*$collectionsStore*/ 512) show_if = null;
    		if (show_if == null) show_if = !!isCollectionsOn(false, /*$collectionsStore*/ ctx[9]["VISIBILITY"]);
    		if (show_if) return create_if_block_5;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx, [-1, -1]);
    	let if_block1 = current_block_type(ctx);
    	let if_block2 = /*noCollections*/ ctx[3] && create_if_block_4(ctx);
    	let if_block3 = /*allDataLoaded*/ ctx[4] && /*$configStore*/ ctx[8]["ccOn"] && create_if_block_3(ctx);
    	let if_block4 = !/*ccPublished*/ ctx[11] && !/*noCollections*/ ctx[3] && create_if_block_2(ctx);
    	let if_block5 = /*showConfig*/ ctx[0] && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			sl_tooltip = element("sl-tooltip");
    			div0 = element("div");
    			t0 = space();
    			a = element("a");
    			i = element("i");
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if_block1.c();
    			t3 = space();
    			small = element("small");
    			small.textContent = "Canvas Collections";
    			t5 = space();
    			if (if_block2) if_block2.c();
    			t6 = space();
    			if (if_block3) if_block3.c();
    			t7 = space();
    			if (if_block4) if_block4.c();
    			t8 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file, 460, 8, 19493);
    			attr_dev(i, "class", "icon-question cc-module-icon");
    			add_location(i, file, 462, 11, 19637);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "href", a_href_value = /*HELP*/ ctx[7].switchTitle.url);
    			add_location(a, file, 461, 8, 19561);
    			set_custom_element_data(sl_tooltip, "class", "svelte-dfjd7v");
    			add_location(sl_tooltip, file, 459, 6, 19471);
    			add_location(small, file, 486, 6, 20465);
    			attr_dev(div1, "class", "cc-switch-title svelte-dfjd7v");
    			add_location(div1, file, 458, 4, 19434);
    			attr_dev(div2, "class", "cc-switch-container svelte-dfjd7v");
    			add_location(div2, file, 457, 2, 19395);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, sl_tooltip);
    			append_dev(sl_tooltip, div0);
    			div0.innerHTML = raw_value;
    			append_dev(sl_tooltip, t0);
    			append_dev(sl_tooltip, a);
    			append_dev(a, i);
    			append_dev(div1, t1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t2);
    			if_block1.m(div1, null);
    			append_dev(div1, t3);
    			append_dev(div1, small);
    			append_dev(div2, t5);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t6);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div2, t7);
    			if (if_block4) if_block4.m(div2, null);
    			append_dev(div2, t8);
    			if (if_block5) if_block5.m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*HELP*/ 128) && raw_value !== (raw_value = /*HELP*/ ctx[7].switchTitle.tooltip + "")) div0.innerHTML = raw_value;
    			if (!current || dirty[0] & /*HELP*/ 128 && a_href_value !== (a_href_value = /*HELP*/ ctx[7].switchTitle.url)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (/*allDataLoaded*/ ctx[4] && !/*noCollections*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6(ctx);
    					if_block0.c();
    					if_block0.m(div1, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, t3);
    				}
    			}

    			if (/*noCollections*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_4(ctx);
    					if_block2.c();
    					if_block2.m(div2, t6);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*allDataLoaded*/ ctx[4] && /*$configStore*/ ctx[8]["ccOn"]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_3(ctx);
    					if_block3.c();
    					if_block3.m(div2, t7);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!/*ccPublished*/ ctx[11] && !/*noCollections*/ ctx[3]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_2(ctx);
    					if_block4.c();
    					if_block4.m(div2, t8);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*showConfig*/ ctx[0]) {
    				if (if_block5) {
    					if (dirty[0] & /*showConfig*/ 1) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_1(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div2, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(457:0) {#if editMode && modulesPage && canvasDataLoaded && !importedCollections}",
    		ctx
    	});

    	return block;
    }

    // (466:6) {#if allDataLoaded && !noCollections}
    function create_if_block_6(ctx) {
    	let i;
    	let i_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "id", "configShowSwitch");

    			attr_dev(i, "class", i_class_value = "" + ((/*showConfig*/ ctx[0]
    			? 'icon-mini-arrow-down'
    			: 'icon-mini-arrow-right') + " cc-module-icon"));

    			add_location(i, file, 466, 8, 19769);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "click", /*toggleConfigShow*/ ctx[14], false, false, false),
    					listen_dev(i, "keydown", /*toggleConfigShow*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*showConfig*/ 1 && i_class_value !== (i_class_value = "" + ((/*showConfig*/ ctx[0]
    			? 'icon-mini-arrow-down'
    			: 'icon-mini-arrow-right') + " cc-module-icon"))) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(466:6) {#if allDataLoaded && !noCollections}",
    		ctx
    	});

    	return block;
    }

    // (481:6) {:else}
    function create_else_block(ctx) {
    	let sl_tooltip;
    	let div;
    	let raw_value = /*HELP*/ ctx[7].studentInvisible.tooltip + "";
    	let t;
    	let i;

    	const block = {
    		c: function create() {
    			sl_tooltip = element("sl-tooltip");
    			div = element("div");
    			t = space();
    			i = element("i");
    			attr_dev(div, "slot", "content");
    			add_location(div, file, 482, 10, 20318);
    			attr_dev(i, "class", "icon-unpublish");
    			add_location(i, file, 483, 10, 20393);
    			set_custom_element_data(sl_tooltip, "class", "svelte-dfjd7v");
    			add_location(sl_tooltip, file, 481, 8, 20294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tooltip, anchor);
    			append_dev(sl_tooltip, div);
    			div.innerHTML = raw_value;
    			append_dev(sl_tooltip, t);
    			append_dev(sl_tooltip, i);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*HELP*/ 128 && raw_value !== (raw_value = /*HELP*/ ctx[7].studentInvisible.tooltip + "")) div.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tooltip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(481:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (476:6) {#if isCollectionsOn(false, $collectionsStore["VISIBILITY"])}
    function create_if_block_5(ctx) {
    	let sl_tooltip;
    	let div;
    	let raw_value = /*HELP*/ ctx[7].studentVisible.tooltip + "";
    	let t;
    	let i;

    	const block = {
    		c: function create() {
    			sl_tooltip = element("sl-tooltip");
    			div = element("div");
    			t = space();
    			i = element("i");
    			attr_dev(div, "slot", "content");
    			add_location(div, file, 477, 10, 20136);
    			attr_dev(i, "class", "icon-Solid icon-publish svelte-dfjd7v");
    			add_location(i, file, 478, 10, 20209);
    			set_custom_element_data(sl_tooltip, "class", "svelte-dfjd7v");
    			add_location(sl_tooltip, file, 476, 8, 20112);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sl_tooltip, anchor);
    			append_dev(sl_tooltip, div);
    			div.innerHTML = raw_value;
    			append_dev(sl_tooltip, t);
    			append_dev(sl_tooltip, i);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*HELP*/ 128 && raw_value !== (raw_value = /*HELP*/ ctx[7].studentVisible.tooltip + "")) div.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sl_tooltip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(476:6) {#if isCollectionsOn(false, $collectionsStore[\\\"VISIBILITY\\\"])}",
    		ctx
    	});

    	return block;
    }

    // (490:4) {#if noCollections}
    function create_if_block_4(ctx) {
    	let label;
    	let sl_switch;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			sl_switch = element("sl-switch");
    			set_custom_element_data(sl_switch, "id", "cc-switch");
    			set_custom_element_data(sl_switch, "class", "svelte-dfjd7v");
    			add_location(sl_switch, file, 491, 8, 20596);
    			attr_dev(label, "class", "cc-switch svelte-dfjd7v");
    			attr_dev(label, "for", "cc-switch");
    			add_location(label, file, 490, 6, 20545);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, sl_switch);

    			if (!mounted) {
    				dispose = listen_dev(sl_switch, "sl-change", /*initialiseCollections*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(490:4) {#if noCollections}",
    		ctx
    	});

    	return block;
    }

    // (495:4) {#if allDataLoaded && $configStore["ccOn"]}
    function create_if_block_3(ctx) {
    	let div;
    	let button;
    	let t;
    	let button_class_value;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t = text("Save");

    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*$configStore*/ ctx[8]["needToSaveCollections"]
    			? "cc-active-save-button"
    			: "cc-save-button") + " svelte-dfjd7v"));

    			attr_dev(button, "id", "cc-save-button");
    			button.disabled = button_disabled_value = !/*$configStore*/ ctx[8]["needToSaveCollections"];
    			add_location(button, file, 496, 8, 20776);
    			attr_dev(div, "class", "cc-save svelte-dfjd7v");
    			add_location(div, file, 495, 6, 20745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*collectionsDetails*/ ctx[6].saveCollections(/*$collectionsStore*/ ctx[9], /*$configStore*/ ctx[8]["editMode"], /*$configStore*/ ctx[8]["needToSaveCollections"], /*completeSaveCollections*/ ctx[13]))) /*collectionsDetails*/ ctx[6].saveCollections(/*$collectionsStore*/ ctx[9], /*$configStore*/ ctx[8]["editMode"], /*$configStore*/ ctx[8]["needToSaveCollections"], /*completeSaveCollections*/ ctx[13]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$configStore*/ 256 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$configStore*/ ctx[8]["needToSaveCollections"]
    			? "cc-active-save-button"
    			: "cc-save-button") + " svelte-dfjd7v"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty[0] & /*$configStore*/ 256 && button_disabled_value !== (button_disabled_value = !/*$configStore*/ ctx[8]["needToSaveCollections"])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(495:4) {#if allDataLoaded && $configStore[\\\"ccOn\\\"]}",
    		ctx
    	});

    	return block;
    }

    // (512:4) {#if !ccPublished && !noCollections}
    function create_if_block_2(ctx) {
    	let div1;
    	let sl_tooltip;
    	let div0;
    	let raw_value = /*HELP*/ ctx[7].unpublished.tooltip + "";
    	let t0;
    	let a0;
    	let i;
    	let a0_href_value;
    	let t1;
    	let a1;
    	let sl_button;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			sl_tooltip = element("sl-tooltip");
    			div0 = element("div");
    			t0 = space();
    			a0 = element("a");
    			i = element("i");
    			t1 = space();
    			a1 = element("a");
    			sl_button = element("sl-button");
    			sl_button.textContent = "unpublished";
    			attr_dev(div0, "slot", "content");
    			add_location(div0, file, 514, 10, 21417);
    			attr_dev(i, "class", "icon-question cc-module-icon");
    			add_location(i, file, 520, 13, 21643);
    			attr_dev(a0, "id", "cc-about-unpublished");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			attr_dev(a0, "href", a0_href_value = /*HELP*/ ctx[7].unpublished.url);
    			add_location(a0, file, 515, 10, 21487);
    			set_custom_element_data(sl_tooltip, "trigger", "hover focus");
    			set_custom_element_data(sl_tooltip, "class", "svelte-dfjd7v");
    			add_location(sl_tooltip, file, 513, 8, 21371);
    			set_custom_element_data(sl_button, "pill", "");
    			set_custom_element_data(sl_button, "size", "small");
    			set_custom_element_data(sl_button, "variant", "warning");
    			add_location(sl_button, file, 524, 10, 21810);
    			attr_dev(a1, "href", /*collectionsConfigUrl*/ ctx[12]);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			add_location(a1, file, 523, 8, 21734);
    			attr_dev(div1, "class", "cc-unpublished svelte-dfjd7v");
    			add_location(div1, file, 512, 6, 21333);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, sl_tooltip);
    			append_dev(sl_tooltip, div0);
    			div0.innerHTML = raw_value;
    			append_dev(sl_tooltip, t0);
    			append_dev(sl_tooltip, a0);
    			append_dev(a0, i);
    			append_dev(div1, t1);
    			append_dev(div1, a1);
    			append_dev(a1, sl_button);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*HELP*/ 128 && raw_value !== (raw_value = /*HELP*/ ctx[7].unpublished.tooltip + "")) div0.innerHTML = raw_value;
    			if (dirty[0] & /*HELP*/ 128 && a0_href_value !== (a0_href_value = /*HELP*/ ctx[7].unpublished.url)) {
    				attr_dev(a0, "href", a0_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(512:4) {#if !ccPublished && !noCollections}",
    		ctx
    	});

    	return block;
    }

    // (529:4) {#if showConfig}
    function create_if_block_1(ctx) {
    	let div;
    	let collectionsconfiguration;
    	let current;
    	collectionsconfiguration = new CollectionsConfiguration({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(collectionsconfiguration.$$.fragment);
    			attr_dev(div, "id", "cc-config");
    			attr_dev(div, "class", "border border-trbl svelte-dfjd7v");
    			add_location(div, file, 529, 6, 21949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(collectionsconfiguration, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collectionsconfiguration.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collectionsconfiguration.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(collectionsconfiguration);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(529:4) {#if showConfig}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*editMode*/ ctx[1] && /*modulesPage*/ ctx[2] && /*canvasDataLoaded*/ ctx[10] && !/*importedCollections*/ ctx[5] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "beforeunload", /*beforeUnload*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*editMode*/ ctx[1] && /*modulesPage*/ ctx[2] && /*canvasDataLoaded*/ ctx[10] && !/*importedCollections*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*editMode, modulesPage, canvasDataLoaded, importedCollections*/ 1062) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const TIME_BETWEEN_SAVES = 10000;
    const TIME_BETWEEN_CANVAS_REFRESH = 15000;
    const AUTO_SAVE = true;
    const EXIT_SAVE = true;

    /**
     * @function isCollectionsOn
     * @param {boolean} editMode  - based on canvas environment
     * @param {string} visibility - collections configuration:
     *      no-one, students, teachers, all
     * @returns {boolean} - true if based on the combination of editMode and visibility
     * @description Conditions
     * - if !editMode (i.e. students)
     *   - false/true === visibility not in ["students","all"]
     * - if editMode (i.e. teacher)
     *   - false if visibility in ["no-one","students"]
     *   - true otherwise
     */
    function isCollectionsOn(editMode, visibility) {
    	if (visibility === "no-one") {
    		return false;
    	}

    	if (!editMode) {
    		// return true if visibility is either 'student' or 'all'
    		return visibility === "students" || visibility === "all";
    	} else {
    		// return true if visibility is either 'teacher' or 'all'
    		return visibility === "teachers" || visibility === "all";
    	}
    }

    function instance($$self, $$props, $$invalidate) {
    	let $configStore;
    	let $collectionsStore;
    	let $modulesStore;
    	validate_store(configStore, 'configStore');
    	component_subscribe($$self, configStore, $$value => $$invalidate(8, $configStore = $$value));
    	validate_store(collectionsStore, 'collectionsStore');
    	component_subscribe($$self, collectionsStore, $$value => $$invalidate(9, $collectionsStore = $$value));
    	validate_store(modulesStore, 'modulesStore');
    	component_subscribe($$self, modulesStore, $$value => $$invalidate(26, $modulesStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CanvasCollections', slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	setBasePath("../node_modules/@shoelace-style/shoelace/dist/");
    	let { courseId } = $$props;
    	let { editMode } = $$props;
    	let { csrfToken } = $$props;
    	let { modulesPage } = $$props;
    	let { showConfig } = $$props;
    	let checked = false;

    	set_store_value(
    		configStore,
    		$configStore = {
    			courseId,
    			editMode,
    			csrfToken,
    			modulesPage,
    			currentCollection: "",
    			needToSaveCollections: false,
    			ccOn: false
    		},
    		$configStore
    	);

    	let collectionsConfigUrl = `/courses/${$configStore["courseId"]}/pages/canvas-collections-configuration`;
    	let noCollections = true;

    	// track whether the intervals have been set
    	// Making sure we don't get multiple intervals running
    	let saveIntervalOn = false;

    	let refreshIntervalOn = false;

    	// whether or data canvas and collections data loaded
    	let canvasDataLoaded = false;

    	let collectionsDataLoaded = false;
    	let allDataLoaded = false;
    	let importedCollections = false;

    	// the actual data objects for canvas and collections data
    	let canvasDetails = null;

    	let collectionsDetails = null;
    	let saveInterval = null;
    	let refreshCanvasDetails = null;
    	let ccPublished = true;

    	/**
     * Callback function for when canvasDetails is loaded
     */
    	function gotCanvasDetails() {
    		$$invalidate(10, canvasDataLoaded = true);

    		// canvasDetails.courseModules is an array of Canvas module objects
    		// set $modulesStore to a dict of Canvas module objects keyed on the module id
    		set_store_value(modulesStore, $modulesStore = canvasDetails.courseModules, $modulesStore); /*.reduce((acc, module) => {
      acc[module.id] = module;
      return acc;
    }, {}); */

    		checkAllDataLoaded();
    	}

    	/**
     * @function gotCollectionsDetails
     * @param {string} status - undefined if working, others a label for an error
     * @description Called by CollectionsDetails when the collections data
     * has been retrieved or if there were problems
     */
    	function gotCollectionsDetails(status = "") {
    		/*
    if (status === "no collections config") {
      // if collectionsDetails has errors and editMode are true
      // call CollectionsDetails::initialiseConfigPage
      if ($configStore["editMode"]) {
        collectionsDetails.initialiseConfigPage();
      }
      // reset status to empty string, since we've emulated loading config
      // we can proceed as normal
      status = "";
    } */
    		if (status === "") {
    			$$invalidate(3, noCollections = false);

    			//----- Range of updates to local data based on the now retrieved collections JSON
    			//ccOn = collectionsDetails.ccOn;
    			//$configStore["ccOn"] = collectionsDetails.ccOn;
    			set_store_value(configStore, $configStore["ccOn"] = isCollectionsOn($configStore["editMode"], collectionsDetails.collections["VISIBILITY"]), $configStore);

    			$$invalidate(11, ccPublished = collectionsDetails.ccPublished);
    			set_store_value(configStore, $configStore["currentCollection"] = collectionsDetails.getCurrentCollection(), $configStore);

    			if (collectionsDetails.isImportedCollection()) {
    				$$invalidate(5, importedCollections = true);
    			} /*        toastAlert(
      `<p>Collection's
      <a href="/courses/${courseId}}/pages/canvas-collections-configuration" target="_blank" rel="noreferrer">
        configuration page</a> has been imported from
      another course.</p>
      <p>The next step will be to review and update the information for this course.</p>`,
      "warning"
    ); */

    			// if a student is viewing and no collections, then limit what is done
    			if (!(!$configStore["ccOn"] && !$configStore["editMode"])) {
    				collectionsDataLoaded = true;
    				checkAllDataLoaded();
    			}
    		}
    	}

    	/**
     * @function checkAllDataLoaded
     * @description Called by both gotCanvasDetails and gotCollectionsDetails will
     * check if both have finished. If so it will
     * 1. Add the collections display (if collections is turned on)
     * 2. use setInterval to check if collections needs to be saved (if ccOn and editMode)
     */
    	function checkAllDataLoaded() {
    		if (canvasDataLoaded && collectionsDataLoaded) {
    			// if we've imported collections, we need to handle that first
    			// - depending on what we find, it might be better to move this
    			// to after the initial processing
    			// - but we do probably want to wait until both canvas and collections data is loaded
    			if (collectionsDetails.isImportedCollection()) {
    				addProcessImportedCollections();
    			} else if (!noCollections) {
    				// Only do all this if able to load collections configuration, otherwise
    				// leave the interface and set up as basic until user hits the switch
    				// add in some Canvas module data to the collections module data
    				collectionsDetails.addCanvasModuleData(canvasDetails.courseModules, $configStore["editMode"]);

    				set_store_value(collectionsStore, $collectionsStore = collectionsDetails.collections, $collectionsStore);
    				calculateActualNum(canvasDetails.courseModules, $collectionsStore["MODULES"]);
    				checked = $configStore["ccOn"];

    				if ($configStore["ccOn"]) {
    					addCollectionsDisplay();

    					// set up auto save for collections config
    					if ($configStore["editMode"] && AUTO_SAVE && !saveIntervalOn) {
    						saveIntervalOn = true;

    						// only if we're in editMode and auto save is on
    						saveInterval = setInterval(
    							() => {
    								collectionsDetails.saveCollections($collectionsStore, $configStore["editMode"], $configStore["needToSaveCollections"], completeSaveCollections);
    							},
    							TIME_BETWEEN_SAVES
    						);
    					}

    					if (!refreshIntervalOn && EXIT_SAVE) {
    						refreshIntervalOn = true;

    						// set up auto refresh of canvasDetails
    						refreshCanvasDetails = setInterval(
    							() => {
    								canvasDetails.refreshCanvasDetails(gotCanvasDetails);
    							},
    							TIME_BETWEEN_CANVAS_REFRESH
    						);
    					}
    				}
    			}

    			// all data is essentially loaded, however, there may be noCollections
    			$$invalidate(4, allDataLoaded = true);
    		}
    	}

    	/**
     * @function addProcessImportedCollections
     * @description Detected an imported collections configuration, need to
     * - stop allDataLoaded and the normal collections configuration commencing
     * - add the ProcessImportedCollections component to div#context_modules
     * - let it do its thing
     * - figure out someway to get started again
     */
    	function addProcessImportedCollections() {
    		// find div#context_modules
    		const contextModules = document.getElementById("context_modules");

    		if (contextModules) {
    			// add the ProcessImportedCollections component
    			new ProcessImportedCollections({
    					target: contextModules,
    					props: { collectionsDetails }
    				});
    		} else {
    			alert("Unable to find div#context_modules");
    		}
    	}

    	/**
     * @function completeMigration
     * @description Called once the ProcessImportedCollection component has
     * been closed by the user with them making one of three choices
     * - proceed - update the collections configuration and set up collections
     * - cancel - do nothing
     * - refresh - empty out the collections configuration and set up collections
     */
    	function completeMigration() {
    		// save the outcome and remove it from configStore so this is only called once
    		const outcome = $configStore["migrationOutcome"];

    		set_store_value(configStore, $configStore["lastMigrationOutcome"] = outcome, $configStore);
    		delete $configStore["migrationOutcome"];

    		if (outcome === "cancel") {
    			return;
    		} else if (outcome === "refresh") {
    			// TODO probably with the dialog not closing
    			$$invalidate(5, importedCollections = false);

    			collectionsDetails.resetImport();
    			initialiseCollections();
    		} else if (outcome === "proceed") {
    			collectionsDetails.migrateCollectionsConfiguration(); // TODO need to do something to refresh the page - show collections
    			collectionsDetails.resetImport();
    			$$invalidate(5, importedCollections = false);
    			gotCollectionsDetails("");
    			collectionsDetails.saveCollections($collectionsStore, true, true, completeImportCollections);
    		}
    	}

    	function completeImportCollections(status) {
    		if (status) {
    			toastAlert(
    				`<p>The import of Collection's 
        <a href="/courses/${courseId}}/pages/canvas-collections-configuration" target="_blank" rel="noreferrer">
          configuration</a> has been successful.</p>`,
    				"success"
    			);
    		}
    	}

    	function completeSaveCollections(status) {
    		if (status) {
    			set_store_value(configStore, $configStore["needToSaveCollections"] = false, $configStore);
    		}
    	}

    	/**
     * @function toggleConfigShow
     * @param e - the event object
     * @description Called when the config show/hide button is clicked
     * 1. Show/hide the CanvasCollectionsConfiguration component depending on state
     */
    	function toggleConfigShow(e) {
    		$$invalidate(0, showConfig = !showConfig);
    	}

    	/**
     * @function initialiseCollections
     * @description Called when there was previous noCollections configuration and
     * the user has turned the switch to on
     * - initialise the config page
     * - update the internal data
     * From this stage everything else should proceed as normal
     */
    	function initialiseCollections() {
    		// set up an empty collections configuration
    		collectionsDetails.initialiseCollectionsConfig();

    		// we now have collections
    		$$invalidate(3, noCollections = false);

    		// and we can do the set up again
    		gotCollectionsDetails("");

    		collectionsDetails.saveCollections($collectionsStore, true, true, completeInitialiseConfigPage);
    	}

    	/**
     * @function completeInitialiseConfigPage
     * @param status - boolean
     * @description Called after an attempt to save the new config page
     * Inform the user of the outcome
     */
    	function completeInitialiseConfigPage(status) {
    		if (status) {
    			toastAlert(
    				`<p>Canvas Collections is now on.</p>
        <p>A new <a target="_blank" rel="noreferrer" 
      href="/courses/${courseId}/pages/canvas-collections-configuration">
      Canvas Collections Configuration page</a> created. It will be used to store
      Collections data. </p>
      <p>The page needs to be published before students can see Collections.
      <p>Removing this page will turn collections off.</p>`,
    				"success"
    			);
    		} else {
    			toastAlert(`<p>Failed to create new Canvas Collections Configuration page</p>`, "danger");
    		}
    	}

    	/**
     * Modify the canvas modules page by
     * - Adding <CanvasCollectionsRepresentation> at top of div#context_modules
     * - Add a <CollectionsModuleConfiguration> for each canvas module belonging to
     *   the currently visible collection
     * - hiding modules not part of the current visible collection
     */
    	function addCollectionsDisplay() {
    		// add the representation div
    		const div = addCollectionsRepresentation();

    		if (div) {
    			new CanvasCollectionsRepresentation({ target: div });
    		}
    	}

    	/**
     *  Modify the Canvas modules page by reversing what addCollectionsDisplay does
     */
    	function removeCollectionsDisplay() {
    		removeCollectionsRepresentation();
    		removeModuleConfiguration($collectionsStore["MODULES"]);
    	}

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		// grab all the canvas course module related information
    		// canvasDetails
    		// - courseObject
    		// - modules
    		if (modulesPage) {
    			canvasDetails = new CanvasDetails(gotCanvasDetails, { courseId, csrfToken });
    			$$invalidate(6, collectionsDetails = new CollectionsDetails(gotCollectionsDetails, { courseId, csrfToken }));
    		}
    	}));

    	/**
     * @function onDestroy
     * @description If there is a saveInterval, then clear it
     * TODO not really sure this is needed, as I don't explicitly destroy the
     * component and it may not be a problem when navigating away
     */
    	onDestroy(() => {
    		if (saveInterval) {
    			clearInterval(saveInterval);
    		}

    		if (refreshCanvasDetails) {
    			clearInterval(refreshCanvasDetails);
    		}
    	});

    	/**
     * @function beforeUnload
     * @param event
     * @description If when leaving the page there are unsaved changes, then
     * save them
     */
    	function beforeUnload(event) {
    		if ($configStore["needToSaveCollections"]) {
    			event.preventDefault();
    			collectionsDetails.saveCollections($collectionsStore, $configStore["editMode"], $configStore["needToSaveCollections"], completeSaveCollections);
    		}
    	}

    	let HELP = {
    		ABOUT: {
    			tooltip: `<p>Use Canvas Collections to customise the modules page to better
          fit your design, by:</p>
          <ol>
             <li> Grouping modules into different collections. </li>
             <li> Using different representations for each collection. </li>
             <li> Adding more contextual information about each module. </li>
          </ol>`
    		},
    		studentVisible: {
    			tooltip: `<p>Students can see Collections.</p>
      <p>To change, click the <i class="icon-mini-arrow-right"></i> icon to the right
        and use the <em>visibility</em> dropdown to select <em>teachers</em> or <em>none</em>.</p>`
    		},
    		studentInvisible: {
    			tooltip: `<p>Students <strong>cannot</strong> see Collections.</p>
      <p>To change, click the <i class="icon-mini-arrow-right"></i> icon to the right
        and use the <em>visibility</em> dropdown to select <em>students</em> or <em>all</em>.</p>`
    		},
    		switchTitle: {
    			tooltip: "",
    			url: "https://djplaner.github.io/canvas-collections/"
    		},
    		unpublished: {
    			tooltip: `<p>The <em>Canvas Collections Configuration</em> page</a> is unpublished.
        (Click the <em>unpublished</em> button to publish the page) </p> 
        <p>Meaning live Collections will <strong>not</strong> be visible in 
          "Student View" or for students.</p> 
          <p>Any Claytons Collections will be visible, if the relevant pages are published.</p>`,
    			url: "https://djplaner.github.io/canvas-collections/reference/visibility/"
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (courseId === undefined && !('courseId' in $$props || $$self.$$.bound[$$self.$$.props['courseId']])) {
    			console.warn("<CanvasCollections> was created without expected prop 'courseId'");
    		}

    		if (editMode === undefined && !('editMode' in $$props || $$self.$$.bound[$$self.$$.props['editMode']])) {
    			console.warn("<CanvasCollections> was created without expected prop 'editMode'");
    		}

    		if (csrfToken === undefined && !('csrfToken' in $$props || $$self.$$.bound[$$self.$$.props['csrfToken']])) {
    			console.warn("<CanvasCollections> was created without expected prop 'csrfToken'");
    		}

    		if (modulesPage === undefined && !('modulesPage' in $$props || $$self.$$.bound[$$self.$$.props['modulesPage']])) {
    			console.warn("<CanvasCollections> was created without expected prop 'modulesPage'");
    		}

    		if (showConfig === undefined && !('showConfig' in $$props || $$self.$$.bound[$$self.$$.props['showConfig']])) {
    			console.warn("<CanvasCollections> was created without expected prop 'showConfig'");
    		}
    	});

    	const writable_props = ['courseId', 'editMode', 'csrfToken', 'modulesPage', 'showConfig'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CanvasCollections> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('courseId' in $$props) $$invalidate(17, courseId = $$props.courseId);
    		if ('editMode' in $$props) $$invalidate(1, editMode = $$props.editMode);
    		if ('csrfToken' in $$props) $$invalidate(18, csrfToken = $$props.csrfToken);
    		if ('modulesPage' in $$props) $$invalidate(2, modulesPage = $$props.modulesPage);
    		if ('showConfig' in $$props) $$invalidate(0, showConfig = $$props.showConfig);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		ProcessImportedCollections,
    		collectionsStore,
    		modulesStore,
    		configStore,
    		CanvasCollectionsRepresentation,
    		CollectionsConfiguration,
    		onMount,
    		onDestroy,
    		addCollectionsRepresentation,
    		removeCollectionsRepresentation,
    		removeModuleConfiguration,
    		CanvasDetails,
    		CollectionsDetails,
    		calculateActualNum,
    		toastAlert,
    		setBasePath,
    		TIME_BETWEEN_SAVES,
    		TIME_BETWEEN_CANVAS_REFRESH,
    		AUTO_SAVE,
    		EXIT_SAVE,
    		courseId,
    		editMode,
    		csrfToken,
    		modulesPage,
    		showConfig,
    		checked,
    		collectionsConfigUrl,
    		noCollections,
    		saveIntervalOn,
    		refreshIntervalOn,
    		canvasDataLoaded,
    		collectionsDataLoaded,
    		allDataLoaded,
    		importedCollections,
    		canvasDetails,
    		collectionsDetails,
    		saveInterval,
    		refreshCanvasDetails,
    		ccPublished,
    		gotCanvasDetails,
    		gotCollectionsDetails,
    		checkAllDataLoaded,
    		addProcessImportedCollections,
    		completeMigration,
    		completeImportCollections,
    		isCollectionsOn,
    		completeSaveCollections,
    		toggleConfigShow,
    		initialiseCollections,
    		completeInitialiseConfigPage,
    		addCollectionsDisplay,
    		removeCollectionsDisplay,
    		beforeUnload,
    		HELP,
    		$configStore,
    		$collectionsStore,
    		$modulesStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
    		if ('courseId' in $$props) $$invalidate(17, courseId = $$props.courseId);
    		if ('editMode' in $$props) $$invalidate(1, editMode = $$props.editMode);
    		if ('csrfToken' in $$props) $$invalidate(18, csrfToken = $$props.csrfToken);
    		if ('modulesPage' in $$props) $$invalidate(2, modulesPage = $$props.modulesPage);
    		if ('showConfig' in $$props) $$invalidate(0, showConfig = $$props.showConfig);
    		if ('checked' in $$props) checked = $$props.checked;
    		if ('collectionsConfigUrl' in $$props) $$invalidate(12, collectionsConfigUrl = $$props.collectionsConfigUrl);
    		if ('noCollections' in $$props) $$invalidate(3, noCollections = $$props.noCollections);
    		if ('saveIntervalOn' in $$props) saveIntervalOn = $$props.saveIntervalOn;
    		if ('refreshIntervalOn' in $$props) refreshIntervalOn = $$props.refreshIntervalOn;
    		if ('canvasDataLoaded' in $$props) $$invalidate(10, canvasDataLoaded = $$props.canvasDataLoaded);
    		if ('collectionsDataLoaded' in $$props) collectionsDataLoaded = $$props.collectionsDataLoaded;
    		if ('allDataLoaded' in $$props) $$invalidate(4, allDataLoaded = $$props.allDataLoaded);
    		if ('importedCollections' in $$props) $$invalidate(5, importedCollections = $$props.importedCollections);
    		if ('canvasDetails' in $$props) canvasDetails = $$props.canvasDetails;
    		if ('collectionsDetails' in $$props) $$invalidate(6, collectionsDetails = $$props.collectionsDetails);
    		if ('saveInterval' in $$props) saveInterval = $$props.saveInterval;
    		if ('refreshCanvasDetails' in $$props) refreshCanvasDetails = $$props.refreshCanvasDetails;
    		if ('ccPublished' in $$props) $$invalidate(11, ccPublished = $$props.ccPublished);
    		if ('HELP' in $$props) $$invalidate(7, HELP = $$props.HELP);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*allDataLoaded, importedCollections, $configStore, $collectionsStore*/ 816) {
    			// Update ccOn when visibility/editmode change
    			{
    				if (allDataLoaded && !importedCollections) {
    					set_store_value(configStore, $configStore["ccOn"] = isCollectionsOn($configStore["editMode"], $collectionsStore["VISIBILITY"]), $configStore);

    					if ($configStore["ccOn"] && allDataLoaded && $collectionsStore["COLLECTIONS_ORDER"].length > 0) {
    						addCollectionsDisplay();
    					} else {
    						removeCollectionsDisplay();
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$configStore, noCollections, HELP*/ 392) {
    			{
    				if ($configStore.hasOwnProperty("migrationOutcome")) {
    					completeMigration();
    				}

    				// recatively update the tooltip for the switch title depending on whether
    				// collections is on or off
    				if (noCollections) {
    					$$invalidate(
    						7,
    						HELP.switchTitle.tooltip = `${HELP.ABOUT.tooltip} <p>Click on the</p>
      <ul> <li> question mark to learn more.</li>
          <li> switch to turn Collections on.</li></ul>`,
    						HELP
    					);
    				} else {
    					$$invalidate(7, HELP.switchTitle.tooltip = HELP.ABOUT.tooltip, HELP);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$configStore, allDataLoaded, importedCollections, collectionsDetails*/ 368) {
    			// Whenever currentCollection is changed, save the last collection viewed
    			// into local storage
    			{
    				let lastViewedCollection = $configStore["currentCollection"];

    				if (allDataLoaded && !importedCollections) {
    					collectionsDetails.saveLastCollectionViewed(lastViewedCollection);
    				}
    			}
    		}
    	};

    	return [
    		showConfig,
    		editMode,
    		modulesPage,
    		noCollections,
    		allDataLoaded,
    		importedCollections,
    		collectionsDetails,
    		HELP,
    		$configStore,
    		$collectionsStore,
    		canvasDataLoaded,
    		ccPublished,
    		collectionsConfigUrl,
    		completeSaveCollections,
    		toggleConfigShow,
    		initialiseCollections,
    		beforeUnload,
    		courseId,
    		csrfToken
    	];
    }

    class CanvasCollections extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance,
    			create_fragment,
    			safe_not_equal,
    			{
    				courseId: 17,
    				editMode: 1,
    				csrfToken: 18,
    				modulesPage: 2,
    				showConfig: 0
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CanvasCollections",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get courseId() {
    		throw new Error("<CanvasCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set courseId(value) {
    		throw new Error("<CanvasCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editMode() {
    		throw new Error("<CanvasCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editMode(value) {
    		throw new Error("<CanvasCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get csrfToken() {
    		throw new Error("<CanvasCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set csrfToken(value) {
    		throw new Error("<CanvasCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modulesPage() {
    		throw new Error("<CanvasCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modulesPage(value) {
    		throw new Error("<CanvasCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showConfig() {
    		throw new Error("<CanvasCollections>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showConfig(value) {
    		throw new Error("<CanvasCollections>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Entry point for CanvasCollections
     * - Check the URL and page contents extract some context
     * - insert div.canvas-collections as the first child of div.right-of-crumbs
     * - add the CanvasCollections app to that div
     */
    // extract some useful context from the URL and the DOM
    const context = checkContext();
    let app = null;
    // Only do this on the modules page
    if (context.modulesPage) {
        // insert the app as the first content of div.right-of-crumbs
        const rightOfCrumbs = document.querySelector(".right-of-crumbs");
        // TODO
        // - should more checks be done here?
        // - e.g. URL etc
        if (!rightOfCrumbs) {
            throw new Error("div.right-of-crumbs not found");
        }
        const div = document.createElement("div");
        div.className = "canvas-collections";
        div.style.display = "flex";
        rightOfCrumbs.appendChild(div);
        app = new CanvasCollections({
            target: div,
            props: context,
        });
    }
    var app$1 = app;

    return app$1;

}());
